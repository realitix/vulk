
#include <Python.h>
#include <dlfcn.h>

#define VK_NO_PROTOTYPES

#if defined(ANDROID) || defined (__ANDROID__)
  #define VK_USE_PLATFORM_ANDROID_KHR 1
#elif defined(_WIN32)
  #define VK_USE_PLATFORM_WIN32_KHR 1
#elif defined(__linux__)
  #define VK_USE_PLATFORM_XLIB_KHR 1
#endif

#ifdef __unix__

#define LOAD_SDK() dlopen("libvulkan.so", RTLD_NOW);

#elif defined(_WIN32) || defined(WIN32)

#define LOAD_SDK() LoadLibrary("vulkan-1.dll");
#define dlsym GetProcAddress

#endif

// BEGIN VULKAN PLATEFORM
//
// File: vk_platform.h
//
/*
** Copyright (c) 2014-2015 The Khronos Group Inc.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/


#ifndef VK_PLATFORM_H_
#define VK_PLATFORM_H_

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

/*
***************************************************************************************************
*   Platform-specific directives and type declarations
***************************************************************************************************
*/

/* Platform-specific calling convention macros.
 *
 * Platforms should define these so that Vulkan clients call Vulkan commands
 * with the same calling conventions that the Vulkan implementation expects.
 *
 * VKAPI_ATTR - Placed before the return type in function declarations.
 *              Useful for C++11 and GCC/Clang-style function attribute syntax.
 * VKAPI_CALL - Placed after the return type in function declarations.
 *              Useful for MSVC-style calling convention syntax.
 * VKAPI_PTR  - Placed between the '(' and '*' in function pointer types.
 *
 * Function declaration:  VKAPI_ATTR void VKAPI_CALL vkCommand(void);
 * Function pointer type: typedef void (VKAPI_PTR *PFN_vkCommand)(void);
 */
#if defined(_WIN32)
    // On Windows, Vulkan commands use the stdcall convention
    #define VKAPI_ATTR
    #define VKAPI_CALL __stdcall
    #define VKAPI_PTR  VKAPI_CALL
#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH < 7
    #error "Vulkan isn't supported for the 'armeabi' NDK ABI"
#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH >= 7 && __ARM_32BIT_STATE
    // On Android 32-bit ARM targets, Vulkan functions use the "hardfloat"
    // calling convention, i.e. float parameters are passed in registers. This
    // is true even if the rest of the application passes floats on the stack,
    // as it does by default when compiling for the armeabi-v7a NDK ABI.
    #define VKAPI_ATTR __attribute__((pcs("aapcs-vfp")))
    #define VKAPI_CALL
    #define VKAPI_PTR  VKAPI_ATTR
#else
    // On other platforms, use the default calling convention
    #define VKAPI_ATTR
    #define VKAPI_CALL
    #define VKAPI_PTR
#endif

#include <stddef.h>

#if !defined(VK_NO_STDINT_H)
    #if defined(_MSC_VER) && (_MSC_VER < 1600)
        typedef signed   __int8  int8_t;
        typedef unsigned __int8  uint8_t;
        typedef signed   __int16 int16_t;
        typedef unsigned __int16 uint16_t;
        typedef signed   __int32 int32_t;
        typedef unsigned __int32 uint32_t;
        typedef signed   __int64 int64_t;
        typedef unsigned __int64 uint64_t;
    #else
        #include <stdint.h>
    #endif
#endif // !defined(VK_NO_STDINT_H)

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

// Platform-specific headers required by platform window system extensions.
// These are enabled prior to #including "vulkan.h". The same enable then
// controls inclusion of the extension interfaces in vulkan.h.

#ifdef VK_USE_PLATFORM_ANDROID_KHR
#include <android/native_window.h>
#endif

#ifdef VK_USE_PLATFORM_MIR_KHR
#include <mir_toolkit/client_types.h>
#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
#include <wayland-client.h>
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
#include <windows.h>
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
#include <X11/Xlib.h>
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR
#include <xcb/xcb.h>
#endif

#endif
// END VULKAN PLATEFORM
// BEGIN VULKAN H
#ifndef VULKAN_H_
#define VULKAN_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright (c) 2015-2016 The Khronos Group Inc.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/

/*
** This header is generated from the Khronos Vulkan XML API Registry.
**
*/


#define VK_VERSION_1_0 1

#define VK_MAKE_VERSION(major, minor, patch) \
    (((major) << 22) | ((minor) << 12) | (patch))

// DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead.
//#define VK_API_VERSION VK_MAKE_VERSION(1, 0, 0)

// Vulkan 1.0 version number
#define VK_API_VERSION_1_0 VK_MAKE_VERSION(1, 0, 0)

#define VK_VERSION_MAJOR(version) ((uint32_t)(version) >> 22)
#define VK_VERSION_MINOR(version) (((uint32_t)(version) >> 12) & 0x3ff)
#define VK_VERSION_PATCH(version) ((uint32_t)(version) & 0xfff)
// Version of this file
#define VK_HEADER_VERSION 25


#define VK_NULL_HANDLE 0
        


#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;


#if !defined(VK_DEFINE_NON_DISPATCHABLE_HANDLE)
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
#endif
        


typedef uint32_t VkFlags;
typedef uint32_t VkBool32;
typedef uint64_t VkDeviceSize;
typedef uint32_t VkSampleMask;

VK_DEFINE_HANDLE(VkInstance)
VK_DEFINE_HANDLE(VkPhysicalDevice)
VK_DEFINE_HANDLE(VkDevice)
VK_DEFINE_HANDLE(VkQueue)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore)
VK_DEFINE_HANDLE(VkCommandBuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFence)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkEvent)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkQueryPool)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBufferView)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkShaderModule)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineCache)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkRenderPass)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipeline)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSampler)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSet)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool)

#define VK_LOD_CLAMP_NONE                 1000.0f
#define VK_REMAINING_MIP_LEVELS           (~0U)
#define VK_REMAINING_ARRAY_LAYERS         (~0U)
#define VK_WHOLE_SIZE                     (~0ULL)
#define VK_ATTACHMENT_UNUSED              (~0U)
#define VK_TRUE                           1
#define VK_FALSE                          0
#define VK_QUEUE_FAMILY_IGNORED           (~0U)
#define VK_SUBPASS_EXTERNAL               (~0U)
#define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE  256
#define VK_UUID_SIZE                      16
#define VK_MAX_MEMORY_TYPES               32
#define VK_MAX_MEMORY_HEAPS               16
#define VK_MAX_EXTENSION_NAME_SIZE        256
#define VK_MAX_DESCRIPTION_SIZE           256


typedef enum VkPipelineCacheHeaderVersion {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
    VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE = (VK_PIPELINE_CACHE_HEADER_VERSION_ONE - VK_PIPELINE_CACHE_HEADER_VERSION_ONE + 1),
    VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7FFFFFFF
} VkPipelineCacheHeaderVersion;

typedef enum VkResult {
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_FRAGMENTED_POOL = -12,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_ERROR_INVALID_SHADER_NV = -1000012000,
    VK_RESULT_BEGIN_RANGE = VK_ERROR_FRAGMENTED_POOL,
    VK_RESULT_END_RANGE = VK_INCOMPLETE,
    VK_RESULT_RANGE_SIZE = (VK_INCOMPLETE - VK_ERROR_FRAGMENTED_POOL + 1),
    VK_RESULT_MAX_ENUM = 0x7FFFFFFF
} VkResult;

typedef enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_VALIDATION_FLAGS_EXT = 1000011002,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
    VK_STRUCTURE_TYPE_BEGIN_RANGE = VK_STRUCTURE_TYPE_APPLICATION_INFO,
    VK_STRUCTURE_TYPE_END_RANGE = VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    VK_STRUCTURE_TYPE_RANGE_SIZE = (VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO - VK_STRUCTURE_TYPE_APPLICATION_INFO + 1),
    VK_STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkStructureType;

typedef enum VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
    VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
    VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
    VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = (VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE - VK_SYSTEM_ALLOCATION_SCOPE_COMMAND + 1),
    VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7FFFFFFF
} VkSystemAllocationScope;

typedef enum VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
    VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
    VK_INTERNAL_ALLOCATION_TYPE_END_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
    VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = (VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE - VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE + 1),
    VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkInternalAllocationType;

typedef enum VkFormat {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
    VK_FORMAT_BEGIN_RANGE = VK_FORMAT_UNDEFINED,
    VK_FORMAT_END_RANGE = VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    VK_FORMAT_RANGE_SIZE = (VK_FORMAT_ASTC_12x12_SRGB_BLOCK - VK_FORMAT_UNDEFINED + 1),
    VK_FORMAT_MAX_ENUM = 0x7FFFFFFF
} VkFormat;

typedef enum VkImageType {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
    VK_IMAGE_TYPE_BEGIN_RANGE = VK_IMAGE_TYPE_1D,
    VK_IMAGE_TYPE_END_RANGE = VK_IMAGE_TYPE_3D,
    VK_IMAGE_TYPE_RANGE_SIZE = (VK_IMAGE_TYPE_3D - VK_IMAGE_TYPE_1D + 1),
    VK_IMAGE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkImageType;

typedef enum VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    VK_IMAGE_TILING_BEGIN_RANGE = VK_IMAGE_TILING_OPTIMAL,
    VK_IMAGE_TILING_END_RANGE = VK_IMAGE_TILING_LINEAR,
    VK_IMAGE_TILING_RANGE_SIZE = (VK_IMAGE_TILING_LINEAR - VK_IMAGE_TILING_OPTIMAL + 1),
    VK_IMAGE_TILING_MAX_ENUM = 0x7FFFFFFF
} VkImageTiling;

typedef enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
    VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE = VK_PHYSICAL_DEVICE_TYPE_OTHER,
    VK_PHYSICAL_DEVICE_TYPE_END_RANGE = VK_PHYSICAL_DEVICE_TYPE_CPU,
    VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE = (VK_PHYSICAL_DEVICE_TYPE_CPU - VK_PHYSICAL_DEVICE_TYPE_OTHER + 1),
    VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkPhysicalDeviceType;

typedef enum VkQueryType {
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
    VK_QUERY_TYPE_BEGIN_RANGE = VK_QUERY_TYPE_OCCLUSION,
    VK_QUERY_TYPE_END_RANGE = VK_QUERY_TYPE_TIMESTAMP,
    VK_QUERY_TYPE_RANGE_SIZE = (VK_QUERY_TYPE_TIMESTAMP - VK_QUERY_TYPE_OCCLUSION + 1),
    VK_QUERY_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkQueryType;

typedef enum VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
    VK_SHARING_MODE_BEGIN_RANGE = VK_SHARING_MODE_EXCLUSIVE,
    VK_SHARING_MODE_END_RANGE = VK_SHARING_MODE_CONCURRENT,
    VK_SHARING_MODE_RANGE_SIZE = (VK_SHARING_MODE_CONCURRENT - VK_SHARING_MODE_EXCLUSIVE + 1),
    VK_SHARING_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSharingMode;

typedef enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    VK_IMAGE_LAYOUT_BEGIN_RANGE = VK_IMAGE_LAYOUT_UNDEFINED,
    VK_IMAGE_LAYOUT_END_RANGE = VK_IMAGE_LAYOUT_PREINITIALIZED,
    VK_IMAGE_LAYOUT_RANGE_SIZE = (VK_IMAGE_LAYOUT_PREINITIALIZED - VK_IMAGE_LAYOUT_UNDEFINED + 1),
    VK_IMAGE_LAYOUT_MAX_ENUM = 0x7FFFFFFF
} VkImageLayout;

typedef enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
    VK_IMAGE_VIEW_TYPE_BEGIN_RANGE = VK_IMAGE_VIEW_TYPE_1D,
    VK_IMAGE_VIEW_TYPE_END_RANGE = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
    VK_IMAGE_VIEW_TYPE_RANGE_SIZE = (VK_IMAGE_VIEW_TYPE_CUBE_ARRAY - VK_IMAGE_VIEW_TYPE_1D + 1),
    VK_IMAGE_VIEW_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkImageViewType;

typedef enum VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
    VK_COMPONENT_SWIZZLE_BEGIN_RANGE = VK_COMPONENT_SWIZZLE_IDENTITY,
    VK_COMPONENT_SWIZZLE_END_RANGE = VK_COMPONENT_SWIZZLE_A,
    VK_COMPONENT_SWIZZLE_RANGE_SIZE = (VK_COMPONENT_SWIZZLE_A - VK_COMPONENT_SWIZZLE_IDENTITY + 1),
    VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7FFFFFFF
} VkComponentSwizzle;

typedef enum VkVertexInputRate {
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
    VK_VERTEX_INPUT_RATE_BEGIN_RANGE = VK_VERTEX_INPUT_RATE_VERTEX,
    VK_VERTEX_INPUT_RATE_END_RANGE = VK_VERTEX_INPUT_RATE_INSTANCE,
    VK_VERTEX_INPUT_RATE_RANGE_SIZE = (VK_VERTEX_INPUT_RATE_INSTANCE - VK_VERTEX_INPUT_RATE_VERTEX + 1),
    VK_VERTEX_INPUT_RATE_MAX_ENUM = 0x7FFFFFFF
} VkVertexInputRate;

typedef enum VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
    VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    VK_PRIMITIVE_TOPOLOGY_END_RANGE = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
    VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE = (VK_PRIMITIVE_TOPOLOGY_PATCH_LIST - VK_PRIMITIVE_TOPOLOGY_POINT_LIST + 1),
    VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7FFFFFFF
} VkPrimitiveTopology;

typedef enum VkPolygonMode {
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
    VK_POLYGON_MODE_BEGIN_RANGE = VK_POLYGON_MODE_FILL,
    VK_POLYGON_MODE_END_RANGE = VK_POLYGON_MODE_POINT,
    VK_POLYGON_MODE_RANGE_SIZE = (VK_POLYGON_MODE_POINT - VK_POLYGON_MODE_FILL + 1),
    VK_POLYGON_MODE_MAX_ENUM = 0x7FFFFFFF
} VkPolygonMode;

typedef enum VkFrontFace {
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
    VK_FRONT_FACE_BEGIN_RANGE = VK_FRONT_FACE_COUNTER_CLOCKWISE,
    VK_FRONT_FACE_END_RANGE = VK_FRONT_FACE_CLOCKWISE,
    VK_FRONT_FACE_RANGE_SIZE = (VK_FRONT_FACE_CLOCKWISE - VK_FRONT_FACE_COUNTER_CLOCKWISE + 1),
    VK_FRONT_FACE_MAX_ENUM = 0x7FFFFFFF
} VkFrontFace;

typedef enum VkCompareOp {
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
    VK_COMPARE_OP_BEGIN_RANGE = VK_COMPARE_OP_NEVER,
    VK_COMPARE_OP_END_RANGE = VK_COMPARE_OP_ALWAYS,
    VK_COMPARE_OP_RANGE_SIZE = (VK_COMPARE_OP_ALWAYS - VK_COMPARE_OP_NEVER + 1),
    VK_COMPARE_OP_MAX_ENUM = 0x7FFFFFFF
} VkCompareOp;

typedef enum VkStencilOp {
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
    VK_STENCIL_OP_BEGIN_RANGE = VK_STENCIL_OP_KEEP,
    VK_STENCIL_OP_END_RANGE = VK_STENCIL_OP_DECREMENT_AND_WRAP,
    VK_STENCIL_OP_RANGE_SIZE = (VK_STENCIL_OP_DECREMENT_AND_WRAP - VK_STENCIL_OP_KEEP + 1),
    VK_STENCIL_OP_MAX_ENUM = 0x7FFFFFFF
} VkStencilOp;

typedef enum VkLogicOp {
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
    VK_LOGIC_OP_BEGIN_RANGE = VK_LOGIC_OP_CLEAR,
    VK_LOGIC_OP_END_RANGE = VK_LOGIC_OP_SET,
    VK_LOGIC_OP_RANGE_SIZE = (VK_LOGIC_OP_SET - VK_LOGIC_OP_CLEAR + 1),
    VK_LOGIC_OP_MAX_ENUM = 0x7FFFFFFF
} VkLogicOp;

typedef enum VkBlendFactor {
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
    VK_BLEND_FACTOR_BEGIN_RANGE = VK_BLEND_FACTOR_ZERO,
    VK_BLEND_FACTOR_END_RANGE = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
    VK_BLEND_FACTOR_RANGE_SIZE = (VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA - VK_BLEND_FACTOR_ZERO + 1),
    VK_BLEND_FACTOR_MAX_ENUM = 0x7FFFFFFF
} VkBlendFactor;

typedef enum VkBlendOp {
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    VK_BLEND_OP_BEGIN_RANGE = VK_BLEND_OP_ADD,
    VK_BLEND_OP_END_RANGE = VK_BLEND_OP_MAX,
    VK_BLEND_OP_RANGE_SIZE = (VK_BLEND_OP_MAX - VK_BLEND_OP_ADD + 1),
    VK_BLEND_OP_MAX_ENUM = 0x7FFFFFFF
} VkBlendOp;

typedef enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    VK_DYNAMIC_STATE_BEGIN_RANGE = VK_DYNAMIC_STATE_VIEWPORT,
    VK_DYNAMIC_STATE_END_RANGE = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    VK_DYNAMIC_STATE_RANGE_SIZE = (VK_DYNAMIC_STATE_STENCIL_REFERENCE - VK_DYNAMIC_STATE_VIEWPORT + 1),
    VK_DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF
} VkDynamicState;

typedef enum VkFilter {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_CUBIC_IMG = 1000015000,
    VK_FILTER_BEGIN_RANGE = VK_FILTER_NEAREST,
    VK_FILTER_END_RANGE = VK_FILTER_LINEAR,
    VK_FILTER_RANGE_SIZE = (VK_FILTER_LINEAR - VK_FILTER_NEAREST + 1),
    VK_FILTER_MAX_ENUM = 0x7FFFFFFF
} VkFilter;

typedef enum VkSamplerMipmapMode {
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
    VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE = VK_SAMPLER_MIPMAP_MODE_NEAREST,
    VK_SAMPLER_MIPMAP_MODE_END_RANGE = VK_SAMPLER_MIPMAP_MODE_LINEAR,
    VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE = (VK_SAMPLER_MIPMAP_MODE_LINEAR - VK_SAMPLER_MIPMAP_MODE_NEAREST + 1),
    VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerMipmapMode;

typedef enum VkSamplerAddressMode {
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
    VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    VK_SAMPLER_ADDRESS_MODE_END_RANGE = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE = (VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER - VK_SAMPLER_ADDRESS_MODE_REPEAT + 1),
    VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerAddressMode;

typedef enum VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
    VK_BORDER_COLOR_BEGIN_RANGE = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    VK_BORDER_COLOR_END_RANGE = VK_BORDER_COLOR_INT_OPAQUE_WHITE,
    VK_BORDER_COLOR_RANGE_SIZE = (VK_BORDER_COLOR_INT_OPAQUE_WHITE - VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK + 1),
    VK_BORDER_COLOR_MAX_ENUM = 0x7FFFFFFF
} VkBorderColor;

typedef enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    VK_DESCRIPTOR_TYPE_BEGIN_RANGE = VK_DESCRIPTOR_TYPE_SAMPLER,
    VK_DESCRIPTOR_TYPE_END_RANGE = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    VK_DESCRIPTOR_TYPE_RANGE_SIZE = (VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT - VK_DESCRIPTOR_TYPE_SAMPLER + 1),
    VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorType;

typedef enum VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
    VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE = VK_ATTACHMENT_LOAD_OP_LOAD,
    VK_ATTACHMENT_LOAD_OP_END_RANGE = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    VK_ATTACHMENT_LOAD_OP_RANGE_SIZE = (VK_ATTACHMENT_LOAD_OP_DONT_CARE - VK_ATTACHMENT_LOAD_OP_LOAD + 1),
    VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentLoadOp;

typedef enum VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
    VK_ATTACHMENT_STORE_OP_BEGIN_RANGE = VK_ATTACHMENT_STORE_OP_STORE,
    VK_ATTACHMENT_STORE_OP_END_RANGE = VK_ATTACHMENT_STORE_OP_DONT_CARE,
    VK_ATTACHMENT_STORE_OP_RANGE_SIZE = (VK_ATTACHMENT_STORE_OP_DONT_CARE - VK_ATTACHMENT_STORE_OP_STORE + 1),
    VK_ATTACHMENT_STORE_OP_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentStoreOp;

typedef enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    VK_PIPELINE_BIND_POINT_BEGIN_RANGE = VK_PIPELINE_BIND_POINT_GRAPHICS,
    VK_PIPELINE_BIND_POINT_END_RANGE = VK_PIPELINE_BIND_POINT_COMPUTE,
    VK_PIPELINE_BIND_POINT_RANGE_SIZE = (VK_PIPELINE_BIND_POINT_COMPUTE - VK_PIPELINE_BIND_POINT_GRAPHICS + 1),
    VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7FFFFFFF
} VkPipelineBindPoint;

typedef enum VkCommandBufferLevel {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
    VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    VK_COMMAND_BUFFER_LEVEL_END_RANGE = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE = (VK_COMMAND_BUFFER_LEVEL_SECONDARY - VK_COMMAND_BUFFER_LEVEL_PRIMARY + 1),
    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferLevel;

typedef enum VkIndexType {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    VK_INDEX_TYPE_BEGIN_RANGE = VK_INDEX_TYPE_UINT16,
    VK_INDEX_TYPE_END_RANGE = VK_INDEX_TYPE_UINT32,
    VK_INDEX_TYPE_RANGE_SIZE = (VK_INDEX_TYPE_UINT32 - VK_INDEX_TYPE_UINT16 + 1),
    VK_INDEX_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkIndexType;

typedef enum VkSubpassContents {
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
    VK_SUBPASS_CONTENTS_BEGIN_RANGE = VK_SUBPASS_CONTENTS_INLINE,
    VK_SUBPASS_CONTENTS_END_RANGE = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
    VK_SUBPASS_CONTENTS_RANGE_SIZE = (VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS - VK_SUBPASS_CONTENTS_INLINE + 1),
    VK_SUBPASS_CONTENTS_MAX_ENUM = 0x7FFFFFFF
} VkSubpassContents;

typedef VkFlags VkInstanceCreateFlags;

typedef enum VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000,
    VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFormatFeatureFlagBits;
typedef VkFlags VkFormatFeatureFlags;

typedef enum VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
    VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
    VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageUsageFlagBits;
typedef VkFlags VkImageUsageFlags;

typedef enum VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
    VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageCreateFlagBits;
typedef VkFlags VkImageCreateFlags;

typedef enum VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT = 0x00000001,
    VK_SAMPLE_COUNT_2_BIT = 0x00000002,
    VK_SAMPLE_COUNT_4_BIT = 0x00000004,
    VK_SAMPLE_COUNT_8_BIT = 0x00000008,
    VK_SAMPLE_COUNT_16_BIT = 0x00000010,
    VK_SAMPLE_COUNT_32_BIT = 0x00000020,
    VK_SAMPLE_COUNT_64_BIT = 0x00000040,
    VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSampleCountFlagBits;
typedef VkFlags VkSampleCountFlags;

typedef enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 0x00000001,
    VK_QUEUE_COMPUTE_BIT = 0x00000002,
    VK_QUEUE_TRANSFER_BIT = 0x00000004,
    VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
    VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueueFlagBits;
typedef VkFlags VkQueueFlags;

typedef enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
    VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryPropertyFlagBits;
typedef VkFlags VkMemoryPropertyFlags;

typedef enum VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryHeapFlagBits;
typedef VkFlags VkMemoryHeapFlags;
typedef VkFlags VkDeviceCreateFlags;
typedef VkFlags VkDeviceQueueCreateFlags;

typedef enum VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
    VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
    VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
    VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPipelineStageFlagBits;
typedef VkFlags VkPipelineStageFlags;
typedef VkFlags VkMemoryMapFlags;

typedef enum VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
    VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
    VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
    VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
    VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageAspectFlagBits;
typedef VkFlags VkImageAspectFlags;

typedef enum VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
    VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSparseImageFormatFlagBits;
typedef VkFlags VkSparseImageFormatFlags;

typedef enum VkSparseMemoryBindFlagBits {
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
    VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSparseMemoryBindFlagBits;
typedef VkFlags VkSparseMemoryBindFlags;

typedef enum VkFenceCreateFlagBits {
    VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
    VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFenceCreateFlagBits;
typedef VkFlags VkFenceCreateFlags;
typedef VkFlags VkSemaphoreCreateFlags;
typedef VkFlags VkEventCreateFlags;
typedef VkFlags VkQueryPoolCreateFlags;

typedef enum VkQueryPipelineStatisticFlagBits {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
    VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryPipelineStatisticFlagBits;
typedef VkFlags VkQueryPipelineStatisticFlags;

typedef enum VkQueryResultFlagBits {
    VK_QUERY_RESULT_64_BIT = 0x00000001,
    VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
    VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
    VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryResultFlagBits;
typedef VkFlags VkQueryResultFlags;

typedef enum VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferCreateFlagBits;
typedef VkFlags VkBufferCreateFlags;

typedef enum VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
    VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferUsageFlagBits;
typedef VkFlags VkBufferUsageFlags;
typedef VkFlags VkBufferViewCreateFlags;
typedef VkFlags VkImageViewCreateFlags;
typedef VkFlags VkShaderModuleCreateFlags;
typedef VkFlags VkPipelineCacheCreateFlags;

typedef enum VkPipelineCreateFlagBits {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
    VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPipelineCreateFlagBits;
typedef VkFlags VkPipelineCreateFlags;
typedef VkFlags VkPipelineShaderStageCreateFlags;

typedef enum VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
    VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
    VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
    VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
    VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
    VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
    VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkShaderStageFlagBits;
typedef VkFlags VkPipelineVertexInputStateCreateFlags;
typedef VkFlags VkPipelineInputAssemblyStateCreateFlags;
typedef VkFlags VkPipelineTessellationStateCreateFlags;
typedef VkFlags VkPipelineViewportStateCreateFlags;
typedef VkFlags VkPipelineRasterizationStateCreateFlags;

typedef enum VkCullModeFlagBits {
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = 0x00000001,
    VK_CULL_MODE_BACK_BIT = 0x00000002,
    VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
    VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCullModeFlagBits;
typedef VkFlags VkCullModeFlags;
typedef VkFlags VkPipelineMultisampleStateCreateFlags;
typedef VkFlags VkPipelineDepthStencilStateCreateFlags;
typedef VkFlags VkPipelineColorBlendStateCreateFlags;

typedef enum VkColorComponentFlagBits {
    VK_COLOR_COMPONENT_R_BIT = 0x00000001,
    VK_COLOR_COMPONENT_G_BIT = 0x00000002,
    VK_COLOR_COMPONENT_B_BIT = 0x00000004,
    VK_COLOR_COMPONENT_A_BIT = 0x00000008,
    VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkColorComponentFlagBits;
typedef VkFlags VkColorComponentFlags;
typedef VkFlags VkPipelineDynamicStateCreateFlags;
typedef VkFlags VkPipelineLayoutCreateFlags;
typedef VkFlags VkShaderStageFlags;
typedef VkFlags VkSamplerCreateFlags;
typedef VkFlags VkDescriptorSetLayoutCreateFlags;

typedef enum VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
    VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorPoolCreateFlagBits;
typedef VkFlags VkDescriptorPoolCreateFlags;
typedef VkFlags VkDescriptorPoolResetFlags;
typedef VkFlags VkFramebufferCreateFlags;
typedef VkFlags VkRenderPassCreateFlags;

typedef enum VkAttachmentDescriptionFlagBits {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
    VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentDescriptionFlagBits;
typedef VkFlags VkAttachmentDescriptionFlags;
typedef VkFlags VkSubpassDescriptionFlags;

typedef enum VkAccessFlagBits {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
    VK_ACCESS_INDEX_READ_BIT = 0x00000002,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
    VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
    VK_ACCESS_SHADER_READ_BIT = 0x00000020,
    VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
    VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
    VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
    VK_ACCESS_HOST_READ_BIT = 0x00002000,
    VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
    VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
    VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
    VK_ACCESS_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkAccessFlagBits;
typedef VkFlags VkAccessFlags;

typedef enum VkDependencyFlagBits {
    VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
    VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDependencyFlagBits;
typedef VkFlags VkDependencyFlags;

typedef enum VkCommandPoolCreateFlagBits {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
    VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandPoolCreateFlagBits;
typedef VkFlags VkCommandPoolCreateFlags;

typedef enum VkCommandPoolResetFlagBits {
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
    VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandPoolResetFlagBits;
typedef VkFlags VkCommandPoolResetFlags;

typedef enum VkCommandBufferUsageFlagBits {
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
    VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferUsageFlagBits;
typedef VkFlags VkCommandBufferUsageFlags;

typedef enum VkQueryControlFlagBits {
    VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
    VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryControlFlagBits;
typedef VkFlags VkQueryControlFlags;

typedef enum VkCommandBufferResetFlagBits {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
    VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferResetFlagBits;
typedef VkFlags VkCommandBufferResetFlags;

typedef enum VkStencilFaceFlagBits {
    VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
    VK_STENCIL_FACE_BACK_BIT = 0x00000002,
    VK_STENCIL_FRONT_AND_BACK = 0x00000003,
    VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkStencilFaceFlagBits;
typedef VkFlags VkStencilFaceFlags;

typedef void* (VKAPI_PTR *PFN_vkAllocationFunction)(
    void*                                       pUserData,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void* (VKAPI_PTR *PFN_vkReallocationFunction)(
    void*                                       pUserData,
    void*                                       pOriginal,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkFreeFunction)(
    void*                                       pUserData,
    void*                                       pMemory);

typedef void (VKAPI_PTR *PFN_vkInternalAllocationNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkInternalFreeNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkVoidFunction)(void);

typedef struct VkApplicationInfo {
    VkStructureType    sType;
    void*        pNext;
    char*        pApplicationName;
    uint32_t           applicationVersion;
    char*        pEngineName;
    uint32_t           engineVersion;
    uint32_t           apiVersion;
} VkApplicationInfo;

typedef struct VkInstanceCreateInfo {
    VkStructureType             sType;
    void*                 pNext;
    VkInstanceCreateFlags       flags;
    VkApplicationInfo*    pApplicationInfo;
    uint32_t                    enabledLayerCount;
    char* *         ppEnabledLayerNames;
    uint32_t                    enabledExtensionCount;
    char* *         ppEnabledExtensionNames;
} VkInstanceCreateInfo;

typedef struct VkAllocationCallbacks {
    void*                                   pUserData;
    PFN_vkAllocationFunction                pfnAllocation;
    PFN_vkReallocationFunction              pfnReallocation;
    PFN_vkFreeFunction                      pfnFree;
    PFN_vkInternalAllocationNotification    pfnInternalAllocation;
    PFN_vkInternalFreeNotification          pfnInternalFree;
} VkAllocationCallbacks;

typedef struct VkPhysicalDeviceFeatures {
    VkBool32    robustBufferAccess;
    VkBool32    fullDrawIndexUint32;
    VkBool32    imageCubeArray;
    VkBool32    independentBlend;
    VkBool32    geometryShader;
    VkBool32    tessellationShader;
    VkBool32    sampleRateShading;
    VkBool32    dualSrcBlend;
    VkBool32    logicOp;
    VkBool32    multiDrawIndirect;
    VkBool32    drawIndirectFirstInstance;
    VkBool32    depthClamp;
    VkBool32    depthBiasClamp;
    VkBool32    fillModeNonSolid;
    VkBool32    depthBounds;
    VkBool32    wideLines;
    VkBool32    largePoints;
    VkBool32    alphaToOne;
    VkBool32    multiViewport;
    VkBool32    samplerAnisotropy;
    VkBool32    textureCompressionETC2;
    VkBool32    textureCompressionASTC_LDR;
    VkBool32    textureCompressionBC;
    VkBool32    occlusionQueryPrecise;
    VkBool32    pipelineStatisticsQuery;
    VkBool32    vertexPipelineStoresAndAtomics;
    VkBool32    fragmentStoresAndAtomics;
    VkBool32    shaderTessellationAndGeometryPointSize;
    VkBool32    shaderImageGatherExtended;
    VkBool32    shaderStorageImageExtendedFormats;
    VkBool32    shaderStorageImageMultisample;
    VkBool32    shaderStorageImageReadWithoutFormat;
    VkBool32    shaderStorageImageWriteWithoutFormat;
    VkBool32    shaderUniformBufferArrayDynamicIndexing;
    VkBool32    shaderSampledImageArrayDynamicIndexing;
    VkBool32    shaderStorageBufferArrayDynamicIndexing;
    VkBool32    shaderStorageImageArrayDynamicIndexing;
    VkBool32    shaderClipDistance;
    VkBool32    shaderCullDistance;
    VkBool32    shaderFloat64;
    VkBool32    shaderInt64;
    VkBool32    shaderInt16;
    VkBool32    shaderResourceResidency;
    VkBool32    shaderResourceMinLod;
    VkBool32    sparseBinding;
    VkBool32    sparseResidencyBuffer;
    VkBool32    sparseResidencyImage2D;
    VkBool32    sparseResidencyImage3D;
    VkBool32    sparseResidency2Samples;
    VkBool32    sparseResidency4Samples;
    VkBool32    sparseResidency8Samples;
    VkBool32    sparseResidency16Samples;
    VkBool32    sparseResidencyAliased;
    VkBool32    variableMultisampleRate;
    VkBool32    inheritedQueries;
} VkPhysicalDeviceFeatures;

typedef struct VkFormatProperties {
    VkFormatFeatureFlags    linearTilingFeatures;
    VkFormatFeatureFlags    optimalTilingFeatures;
    VkFormatFeatureFlags    bufferFeatures;
} VkFormatProperties;

typedef struct VkExtent3D {
    uint32_t    width;
    uint32_t    height;
    uint32_t    depth;
} VkExtent3D;

typedef struct VkImageFormatProperties {
    VkExtent3D            maxExtent;
    uint32_t              maxMipLevels;
    uint32_t              maxArrayLayers;
    VkSampleCountFlags    sampleCounts;
    VkDeviceSize          maxResourceSize;
} VkImageFormatProperties;

typedef struct VkPhysicalDeviceLimits {
    uint32_t              maxImageDimension1D;
    uint32_t              maxImageDimension2D;
    uint32_t              maxImageDimension3D;
    uint32_t              maxImageDimensionCube;
    uint32_t              maxImageArrayLayers;
    uint32_t              maxTexelBufferElements;
    uint32_t              maxUniformBufferRange;
    uint32_t              maxStorageBufferRange;
    uint32_t              maxPushConstantsSize;
    uint32_t              maxMemoryAllocationCount;
    uint32_t              maxSamplerAllocationCount;
    VkDeviceSize          bufferImageGranularity;
    VkDeviceSize          sparseAddressSpaceSize;
    uint32_t              maxBoundDescriptorSets;
    uint32_t              maxPerStageDescriptorSamplers;
    uint32_t              maxPerStageDescriptorUniformBuffers;
    uint32_t              maxPerStageDescriptorStorageBuffers;
    uint32_t              maxPerStageDescriptorSampledImages;
    uint32_t              maxPerStageDescriptorStorageImages;
    uint32_t              maxPerStageDescriptorInputAttachments;
    uint32_t              maxPerStageResources;
    uint32_t              maxDescriptorSetSamplers;
    uint32_t              maxDescriptorSetUniformBuffers;
    uint32_t              maxDescriptorSetUniformBuffersDynamic;
    uint32_t              maxDescriptorSetStorageBuffers;
    uint32_t              maxDescriptorSetStorageBuffersDynamic;
    uint32_t              maxDescriptorSetSampledImages;
    uint32_t              maxDescriptorSetStorageImages;
    uint32_t              maxDescriptorSetInputAttachments;
    uint32_t              maxVertexInputAttributes;
    uint32_t              maxVertexInputBindings;
    uint32_t              maxVertexInputAttributeOffset;
    uint32_t              maxVertexInputBindingStride;
    uint32_t              maxVertexOutputComponents;
    uint32_t              maxTessellationGenerationLevel;
    uint32_t              maxTessellationPatchSize;
    uint32_t              maxTessellationControlPerVertexInputComponents;
    uint32_t              maxTessellationControlPerVertexOutputComponents;
    uint32_t              maxTessellationControlPerPatchOutputComponents;
    uint32_t              maxTessellationControlTotalOutputComponents;
    uint32_t              maxTessellationEvaluationInputComponents;
    uint32_t              maxTessellationEvaluationOutputComponents;
    uint32_t              maxGeometryShaderInvocations;
    uint32_t              maxGeometryInputComponents;
    uint32_t              maxGeometryOutputComponents;
    uint32_t              maxGeometryOutputVertices;
    uint32_t              maxGeometryTotalOutputComponents;
    uint32_t              maxFragmentInputComponents;
    uint32_t              maxFragmentOutputAttachments;
    uint32_t              maxFragmentDualSrcAttachments;
    uint32_t              maxFragmentCombinedOutputResources;
    uint32_t              maxComputeSharedMemorySize;
    uint32_t              maxComputeWorkGroupCount[3];
    uint32_t              maxComputeWorkGroupInvocations;
    uint32_t              maxComputeWorkGroupSize[3];
    uint32_t              subPixelPrecisionBits;
    uint32_t              subTexelPrecisionBits;
    uint32_t              mipmapPrecisionBits;
    uint32_t              maxDrawIndexedIndexValue;
    uint32_t              maxDrawIndirectCount;
    float                 maxSamplerLodBias;
    float                 maxSamplerAnisotropy;
    uint32_t              maxViewports;
    uint32_t              maxViewportDimensions[2];
    float                 viewportBoundsRange[2];
    uint32_t              viewportSubPixelBits;
    size_t                minMemoryMapAlignment;
    VkDeviceSize          minTexelBufferOffsetAlignment;
    VkDeviceSize          minUniformBufferOffsetAlignment;
    VkDeviceSize          minStorageBufferOffsetAlignment;
    int32_t               minTexelOffset;
    uint32_t              maxTexelOffset;
    int32_t               minTexelGatherOffset;
    uint32_t              maxTexelGatherOffset;
    float                 minInterpolationOffset;
    float                 maxInterpolationOffset;
    uint32_t              subPixelInterpolationOffsetBits;
    uint32_t              maxFramebufferWidth;
    uint32_t              maxFramebufferHeight;
    uint32_t              maxFramebufferLayers;
    VkSampleCountFlags    framebufferColorSampleCounts;
    VkSampleCountFlags    framebufferDepthSampleCounts;
    VkSampleCountFlags    framebufferStencilSampleCounts;
    VkSampleCountFlags    framebufferNoAttachmentsSampleCounts;
    uint32_t              maxColorAttachments;
    VkSampleCountFlags    sampledImageColorSampleCounts;
    VkSampleCountFlags    sampledImageIntegerSampleCounts;
    VkSampleCountFlags    sampledImageDepthSampleCounts;
    VkSampleCountFlags    sampledImageStencilSampleCounts;
    VkSampleCountFlags    storageImageSampleCounts;
    uint32_t              maxSampleMaskWords;
    VkBool32              timestampComputeAndGraphics;
    float                 timestampPeriod;
    uint32_t              maxClipDistances;
    uint32_t              maxCullDistances;
    uint32_t              maxCombinedClipAndCullDistances;
    uint32_t              discreteQueuePriorities;
    float                 pointSizeRange[2];
    float                 lineWidthRange[2];
    float                 pointSizeGranularity;
    float                 lineWidthGranularity;
    VkBool32              strictLines;
    VkBool32              standardSampleLocations;
    VkDeviceSize          optimalBufferCopyOffsetAlignment;
    VkDeviceSize          optimalBufferCopyRowPitchAlignment;
    VkDeviceSize          nonCoherentAtomSize;
} VkPhysicalDeviceLimits;

typedef struct VkPhysicalDeviceSparseProperties {
    VkBool32    residencyStandard2DBlockShape;
    VkBool32    residencyStandard2DMultisampleBlockShape;
    VkBool32    residencyStandard3DBlockShape;
    VkBool32    residencyAlignedMipSize;
    VkBool32    residencyNonResidentStrict;
} VkPhysicalDeviceSparseProperties;

typedef struct VkPhysicalDeviceProperties {
    uint32_t                            apiVersion;
    uint32_t                            driverVersion;
    uint32_t                            vendorID;
    uint32_t                            deviceID;
    VkPhysicalDeviceType                deviceType;
    char                                deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    uint8_t                             pipelineCacheUUID[VK_UUID_SIZE];
    VkPhysicalDeviceLimits              limits;
    VkPhysicalDeviceSparseProperties    sparseProperties;
} VkPhysicalDeviceProperties;

typedef struct VkQueueFamilyProperties {
    VkQueueFlags    queueFlags;
    uint32_t        queueCount;
    uint32_t        timestampValidBits;
    VkExtent3D      minImageTransferGranularity;
} VkQueueFamilyProperties;

typedef struct VkMemoryType {
    VkMemoryPropertyFlags    propertyFlags;
    uint32_t                 heapIndex;
} VkMemoryType;

typedef struct VkMemoryHeap {
    VkDeviceSize         size;
    VkMemoryHeapFlags    flags;
} VkMemoryHeap;

typedef struct VkPhysicalDeviceMemoryProperties {
    uint32_t        memoryTypeCount;
    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];
    uint32_t        memoryHeapCount;
    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties;

typedef struct VkDeviceQueueCreateInfo {
    VkStructureType             sType;
    void*                 pNext;
    VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueCount;
    float*                pQueuePriorities;
} VkDeviceQueueCreateInfo;

typedef struct VkDeviceCreateInfo {
    VkStructureType                    sType;
    void*                        pNext;
    VkDeviceCreateFlags                flags;
    uint32_t                           queueCreateInfoCount;
    VkDeviceQueueCreateInfo*     pQueueCreateInfos;
    uint32_t                           enabledLayerCount;
    char* *                ppEnabledLayerNames;
    uint32_t                           enabledExtensionCount;
    char* *                ppEnabledExtensionNames;
    VkPhysicalDeviceFeatures*    pEnabledFeatures;
} VkDeviceCreateInfo;

typedef struct VkExtensionProperties {
    char        extensionName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
} VkExtensionProperties;

typedef struct VkLayerProperties {
    char        layerName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
    uint32_t    implementationVersion;
    char        description[VK_MAX_DESCRIPTION_SIZE];
} VkLayerProperties;

typedef struct VkSubmitInfo {
    VkStructureType                sType;
    void*                    pNext;
    uint32_t                       waitSemaphoreCount;
    VkSemaphore*             pWaitSemaphores;
    VkPipelineStageFlags*    pWaitDstStageMask;
    uint32_t                       commandBufferCount;
    VkCommandBuffer*         pCommandBuffers;
    uint32_t                       signalSemaphoreCount;
    VkSemaphore*             pSignalSemaphores;
} VkSubmitInfo;

typedef struct VkMemoryAllocateInfo {
    VkStructureType    sType;
    void*        pNext;
    VkDeviceSize       allocationSize;
    uint32_t           memoryTypeIndex;
} VkMemoryAllocateInfo;

typedef struct VkMappedMemoryRange {
    VkStructureType    sType;
    void*        pNext;
    VkDeviceMemory     memory;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkMappedMemoryRange;

typedef struct VkMemoryRequirements {
    VkDeviceSize    size;
    VkDeviceSize    alignment;
    uint32_t        memoryTypeBits;
} VkMemoryRequirements;

typedef struct VkSparseImageFormatProperties {
    VkImageAspectFlags          aspectMask;
    VkExtent3D                  imageGranularity;
    VkSparseImageFormatFlags    flags;
} VkSparseImageFormatProperties;

typedef struct VkSparseImageMemoryRequirements {
    VkSparseImageFormatProperties    formatProperties;
    uint32_t                         imageMipTailFirstLod;
    VkDeviceSize                     imageMipTailSize;
    VkDeviceSize                     imageMipTailOffset;
    VkDeviceSize                     imageMipTailStride;
} VkSparseImageMemoryRequirements;

typedef struct VkSparseMemoryBind {
    VkDeviceSize               resourceOffset;
    VkDeviceSize               size;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseMemoryBind;

typedef struct VkSparseBufferMemoryBindInfo {
    VkBuffer                     buffer;
    uint32_t                     bindCount;
    VkSparseMemoryBind*    pBinds;
} VkSparseBufferMemoryBindInfo;

typedef struct VkSparseImageOpaqueMemoryBindInfo {
    VkImage                      image;
    uint32_t                     bindCount;
    VkSparseMemoryBind*    pBinds;
} VkSparseImageOpaqueMemoryBindInfo;

typedef struct VkImageSubresource {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              arrayLayer;
} VkImageSubresource;

typedef struct VkOffset3D {
    int32_t    x;
    int32_t    y;
    int32_t    z;
} VkOffset3D;

typedef struct VkSparseImageMemoryBind {
    VkImageSubresource         subresource;
    VkOffset3D                 offset;
    VkExtent3D                 extent;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseImageMemoryBind;

typedef struct VkSparseImageMemoryBindInfo {
    VkImage                           image;
    uint32_t                          bindCount;
    VkSparseImageMemoryBind*    pBinds;
} VkSparseImageMemoryBindInfo;

typedef struct VkBindSparseInfo {
    VkStructureType                             sType;
    void*                                 pNext;
    uint32_t                                    waitSemaphoreCount;
    VkSemaphore*                          pWaitSemaphores;
    uint32_t                                    bufferBindCount;
    VkSparseBufferMemoryBindInfo*         pBufferBinds;
    uint32_t                                    imageOpaqueBindCount;
    VkSparseImageOpaqueMemoryBindInfo*    pImageOpaqueBinds;
    uint32_t                                    imageBindCount;
    VkSparseImageMemoryBindInfo*          pImageBinds;
    uint32_t                                    signalSemaphoreCount;
    VkSemaphore*                          pSignalSemaphores;
} VkBindSparseInfo;

typedef struct VkFenceCreateInfo {
    VkStructureType       sType;
    void*           pNext;
    VkFenceCreateFlags    flags;
} VkFenceCreateInfo;

typedef struct VkSemaphoreCreateInfo {
    VkStructureType           sType;
    void*               pNext;
    VkSemaphoreCreateFlags    flags;
} VkSemaphoreCreateInfo;

typedef struct VkEventCreateInfo {
    VkStructureType       sType;
    void*           pNext;
    VkEventCreateFlags    flags;
} VkEventCreateInfo;

typedef struct VkQueryPoolCreateInfo {
    VkStructureType                  sType;
    void*                      pNext;
    VkQueryPoolCreateFlags           flags;
    VkQueryType                      queryType;
    uint32_t                         queryCount;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkQueryPoolCreateInfo;

typedef struct VkBufferCreateInfo {
    VkStructureType        sType;
    void*            pNext;
    VkBufferCreateFlags    flags;
    VkDeviceSize           size;
    VkBufferUsageFlags     usage;
    VkSharingMode          sharingMode;
    uint32_t               queueFamilyIndexCount;
    uint32_t*        pQueueFamilyIndices;
} VkBufferCreateInfo;

typedef struct VkBufferViewCreateInfo {
    VkStructureType            sType;
    void*                pNext;
    VkBufferViewCreateFlags    flags;
    VkBuffer                   buffer;
    VkFormat                   format;
    VkDeviceSize               offset;
    VkDeviceSize               range;
} VkBufferViewCreateInfo;

typedef struct VkImageCreateInfo {
    VkStructureType          sType;
    void*              pNext;
    VkImageCreateFlags       flags;
    VkImageType              imageType;
    VkFormat                 format;
    VkExtent3D               extent;
    uint32_t                 mipLevels;
    uint32_t                 arrayLayers;
    VkSampleCountFlagBits    samples;
    VkImageTiling            tiling;
    VkImageUsageFlags        usage;
    VkSharingMode            sharingMode;
    uint32_t                 queueFamilyIndexCount;
    uint32_t*          pQueueFamilyIndices;
    VkImageLayout            initialLayout;
} VkImageCreateInfo;

typedef struct VkSubresourceLayout {
    VkDeviceSize    offset;
    VkDeviceSize    size;
    VkDeviceSize    rowPitch;
    VkDeviceSize    arrayPitch;
    VkDeviceSize    depthPitch;
} VkSubresourceLayout;

typedef struct VkComponentMapping {
    VkComponentSwizzle    r;
    VkComponentSwizzle    g;
    VkComponentSwizzle    b;
    VkComponentSwizzle    a;
} VkComponentMapping;

typedef struct VkImageSubresourceRange {
    VkImageAspectFlags    aspectMask;
    uint32_t              baseMipLevel;
    uint32_t              levelCount;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceRange;

typedef struct VkImageViewCreateInfo {
    VkStructureType            sType;
    void*                pNext;
    VkImageViewCreateFlags     flags;
    VkImage                    image;
    VkImageViewType            viewType;
    VkFormat                   format;
    VkComponentMapping         components;
    VkImageSubresourceRange    subresourceRange;
} VkImageViewCreateInfo;

typedef struct VkShaderModuleCreateInfo {
    VkStructureType              sType;
    void*                  pNext;
    VkShaderModuleCreateFlags    flags;
    size_t                       codeSize;
    uint32_t*              pCode;
} VkShaderModuleCreateInfo;

typedef struct VkPipelineCacheCreateInfo {
    VkStructureType               sType;
    void*                   pNext;
    VkPipelineCacheCreateFlags    flags;
    size_t                        initialDataSize;
    void*                   pInitialData;
} VkPipelineCacheCreateInfo;

typedef struct VkSpecializationMapEntry {
    uint32_t    constantID;
    uint32_t    offset;
    size_t      size;
} VkSpecializationMapEntry;

typedef struct VkSpecializationInfo {
    uint32_t                           mapEntryCount;
    VkSpecializationMapEntry*    pMapEntries;
    size_t                             dataSize;
    void*                        pData;
} VkSpecializationInfo;

typedef struct VkPipelineShaderStageCreateInfo {
    VkStructureType                     sType;
    void*                         pNext;
    VkPipelineShaderStageCreateFlags    flags;
    VkShaderStageFlagBits               stage;
    VkShaderModule                      module;
    char*                         pName;
    VkSpecializationInfo*         pSpecializationInfo;
} VkPipelineShaderStageCreateInfo;

typedef struct VkVertexInputBindingDescription {
    uint32_t             binding;
    uint32_t             stride;
    VkVertexInputRate    inputRate;
} VkVertexInputBindingDescription;

typedef struct VkVertexInputAttributeDescription {
    uint32_t    location;
    uint32_t    binding;
    VkFormat    format;
    uint32_t    offset;
} VkVertexInputAttributeDescription;

typedef struct VkPipelineVertexInputStateCreateInfo {
    VkStructureType                             sType;
    void*                                 pNext;
    VkPipelineVertexInputStateCreateFlags       flags;
    uint32_t                                    vertexBindingDescriptionCount;
    VkVertexInputBindingDescription*      pVertexBindingDescriptions;
    uint32_t                                    vertexAttributeDescriptionCount;
    VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;
} VkPipelineVertexInputStateCreateInfo;

typedef struct VkPipelineInputAssemblyStateCreateInfo {
    VkStructureType                            sType;
    void*                                pNext;
    VkPipelineInputAssemblyStateCreateFlags    flags;
    VkPrimitiveTopology                        topology;
    VkBool32                                   primitiveRestartEnable;
} VkPipelineInputAssemblyStateCreateInfo;

typedef struct VkPipelineTessellationStateCreateInfo {
    VkStructureType                           sType;
    void*                               pNext;
    VkPipelineTessellationStateCreateFlags    flags;
    uint32_t                                  patchControlPoints;
} VkPipelineTessellationStateCreateInfo;

typedef struct VkViewport {
    float    x;
    float    y;
    float    width;
    float    height;
    float    minDepth;
    float    maxDepth;
} VkViewport;

typedef struct VkOffset2D {
    int32_t    x;
    int32_t    y;
} VkOffset2D;

typedef struct VkExtent2D {
    uint32_t    width;
    uint32_t    height;
} VkExtent2D;

typedef struct VkRect2D {
    VkOffset2D    offset;
    VkExtent2D    extent;
} VkRect2D;

typedef struct VkPipelineViewportStateCreateInfo {
    VkStructureType                       sType;
    void*                           pNext;
    VkPipelineViewportStateCreateFlags    flags;
    uint32_t                              viewportCount;
    VkViewport*                     pViewports;
    uint32_t                              scissorCount;
    VkRect2D*                       pScissors;
} VkPipelineViewportStateCreateInfo;

typedef struct VkPipelineRasterizationStateCreateInfo {
    VkStructureType                            sType;
    void*                                pNext;
    VkPipelineRasterizationStateCreateFlags    flags;
    VkBool32                                   depthClampEnable;
    VkBool32                                   rasterizerDiscardEnable;
    VkPolygonMode                              polygonMode;
    VkCullModeFlags                            cullMode;
    VkFrontFace                                frontFace;
    VkBool32                                   depthBiasEnable;
    float                                      depthBiasConstantFactor;
    float                                      depthBiasClamp;
    float                                      depthBiasSlopeFactor;
    float                                      lineWidth;
} VkPipelineRasterizationStateCreateInfo;

typedef struct VkPipelineMultisampleStateCreateInfo {
    VkStructureType                          sType;
    void*                              pNext;
    VkPipelineMultisampleStateCreateFlags    flags;
    VkSampleCountFlagBits                    rasterizationSamples;
    VkBool32                                 sampleShadingEnable;
    float                                    minSampleShading;
    VkSampleMask*                      pSampleMask;
    VkBool32                                 alphaToCoverageEnable;
    VkBool32                                 alphaToOneEnable;
} VkPipelineMultisampleStateCreateInfo;

typedef struct VkStencilOpState {
    VkStencilOp    failOp;
    VkStencilOp    passOp;
    VkStencilOp    depthFailOp;
    VkCompareOp    compareOp;
    uint32_t       compareMask;
    uint32_t       writeMask;
    uint32_t       reference;
} VkStencilOpState;

typedef struct VkPipelineDepthStencilStateCreateInfo {
    VkStructureType                           sType;
    void*                               pNext;
    VkPipelineDepthStencilStateCreateFlags    flags;
    VkBool32                                  depthTestEnable;
    VkBool32                                  depthWriteEnable;
    VkCompareOp                               depthCompareOp;
    VkBool32                                  depthBoundsTestEnable;
    VkBool32                                  stencilTestEnable;
    VkStencilOpState                          front;
    VkStencilOpState                          back;
    float                                     minDepthBounds;
    float                                     maxDepthBounds;
} VkPipelineDepthStencilStateCreateInfo;

typedef struct VkPipelineColorBlendAttachmentState {
    VkBool32                 blendEnable;
    VkBlendFactor            srcColorBlendFactor;
    VkBlendFactor            dstColorBlendFactor;
    VkBlendOp                colorBlendOp;
    VkBlendFactor            srcAlphaBlendFactor;
    VkBlendFactor            dstAlphaBlendFactor;
    VkBlendOp                alphaBlendOp;
    VkColorComponentFlags    colorWriteMask;
} VkPipelineColorBlendAttachmentState;

typedef struct VkPipelineColorBlendStateCreateInfo {
    VkStructureType                               sType;
    void*                                   pNext;
    VkPipelineColorBlendStateCreateFlags          flags;
    VkBool32                                      logicOpEnable;
    VkLogicOp                                     logicOp;
    uint32_t                                      attachmentCount;
    VkPipelineColorBlendAttachmentState*    pAttachments;
    float                                         blendConstants[4];
} VkPipelineColorBlendStateCreateInfo;

typedef struct VkPipelineDynamicStateCreateInfo {
    VkStructureType                      sType;
    void*                          pNext;
    VkPipelineDynamicStateCreateFlags    flags;
    uint32_t                             dynamicStateCount;
    VkDynamicState*                pDynamicStates;
} VkPipelineDynamicStateCreateInfo;

typedef struct VkGraphicsPipelineCreateInfo {
    VkStructureType                                  sType;
    void*                                      pNext;
    VkPipelineCreateFlags                            flags;
    uint32_t                                         stageCount;
    VkPipelineShaderStageCreateInfo*           pStages;
    VkPipelineVertexInputStateCreateInfo*      pVertexInputState;
    VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;
    VkPipelineTessellationStateCreateInfo*     pTessellationState;
    VkPipelineViewportStateCreateInfo*         pViewportState;
    VkPipelineRasterizationStateCreateInfo*    pRasterizationState;
    VkPipelineMultisampleStateCreateInfo*      pMultisampleState;
    VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;
    VkPipelineColorBlendStateCreateInfo*       pColorBlendState;
    VkPipelineDynamicStateCreateInfo*          pDynamicState;
    VkPipelineLayout                                 layout;
    VkRenderPass                                     renderPass;
    uint32_t                                         subpass;
    VkPipeline                                       basePipelineHandle;
    int32_t                                          basePipelineIndex;
} VkGraphicsPipelineCreateInfo;

typedef struct VkComputePipelineCreateInfo {
    VkStructureType                    sType;
    void*                        pNext;
    VkPipelineCreateFlags              flags;
    VkPipelineShaderStageCreateInfo    stage;
    VkPipelineLayout                   layout;
    VkPipeline                         basePipelineHandle;
    int32_t                            basePipelineIndex;
} VkComputePipelineCreateInfo;

typedef struct VkPushConstantRange {
    VkShaderStageFlags    stageFlags;
    uint32_t              offset;
    uint32_t              size;
} VkPushConstantRange;

typedef struct VkPipelineLayoutCreateInfo {
    VkStructureType                 sType;
    void*                     pNext;
    VkPipelineLayoutCreateFlags     flags;
    uint32_t                        setLayoutCount;
    VkDescriptorSetLayout*    pSetLayouts;
    uint32_t                        pushConstantRangeCount;
    VkPushConstantRange*      pPushConstantRanges;
} VkPipelineLayoutCreateInfo;

typedef struct VkSamplerCreateInfo {
    VkStructureType         sType;
    void*             pNext;
    VkSamplerCreateFlags    flags;
    VkFilter                magFilter;
    VkFilter                minFilter;
    VkSamplerMipmapMode     mipmapMode;
    VkSamplerAddressMode    addressModeU;
    VkSamplerAddressMode    addressModeV;
    VkSamplerAddressMode    addressModeW;
    float                   mipLodBias;
    VkBool32                anisotropyEnable;
    float                   maxAnisotropy;
    VkBool32                compareEnable;
    VkCompareOp             compareOp;
    float                   minLod;
    float                   maxLod;
    VkBorderColor           borderColor;
    VkBool32                unnormalizedCoordinates;
} VkSamplerCreateInfo;

typedef struct VkDescriptorSetLayoutBinding {
    uint32_t              binding;
    VkDescriptorType      descriptorType;
    uint32_t              descriptorCount;
    VkShaderStageFlags    stageFlags;
    VkSampler*      pImmutableSamplers;
} VkDescriptorSetLayoutBinding;

typedef struct VkDescriptorSetLayoutCreateInfo {
    VkStructureType                        sType;
    void*                            pNext;
    VkDescriptorSetLayoutCreateFlags       flags;
    uint32_t                               bindingCount;
    VkDescriptorSetLayoutBinding*    pBindings;
} VkDescriptorSetLayoutCreateInfo;

typedef struct VkDescriptorPoolSize {
    VkDescriptorType    type;
    uint32_t            descriptorCount;
} VkDescriptorPoolSize;

typedef struct VkDescriptorPoolCreateInfo {
    VkStructureType                sType;
    void*                    pNext;
    VkDescriptorPoolCreateFlags    flags;
    uint32_t                       maxSets;
    uint32_t                       poolSizeCount;
    VkDescriptorPoolSize*    pPoolSizes;
} VkDescriptorPoolCreateInfo;

typedef struct VkDescriptorSetAllocateInfo {
    VkStructureType                 sType;
    void*                     pNext;
    VkDescriptorPool                descriptorPool;
    uint32_t                        descriptorSetCount;
    VkDescriptorSetLayout*    pSetLayouts;
} VkDescriptorSetAllocateInfo;

typedef struct VkDescriptorImageInfo {
    VkSampler        sampler;
    VkImageView      imageView;
    VkImageLayout    imageLayout;
} VkDescriptorImageInfo;

typedef struct VkDescriptorBufferInfo {
    VkBuffer        buffer;
    VkDeviceSize    offset;
    VkDeviceSize    range;
} VkDescriptorBufferInfo;

typedef struct VkWriteDescriptorSet {
    VkStructureType                  sType;
    void*                      pNext;
    VkDescriptorSet                  dstSet;
    uint32_t                         dstBinding;
    uint32_t                         dstArrayElement;
    uint32_t                         descriptorCount;
    VkDescriptorType                 descriptorType;
    VkDescriptorImageInfo*     pImageInfo;
    VkDescriptorBufferInfo*    pBufferInfo;
    VkBufferView*              pTexelBufferView;
} VkWriteDescriptorSet;

typedef struct VkCopyDescriptorSet {
    VkStructureType    sType;
    void*        pNext;
    VkDescriptorSet    srcSet;
    uint32_t           srcBinding;
    uint32_t           srcArrayElement;
    VkDescriptorSet    dstSet;
    uint32_t           dstBinding;
    uint32_t           dstArrayElement;
    uint32_t           descriptorCount;
} VkCopyDescriptorSet;

typedef struct VkFramebufferCreateInfo {
    VkStructureType             sType;
    void*                 pNext;
    VkFramebufferCreateFlags    flags;
    VkRenderPass                renderPass;
    uint32_t                    attachmentCount;
    VkImageView*          pAttachments;
    uint32_t                    width;
    uint32_t                    height;
    uint32_t                    layers;
} VkFramebufferCreateInfo;

typedef struct VkAttachmentDescription {
    VkAttachmentDescriptionFlags    flags;
    VkFormat                        format;
    VkSampleCountFlagBits           samples;
    VkAttachmentLoadOp              loadOp;
    VkAttachmentStoreOp             storeOp;
    VkAttachmentLoadOp              stencilLoadOp;
    VkAttachmentStoreOp             stencilStoreOp;
    VkImageLayout                   initialLayout;
    VkImageLayout                   finalLayout;
} VkAttachmentDescription;

typedef struct VkAttachmentReference {
    uint32_t         attachment;
    VkImageLayout    layout;
} VkAttachmentReference;

typedef struct VkSubpassDescription {
    VkSubpassDescriptionFlags       flags;
    VkPipelineBindPoint             pipelineBindPoint;
    uint32_t                        inputAttachmentCount;
    VkAttachmentReference*    pInputAttachments;
    uint32_t                        colorAttachmentCount;
    VkAttachmentReference*    pColorAttachments;
    VkAttachmentReference*    pResolveAttachments;
    VkAttachmentReference*    pDepthStencilAttachment;
    uint32_t                        preserveAttachmentCount;
    uint32_t*                 pPreserveAttachments;
} VkSubpassDescription;

typedef struct VkSubpassDependency {
    uint32_t                srcSubpass;
    uint32_t                dstSubpass;
    VkPipelineStageFlags    srcStageMask;
    VkPipelineStageFlags    dstStageMask;
    VkAccessFlags           srcAccessMask;
    VkAccessFlags           dstAccessMask;
    VkDependencyFlags       dependencyFlags;
} VkSubpassDependency;

typedef struct VkRenderPassCreateInfo {
    VkStructureType                   sType;
    void*                       pNext;
    VkRenderPassCreateFlags           flags;
    uint32_t                          attachmentCount;
    VkAttachmentDescription*    pAttachments;
    uint32_t                          subpassCount;
    VkSubpassDescription*       pSubpasses;
    uint32_t                          dependencyCount;
    VkSubpassDependency*        pDependencies;
} VkRenderPassCreateInfo;

typedef struct VkCommandPoolCreateInfo {
    VkStructureType             sType;
    void*                 pNext;
    VkCommandPoolCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
} VkCommandPoolCreateInfo;

typedef struct VkCommandBufferAllocateInfo {
    VkStructureType         sType;
    void*             pNext;
    VkCommandPool           commandPool;
    VkCommandBufferLevel    level;
    uint32_t                commandBufferCount;
} VkCommandBufferAllocateInfo;

typedef struct VkCommandBufferInheritanceInfo {
    VkStructureType                  sType;
    void*                      pNext;
    VkRenderPass                     renderPass;
    uint32_t                         subpass;
    VkFramebuffer                    framebuffer;
    VkBool32                         occlusionQueryEnable;
    VkQueryControlFlags              queryFlags;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkCommandBufferInheritanceInfo;

typedef struct VkCommandBufferBeginInfo {
    VkStructureType                          sType;
    void*                              pNext;
    VkCommandBufferUsageFlags                flags;
    VkCommandBufferInheritanceInfo*    pInheritanceInfo;
} VkCommandBufferBeginInfo;

typedef struct VkBufferCopy {
    VkDeviceSize    srcOffset;
    VkDeviceSize    dstOffset;
    VkDeviceSize    size;
} VkBufferCopy;

typedef struct VkImageSubresourceLayers {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceLayers;

typedef struct VkImageCopy {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageCopy;

typedef struct VkImageBlit {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffsets[2];
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffsets[2];
} VkImageBlit;

typedef struct VkBufferImageCopy {
    VkDeviceSize                bufferOffset;
    uint32_t                    bufferRowLength;
    uint32_t                    bufferImageHeight;
    VkImageSubresourceLayers    imageSubresource;
    VkOffset3D                  imageOffset;
    VkExtent3D                  imageExtent;
} VkBufferImageCopy;

typedef union VkClearColorValue {
    float       float32[4];
    int32_t     int32[4];
    uint32_t    uint32[4];
} VkClearColorValue;

typedef struct VkClearDepthStencilValue {
    float       depth;
    uint32_t    stencil;
} VkClearDepthStencilValue;

typedef union VkClearValue {
    VkClearColorValue           color;
    VkClearDepthStencilValue    depthStencil;
} VkClearValue;

typedef struct VkClearAttachment {
    VkImageAspectFlags    aspectMask;
    uint32_t              colorAttachment;
    VkClearValue          clearValue;
} VkClearAttachment;

typedef struct VkClearRect {
    VkRect2D    rect;
    uint32_t    baseArrayLayer;
    uint32_t    layerCount;
} VkClearRect;

typedef struct VkImageResolve {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageResolve;

typedef struct VkMemoryBarrier {
    VkStructureType    sType;
    void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
} VkMemoryBarrier;

typedef struct VkBufferMemoryBarrier {
    VkStructureType    sType;
    void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
    uint32_t           srcQueueFamilyIndex;
    uint32_t           dstQueueFamilyIndex;
    VkBuffer           buffer;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkBufferMemoryBarrier;

typedef struct VkImageMemoryBarrier {
    VkStructureType            sType;
    void*                pNext;
    VkAccessFlags              srcAccessMask;
    VkAccessFlags              dstAccessMask;
    VkImageLayout              oldLayout;
    VkImageLayout              newLayout;
    uint32_t                   srcQueueFamilyIndex;
    uint32_t                   dstQueueFamilyIndex;
    VkImage                    image;
    VkImageSubresourceRange    subresourceRange;
} VkImageMemoryBarrier;

typedef struct VkRenderPassBeginInfo {
    VkStructureType        sType;
    void*            pNext;
    VkRenderPass           renderPass;
    VkFramebuffer          framebuffer;
    VkRect2D               renderArea;
    uint32_t               clearValueCount;
    VkClearValue*    pClearValues;
} VkRenderPassBeginInfo;

typedef struct VkDispatchIndirectCommand {
    uint32_t    x;
    uint32_t    y;
    uint32_t    z;
} VkDispatchIndirectCommand;

typedef struct VkDrawIndexedIndirectCommand {
    uint32_t    indexCount;
    uint32_t    instanceCount;
    uint32_t    firstIndex;
    int32_t     vertexOffset;
    uint32_t    firstInstance;
} VkDrawIndexedIndirectCommand;

typedef struct VkDrawIndirectCommand {
    uint32_t    vertexCount;
    uint32_t    instanceCount;
    uint32_t    firstVertex;
    uint32_t    firstInstance;
} VkDrawIndirectCommand;


typedef VkResult (VKAPI_PTR *PFN_vkCreateInstance)(const VkInstanceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkInstance* pInstance);
typedef void (VKAPI_PTR *PFN_vkDestroyInstance)(VkInstance instance, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkEnumeratePhysicalDevices)(VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFeatures)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties)(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceMemoryProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties);
typedef PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetInstanceProcAddr)(VkInstance instance, char* pName);
typedef PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetDeviceProcAddr)(VkDevice device, char* pName);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDevice)(VkPhysicalDevice physicalDevice, VkDeviceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDevice* pDevice);
typedef void (VKAPI_PTR *PFN_vkDestroyDevice)(VkDevice device, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceExtensionProperties)(const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceExtensionProperties)(VkPhysicalDevice physicalDevice, char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceLayerProperties)(uint32_t* pPropertyCount, VkLayerProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceLayerProperties)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties);
typedef void (VKAPI_PTR *PFN_vkGetDeviceQueue)(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue);
typedef VkResult (VKAPI_PTR *PFN_vkQueueSubmit)(VkQueue queue, uint32_t submitCount, VkSubmitInfo* pSubmits, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkQueueWaitIdle)(VkQueue queue);
typedef VkResult (VKAPI_PTR *PFN_vkDeviceWaitIdle)(VkDevice device);
typedef VkResult (VKAPI_PTR *PFN_vkAllocateMemory)(VkDevice device, VkMemoryAllocateInfo* pAllocateInfo, VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory);
typedef void (VKAPI_PTR *PFN_vkFreeMemory)(VkDevice device, VkDeviceMemory memory, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkMapMemory)(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData);
typedef void (VKAPI_PTR *PFN_vkUnmapMemory)(VkDevice device, VkDeviceMemory memory);
typedef VkResult (VKAPI_PTR *PFN_vkFlushMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, VkMappedMemoryRange* pMemoryRanges);
typedef VkResult (VKAPI_PTR *PFN_vkInvalidateMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, VkMappedMemoryRange* pMemoryRanges);
typedef void (VKAPI_PTR *PFN_vkGetDeviceMemoryCommitment)(VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes);
typedef VkResult (VKAPI_PTR *PFN_vkBindBufferMemory)(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef VkResult (VKAPI_PTR *PFN_vkBindImageMemory)(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef void (VKAPI_PTR *PFN_vkGetBufferMemoryRequirements)(VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements)(VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetImageSparseMemoryRequirements)(VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkQueueBindSparse)(VkQueue queue, uint32_t bindInfoCount, VkBindSparseInfo* pBindInfo, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkCreateFence)(VkDevice device, VkFenceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkFence* pFence);
typedef void (VKAPI_PTR *PFN_vkDestroyFence)(VkDevice device, VkFence fence, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetFences)(VkDevice device, uint32_t fenceCount, VkFence* pFences);
typedef VkResult (VKAPI_PTR *PFN_vkGetFenceStatus)(VkDevice device, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkWaitForFences)(VkDevice device, uint32_t fenceCount, VkFence* pFences, VkBool32 waitAll, uint64_t timeout);
typedef VkResult (VKAPI_PTR *PFN_vkCreateSemaphore)(VkDevice device, VkSemaphoreCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore);
typedef void (VKAPI_PTR *PFN_vkDestroySemaphore)(VkDevice device, VkSemaphore semaphore, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateEvent)(VkDevice device, VkEventCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkEvent* pEvent);
typedef void (VKAPI_PTR *PFN_vkDestroyEvent)(VkDevice device, VkEvent event, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetEventStatus)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkSetEvent)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkResetEvent)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkCreateQueryPool)(VkDevice device, VkQueryPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool);
typedef void (VKAPI_PTR *PFN_vkDestroyQueryPool)(VkDevice device, VkQueryPool queryPool, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetQueryPoolResults)(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags);
typedef VkResult (VKAPI_PTR *PFN_vkCreateBuffer)(VkDevice device, VkBufferCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer);
typedef void (VKAPI_PTR *PFN_vkDestroyBuffer)(VkDevice device, VkBuffer buffer, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateBufferView)(VkDevice device, VkBufferViewCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkBufferView* pView);
typedef void (VKAPI_PTR *PFN_vkDestroyBufferView)(VkDevice device, VkBufferView bufferView, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateImage)(VkDevice device, VkImageCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkImage* pImage);
typedef void (VKAPI_PTR *PFN_vkDestroyImage)(VkDevice device, VkImage image, VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout)(VkDevice device, VkImage image, VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout);
typedef VkResult (VKAPI_PTR *PFN_vkCreateImageView)(VkDevice device, VkImageViewCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkImageView* pView);
typedef void (VKAPI_PTR *PFN_vkDestroyImageView)(VkDevice device, VkImageView imageView, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateShaderModule)(VkDevice device, VkShaderModuleCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule);
typedef void (VKAPI_PTR *PFN_vkDestroyShaderModule)(VkDevice device, VkShaderModule shaderModule, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineCache)(VkDevice device, VkPipelineCacheCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache);
typedef void (VKAPI_PTR *PFN_vkDestroyPipelineCache)(VkDevice device, VkPipelineCache pipelineCache, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetPipelineCacheData)(VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData);
typedef VkResult (VKAPI_PTR *PFN_vkMergePipelineCaches)(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, VkPipelineCache* pSrcCaches);
typedef VkResult (VKAPI_PTR *PFN_vkCreateGraphicsPipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, VkGraphicsPipelineCreateInfo* pCreateInfos, VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
typedef VkResult (VKAPI_PTR *PFN_vkCreateComputePipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, VkComputePipelineCreateInfo* pCreateInfos, VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
typedef void (VKAPI_PTR *PFN_vkDestroyPipeline)(VkDevice device, VkPipeline pipeline, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineLayout)(VkDevice device, VkPipelineLayoutCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout);
typedef void (VKAPI_PTR *PFN_vkDestroyPipelineLayout)(VkDevice device, VkPipelineLayout pipelineLayout, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateSampler)(VkDevice device, VkSamplerCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSampler* pSampler);
typedef void (VKAPI_PTR *PFN_vkDestroySampler)(VkDevice device, VkSampler sampler, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorSetLayout)(VkDevice device, VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout);
typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorSetLayout)(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorPool)(VkDevice device, VkDescriptorPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool);
typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags);
typedef VkResult (VKAPI_PTR *PFN_vkAllocateDescriptorSets)(VkDevice device, VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets);
typedef VkResult (VKAPI_PTR *PFN_vkFreeDescriptorSets)(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, VkDescriptorSet* pDescriptorSets);
typedef void (VKAPI_PTR *PFN_vkUpdateDescriptorSets)(VkDevice device, uint32_t descriptorWriteCount, VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, VkCopyDescriptorSet* pDescriptorCopies);
typedef VkResult (VKAPI_PTR *PFN_vkCreateFramebuffer)(VkDevice device, VkFramebufferCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer);
typedef void (VKAPI_PTR *PFN_vkDestroyFramebuffer)(VkDevice device, VkFramebuffer framebuffer, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateRenderPass)(VkDevice device, VkRenderPassCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass);
typedef void (VKAPI_PTR *PFN_vkDestroyRenderPass)(VkDevice device, VkRenderPass renderPass, VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkGetRenderAreaGranularity)(VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity);
typedef VkResult (VKAPI_PTR *PFN_vkCreateCommandPool)(VkDevice device, VkCommandPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool);
typedef void (VKAPI_PTR *PFN_vkDestroyCommandPool)(VkDevice device, VkCommandPool commandPool, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetCommandPool)(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags);
typedef VkResult (VKAPI_PTR *PFN_vkAllocateCommandBuffers)(VkDevice device, VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers);
typedef void (VKAPI_PTR *PFN_vkFreeCommandBuffers)(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, VkCommandBuffer* pCommandBuffers);
typedef VkResult (VKAPI_PTR *PFN_vkBeginCommandBuffer)(VkCommandBuffer commandBuffer, VkCommandBufferBeginInfo* pBeginInfo);
typedef VkResult (VKAPI_PTR *PFN_vkEndCommandBuffer)(VkCommandBuffer commandBuffer);
typedef VkResult (VKAPI_PTR *PFN_vkResetCommandBuffer)(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdBindPipeline)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
typedef void (VKAPI_PTR *PFN_vkCmdSetViewport)(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, VkViewport* pViewports);
typedef void (VKAPI_PTR *PFN_vkCmdSetScissor)(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, VkRect2D* pScissors);
typedef void (VKAPI_PTR *PFN_vkCmdSetLineWidth)(VkCommandBuffer commandBuffer, float lineWidth);
typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBias)(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);
typedef void (VKAPI_PTR *PFN_vkCmdSetBlendConstants)(VkCommandBuffer commandBuffer, float blendConstants[4]);
typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBounds)(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilCompareMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilWriteMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilReference)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference);
typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorSets)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, uint32_t* pDynamicOffsets);
typedef void (VKAPI_PTR *PFN_vkCmdBindIndexBuffer)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType);
typedef void (VKAPI_PTR *PFN_vkCmdBindVertexBuffers)(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, VkBuffer* pBuffers, VkDeviceSize* pOffsets);
typedef void (VKAPI_PTR *PFN_vkCmdDraw)(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexed)(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDispatch)(VkCommandBuffer commandBuffer, uint32_t x, uint32_t y, uint32_t z);
typedef void (VKAPI_PTR *PFN_vkCmdDispatchIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);
typedef void (VKAPI_PTR *PFN_vkCmdCopyBuffer)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, VkBufferCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdCopyImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdBlitImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageBlit* pRegions, VkFilter filter);
typedef void (VKAPI_PTR *PFN_vkCmdCopyBufferToImage)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkBufferImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdCopyImageToBuffer)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, VkBufferImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdUpdateBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, void* pData);
typedef void (VKAPI_PTR *PFN_vkCmdFillBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data);
typedef void (VKAPI_PTR *PFN_vkCmdClearColorImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearColorValue* pColor, uint32_t rangeCount, VkImageSubresourceRange* pRanges);
typedef void (VKAPI_PTR *PFN_vkCmdClearDepthStencilImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, VkImageSubresourceRange* pRanges);
typedef void (VKAPI_PTR *PFN_vkCmdClearAttachments)(VkCommandBuffer commandBuffer, uint32_t attachmentCount, VkClearAttachment* pAttachments, uint32_t rectCount, VkClearRect* pRects);
typedef void (VKAPI_PTR *PFN_vkCmdResolveImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageResolve* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdSetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef void (VKAPI_PTR *PFN_vkCmdResetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef void (VKAPI_PTR *PFN_vkCmdWaitEvents)(VkCommandBuffer commandBuffer, uint32_t eventCount, VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, VkImageMemoryBarrier* pImageMemoryBarriers);
typedef void (VKAPI_PTR *PFN_vkCmdPipelineBarrier)(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, VkImageMemoryBarrier* pImageMemoryBarriers);
typedef void (VKAPI_PTR *PFN_vkCmdBeginQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdEndQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query);
typedef void (VKAPI_PTR *PFN_vkCmdResetQueryPool)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
typedef void (VKAPI_PTR *PFN_vkCmdWriteTimestamp)(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query);
typedef void (VKAPI_PTR *PFN_vkCmdCopyQueryPoolResults)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdPushConstants)(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, void* pValues);
typedef void (VKAPI_PTR *PFN_vkCmdBeginRenderPass)(VkCommandBuffer commandBuffer, VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents);
typedef void (VKAPI_PTR *PFN_vkCmdNextSubpass)(VkCommandBuffer commandBuffer, VkSubpassContents contents);
typedef void (VKAPI_PTR *PFN_vkCmdEndRenderPass)(VkCommandBuffer commandBuffer);
typedef void (VKAPI_PTR *PFN_vkCmdExecuteCommands)(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, VkCommandBuffer* pCommandBuffers);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateInstance(
    VkInstanceCreateInfo*                 pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkInstance*                                 pInstance);

VKAPI_ATTR void VKAPI_CALL vkDestroyInstance(
    VkInstance                                  instance,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkEnumeratePhysicalDevices(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceCount,
    VkPhysicalDevice*                           pPhysicalDevices);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures*                   pFeatures);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkFormatProperties*                         pFormatProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkImageFormatProperties*                    pImageFormatProperties);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties*                 pProperties);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pQueueFamilyPropertyCount,
    VkQueueFamilyProperties*                    pQueueFamilyProperties);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties*           pMemoryProperties);

VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vkGetInstanceProcAddr(
    VkInstance                                  instance,
    char*                                 pName);

VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vkGetDeviceProcAddr(
    VkDevice                                    device,
    char*                                 pName);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDevice(
    VkPhysicalDevice                            physicalDevice,
    VkDeviceCreateInfo*                   pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDevice*                                   pDevice);

VKAPI_ATTR void VKAPI_CALL vkDestroyDevice(
    VkDevice                                    device,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateInstanceExtensionProperties(
    char*                                 pLayerName,
    uint32_t*                                   pPropertyCount,
    VkExtensionProperties*                      pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice                            physicalDevice,
    char*                                 pLayerName,
    uint32_t*                                   pPropertyCount,
    VkExtensionProperties*                      pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateInstanceLayerProperties(
    uint32_t*                                   pPropertyCount,
    VkLayerProperties*                          pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkLayerProperties*                          pProperties);

VKAPI_ATTR void VKAPI_CALL vkGetDeviceQueue(
    VkDevice                                    device,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex,
    VkQueue*                                    pQueue);

VKAPI_ATTR VkResult VKAPI_CALL vkQueueSubmit(
    VkQueue                                     queue,
    uint32_t                                    submitCount,
    VkSubmitInfo*                         pSubmits,
    VkFence                                     fence);

VKAPI_ATTR VkResult VKAPI_CALL vkQueueWaitIdle(
    VkQueue                                     queue);

VKAPI_ATTR VkResult VKAPI_CALL vkDeviceWaitIdle(
    VkDevice                                    device);

VKAPI_ATTR VkResult VKAPI_CALL vkAllocateMemory(
    VkDevice                                    device,
    VkMemoryAllocateInfo*                 pAllocateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDeviceMemory*                             pMemory);

VKAPI_ATTR void VKAPI_CALL vkFreeMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkMapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkMemoryMapFlags                            flags,
    void**                                      ppData);

VKAPI_ATTR void VKAPI_CALL vkUnmapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory);

VKAPI_ATTR VkResult VKAPI_CALL vkFlushMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    VkMappedMemoryRange*                  pMemoryRanges);

VKAPI_ATTR VkResult VKAPI_CALL vkInvalidateMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    VkMappedMemoryRange*                  pMemoryRanges);

VKAPI_ATTR void VKAPI_CALL vkGetDeviceMemoryCommitment(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize*                               pCommittedMemoryInBytes);

VKAPI_ATTR VkResult VKAPI_CALL vkBindBufferMemory(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);

VKAPI_ATTR VkResult VKAPI_CALL vkBindImageMemory(
    VkDevice                                    device,
    VkImage                                     image,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);

VKAPI_ATTR void VKAPI_CALL vkGetBufferMemoryRequirements(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkMemoryRequirements*                       pMemoryRequirements);

VKAPI_ATTR void VKAPI_CALL vkGetImageMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    VkMemoryRequirements*                       pMemoryRequirements);

VKAPI_ATTR void VKAPI_CALL vkGetImageSparseMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements*            pSparseMemoryRequirements);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling,
    uint32_t*                                   pPropertyCount,
    VkSparseImageFormatProperties*              pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkQueueBindSparse(
    VkQueue                                     queue,
    uint32_t                                    bindInfoCount,
    VkBindSparseInfo*                     pBindInfo,
    VkFence                                     fence);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateFence(
    VkDevice                                    device,
    VkFenceCreateInfo*                    pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence);

VKAPI_ATTR void VKAPI_CALL vkDestroyFence(
    VkDevice                                    device,
    VkFence                                     fence,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkResetFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    VkFence*                              pFences);

VKAPI_ATTR VkResult VKAPI_CALL vkGetFenceStatus(
    VkDevice                                    device,
    VkFence                                     fence);

VKAPI_ATTR VkResult VKAPI_CALL vkWaitForFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    VkFence*                              pFences,
    VkBool32                                    waitAll,
    uint64_t                                    timeout);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateSemaphore(
    VkDevice                                    device,
    VkSemaphoreCreateInfo*                pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSemaphore*                                pSemaphore);

VKAPI_ATTR void VKAPI_CALL vkDestroySemaphore(
    VkDevice                                    device,
    VkSemaphore                                 semaphore,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateEvent(
    VkDevice                                    device,
    VkEventCreateInfo*                    pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkEvent*                                    pEvent);

VKAPI_ATTR void VKAPI_CALL vkDestroyEvent(
    VkDevice                                    device,
    VkEvent                                     event,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkGetEventStatus(
    VkDevice                                    device,
    VkEvent                                     event);

VKAPI_ATTR VkResult VKAPI_CALL vkSetEvent(
    VkDevice                                    device,
    VkEvent                                     event);

VKAPI_ATTR VkResult VKAPI_CALL vkResetEvent(
    VkDevice                                    device,
    VkEvent                                     event);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateQueryPool(
    VkDevice                                    device,
    VkQueryPoolCreateInfo*                pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkQueryPool*                                pQueryPool);

VKAPI_ATTR void VKAPI_CALL vkDestroyQueryPool(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkGetQueryPoolResults(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    size_t                                      dataSize,
    void*                                       pData,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateBuffer(
    VkDevice                                    device,
    VkBufferCreateInfo*                   pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkBuffer*                                   pBuffer);

VKAPI_ATTR void VKAPI_CALL vkDestroyBuffer(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateBufferView(
    VkDevice                                    device,
    VkBufferViewCreateInfo*               pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkBufferView*                               pView);

VKAPI_ATTR void VKAPI_CALL vkDestroyBufferView(
    VkDevice                                    device,
    VkBufferView                                bufferView,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateImage(
    VkDevice                                    device,
    VkImageCreateInfo*                    pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkImage*                                    pImage);

VKAPI_ATTR void VKAPI_CALL vkDestroyImage(
    VkDevice                                    device,
    VkImage                                     image,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR void VKAPI_CALL vkGetImageSubresourceLayout(
    VkDevice                                    device,
    VkImage                                     image,
    VkImageSubresource*                   pSubresource,
    VkSubresourceLayout*                        pLayout);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateImageView(
    VkDevice                                    device,
    VkImageViewCreateInfo*                pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkImageView*                                pView);

VKAPI_ATTR void VKAPI_CALL vkDestroyImageView(
    VkDevice                                    device,
    VkImageView                                 imageView,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateShaderModule(
    VkDevice                                    device,
    VkShaderModuleCreateInfo*             pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkShaderModule*                             pShaderModule);

VKAPI_ATTR void VKAPI_CALL vkDestroyShaderModule(
    VkDevice                                    device,
    VkShaderModule                              shaderModule,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreatePipelineCache(
    VkDevice                                    device,
    VkPipelineCacheCreateInfo*            pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkPipelineCache*                            pPipelineCache);

VKAPI_ATTR void VKAPI_CALL vkDestroyPipelineCache(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPipelineCacheData(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    size_t*                                     pDataSize,
    void*                                       pData);

VKAPI_ATTR VkResult VKAPI_CALL vkMergePipelineCaches(
    VkDevice                                    device,
    VkPipelineCache                             dstCache,
    uint32_t                                    srcCacheCount,
    VkPipelineCache*                      pSrcCaches);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateGraphicsPipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    VkGraphicsPipelineCreateInfo*         pCreateInfos,
    VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateComputePipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    VkComputePipelineCreateInfo*          pCreateInfos,
    VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines);

VKAPI_ATTR void VKAPI_CALL vkDestroyPipeline(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreatePipelineLayout(
    VkDevice                                    device,
    VkPipelineLayoutCreateInfo*           pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkPipelineLayout*                           pPipelineLayout);

VKAPI_ATTR void VKAPI_CALL vkDestroyPipelineLayout(
    VkDevice                                    device,
    VkPipelineLayout                            pipelineLayout,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateSampler(
    VkDevice                                    device,
    VkSamplerCreateInfo*                  pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSampler*                                  pSampler);

VKAPI_ATTR void VKAPI_CALL vkDestroySampler(
    VkDevice                                    device,
    VkSampler                                   sampler,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDescriptorSetLayout(
    VkDevice                                    device,
    VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDescriptorSetLayout*                      pSetLayout);

VKAPI_ATTR void VKAPI_CALL vkDestroyDescriptorSetLayout(
    VkDevice                                    device,
    VkDescriptorSetLayout                       descriptorSetLayout,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPoolCreateInfo*           pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDescriptorPool*                           pDescriptorPool);

VKAPI_ATTR void VKAPI_CALL vkDestroyDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkResetDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    VkDescriptorPoolResetFlags                  flags);

VKAPI_ATTR VkResult VKAPI_CALL vkAllocateDescriptorSets(
    VkDevice                                    device,
    VkDescriptorSetAllocateInfo*          pAllocateInfo,
    VkDescriptorSet*                            pDescriptorSets);

VKAPI_ATTR VkResult VKAPI_CALL vkFreeDescriptorSets(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    uint32_t                                    descriptorSetCount,
    VkDescriptorSet*                      pDescriptorSets);

VKAPI_ATTR void VKAPI_CALL vkUpdateDescriptorSets(
    VkDevice                                    device,
    uint32_t                                    descriptorWriteCount,
    VkWriteDescriptorSet*                 pDescriptorWrites,
    uint32_t                                    descriptorCopyCount,
    VkCopyDescriptorSet*                  pDescriptorCopies);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateFramebuffer(
    VkDevice                                    device,
    VkFramebufferCreateInfo*              pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkFramebuffer*                              pFramebuffer);

VKAPI_ATTR void VKAPI_CALL vkDestroyFramebuffer(
    VkDevice                                    device,
    VkFramebuffer                               framebuffer,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateRenderPass(
    VkDevice                                    device,
    VkRenderPassCreateInfo*               pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkRenderPass*                               pRenderPass);

VKAPI_ATTR void VKAPI_CALL vkDestroyRenderPass(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR void VKAPI_CALL vkGetRenderAreaGranularity(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    VkExtent2D*                                 pGranularity);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateCommandPool(
    VkDevice                                    device,
    VkCommandPoolCreateInfo*              pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkCommandPool*                              pCommandPool);

VKAPI_ATTR void VKAPI_CALL vkDestroyCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkResetCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkCommandPoolResetFlags                     flags);

VKAPI_ATTR VkResult VKAPI_CALL vkAllocateCommandBuffers(
    VkDevice                                    device,
    VkCommandBufferAllocateInfo*          pAllocateInfo,
    VkCommandBuffer*                            pCommandBuffers);

VKAPI_ATTR void VKAPI_CALL vkFreeCommandBuffers(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    uint32_t                                    commandBufferCount,
    VkCommandBuffer*                      pCommandBuffers);

VKAPI_ATTR VkResult VKAPI_CALL vkBeginCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    VkCommandBufferBeginInfo*             pBeginInfo);

VKAPI_ATTR VkResult VKAPI_CALL vkEndCommandBuffer(
    VkCommandBuffer                             commandBuffer);

VKAPI_ATTR VkResult VKAPI_CALL vkResetCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    VkCommandBufferResetFlags                   flags);

VKAPI_ATTR void VKAPI_CALL vkCmdBindPipeline(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipeline                                  pipeline);

VKAPI_ATTR void VKAPI_CALL vkCmdSetViewport(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    VkViewport*                           pViewports);

VKAPI_ATTR void VKAPI_CALL vkCmdSetScissor(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstScissor,
    uint32_t                                    scissorCount,
    VkRect2D*                             pScissors);

VKAPI_ATTR void VKAPI_CALL vkCmdSetLineWidth(
    VkCommandBuffer                             commandBuffer,
    float                                       lineWidth);

VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBias(
    VkCommandBuffer                             commandBuffer,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor);

VKAPI_ATTR void VKAPI_CALL vkCmdSetBlendConstants(
    VkCommandBuffer                             commandBuffer,
    float                                 blendConstants[4]);

VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBounds(
    VkCommandBuffer                             commandBuffer,
    float                                       minDepthBounds,
    float                                       maxDepthBounds);

VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilCompareMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    compareMask);

VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilWriteMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    writeMask);

VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilReference(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    reference);

VKAPI_ATTR void VKAPI_CALL vkCmdBindDescriptorSets(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    descriptorSetCount,
    VkDescriptorSet*                      pDescriptorSets,
    uint32_t                                    dynamicOffsetCount,
    uint32_t*                             pDynamicOffsets);

VKAPI_ATTR void VKAPI_CALL vkCmdBindIndexBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkIndexType                                 indexType);

VKAPI_ATTR void VKAPI_CALL vkCmdBindVertexBuffers(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    VkBuffer*                             pBuffers,
    VkDeviceSize*                         pOffsets);

VKAPI_ATTR void VKAPI_CALL vkCmdDraw(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance);

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexed(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance);

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride);

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexedIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride);

VKAPI_ATTR void VKAPI_CALL vkCmdDispatch(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    x,
    uint32_t                                    y,
    uint32_t                                    z);

VKAPI_ATTR void VKAPI_CALL vkCmdDispatchIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset);

VKAPI_ATTR void VKAPI_CALL vkCmdCopyBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    VkBufferCopy*                         pRegions);

VKAPI_ATTR void VKAPI_CALL vkCmdCopyImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    VkImageCopy*                          pRegions);

VKAPI_ATTR void VKAPI_CALL vkCmdBlitImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    VkImageBlit*                          pRegions,
    VkFilter                                    filter);

VKAPI_ATTR void VKAPI_CALL vkCmdCopyBufferToImage(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    VkBufferImageCopy*                    pRegions);

VKAPI_ATTR void VKAPI_CALL vkCmdCopyImageToBuffer(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    VkBufferImageCopy*                    pRegions);

VKAPI_ATTR void VKAPI_CALL vkCmdUpdateBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                dataSize,
    void*                                 pData);

VKAPI_ATTR void VKAPI_CALL vkCmdFillBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size,
    uint32_t                                    data);

VKAPI_ATTR void VKAPI_CALL vkCmdClearColorImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    VkClearColorValue*                    pColor,
    uint32_t                                    rangeCount,
    VkImageSubresourceRange*              pRanges);

VKAPI_ATTR void VKAPI_CALL vkCmdClearDepthStencilImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    VkClearDepthStencilValue*             pDepthStencil,
    uint32_t                                    rangeCount,
    VkImageSubresourceRange*              pRanges);

VKAPI_ATTR void VKAPI_CALL vkCmdClearAttachments(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    attachmentCount,
    VkClearAttachment*                    pAttachments,
    uint32_t                                    rectCount,
    VkClearRect*                          pRects);

VKAPI_ATTR void VKAPI_CALL vkCmdResolveImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    VkImageResolve*                       pRegions);

VKAPI_ATTR void VKAPI_CALL vkCmdSetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask);

VKAPI_ATTR void VKAPI_CALL vkCmdResetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask);

VKAPI_ATTR void VKAPI_CALL vkCmdWaitEvents(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    eventCount,
    VkEvent*                              pEvents,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    uint32_t                                    memoryBarrierCount,
    VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    VkImageMemoryBarrier*                 pImageMemoryBarriers);

VKAPI_ATTR void VKAPI_CALL vkCmdPipelineBarrier(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkDependencyFlags                           dependencyFlags,
    uint32_t                                    memoryBarrierCount,
    VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    VkImageMemoryBarrier*                 pImageMemoryBarriers);

VKAPI_ATTR void VKAPI_CALL vkCmdBeginQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags);

VKAPI_ATTR void VKAPI_CALL vkCmdEndQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query);

VKAPI_ATTR void VKAPI_CALL vkCmdResetQueryPool(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount);

VKAPI_ATTR void VKAPI_CALL vkCmdWriteTimestamp(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    VkQueryPool                                 queryPool,
    uint32_t                                    query);

VKAPI_ATTR void VKAPI_CALL vkCmdCopyQueryPoolResults(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags);

VKAPI_ATTR void VKAPI_CALL vkCmdPushConstants(
    VkCommandBuffer                             commandBuffer,
    VkPipelineLayout                            layout,
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size,
    void*                                 pValues);

VKAPI_ATTR void VKAPI_CALL vkCmdBeginRenderPass(
    VkCommandBuffer                             commandBuffer,
    VkRenderPassBeginInfo*                pRenderPassBegin,
    VkSubpassContents                           contents);

VKAPI_ATTR void VKAPI_CALL vkCmdNextSubpass(
    VkCommandBuffer                             commandBuffer,
    VkSubpassContents                           contents);

VKAPI_ATTR void VKAPI_CALL vkCmdEndRenderPass(
    VkCommandBuffer                             commandBuffer);

VKAPI_ATTR void VKAPI_CALL vkCmdExecuteCommands(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    commandBufferCount,
    VkCommandBuffer*                      pCommandBuffers);
#endif

#define VK_KHR_surface 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSurfaceKHR)

#define VK_KHR_SURFACE_SPEC_VERSION       25
#define VK_KHR_SURFACE_EXTENSION_NAME     "VK_KHR_surface"
#define VK_COLORSPACE_SRGB_NONLINEAR_KHR  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR


typedef enum VkColorSpaceKHR {
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
    VK_COLOR_SPACE_BEGIN_RANGE_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VK_COLOR_SPACE_END_RANGE_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VK_COLOR_SPACE_RANGE_SIZE_KHR = (VK_COLOR_SPACE_SRGB_NONLINEAR_KHR - VK_COLOR_SPACE_SRGB_NONLINEAR_KHR + 1),
    VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkColorSpaceKHR;

typedef enum VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    VK_PRESENT_MODE_BEGIN_RANGE_KHR = VK_PRESENT_MODE_IMMEDIATE_KHR,
    VK_PRESENT_MODE_END_RANGE_KHR = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    VK_PRESENT_MODE_RANGE_SIZE_KHR = (VK_PRESENT_MODE_FIFO_RELAXED_KHR - VK_PRESENT_MODE_IMMEDIATE_KHR + 1),
    VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkPresentModeKHR;


typedef enum VkSurfaceTransformFlagBitsKHR {
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100,
    VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkSurfaceTransformFlagBitsKHR;
typedef VkFlags VkSurfaceTransformFlagsKHR;

typedef enum VkCompositeAlphaFlagBitsKHR {
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008,
    VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkCompositeAlphaFlagBitsKHR;
typedef VkFlags VkCompositeAlphaFlagsKHR;

typedef struct VkSurfaceCapabilitiesKHR {
    uint32_t                         minImageCount;
    uint32_t                         maxImageCount;
    VkExtent2D                       currentExtent;
    VkExtent2D                       minImageExtent;
    VkExtent2D                       maxImageExtent;
    uint32_t                         maxImageArrayLayers;
    VkSurfaceTransformFlagsKHR       supportedTransforms;
    VkSurfaceTransformFlagBitsKHR    currentTransform;
    VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;
    VkImageUsageFlags                supportedUsageFlags;
} VkSurfaceCapabilitiesKHR;

typedef struct VkSurfaceFormatKHR {
    VkFormat           format;
    VkColorSpaceKHR    colorSpace;
} VkSurfaceFormatKHR;


typedef void (VKAPI_PTR *PFN_vkDestroySurfaceKHR)(VkInstance instance, VkSurfaceKHR surface, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR void VKAPI_CALL vkDestroySurfaceKHR(
    VkInstance                                  instance,
    VkSurfaceKHR                                surface,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    VkSurfaceKHR                                surface,
    VkBool32*                                   pSupported);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    VkSurfaceCapabilitiesKHR*                   pSurfaceCapabilities);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pSurfaceFormatCount,
    VkSurfaceFormatKHR*                         pSurfaceFormats);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pPresentModeCount,
    VkPresentModeKHR*                           pPresentModes);
#endif

#define VK_KHR_swapchain 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSwapchainKHR)

#define VK_KHR_SWAPCHAIN_SPEC_VERSION     68
#define VK_KHR_SWAPCHAIN_EXTENSION_NAME   "VK_KHR_swapchain"

typedef VkFlags VkSwapchainCreateFlagsKHR;

typedef struct VkSwapchainCreateInfoKHR {
    VkStructureType                  sType;
    void*                      pNext;
    VkSwapchainCreateFlagsKHR        flags;
    VkSurfaceKHR                     surface;
    uint32_t                         minImageCount;
    VkFormat                         imageFormat;
    VkColorSpaceKHR                  imageColorSpace;
    VkExtent2D                       imageExtent;
    uint32_t                         imageArrayLayers;
    VkImageUsageFlags                imageUsage;
    VkSharingMode                    imageSharingMode;
    uint32_t                         queueFamilyIndexCount;
    uint32_t*                  pQueueFamilyIndices;
    VkSurfaceTransformFlagBitsKHR    preTransform;
    VkCompositeAlphaFlagBitsKHR      compositeAlpha;
    VkPresentModeKHR                 presentMode;
    VkBool32                         clipped;
    VkSwapchainKHR                   oldSwapchain;
} VkSwapchainCreateInfoKHR;

typedef struct VkPresentInfoKHR {
    VkStructureType          sType;
    void*              pNext;
    uint32_t                 waitSemaphoreCount;
    VkSemaphore*       pWaitSemaphores;
    uint32_t                 swapchainCount;
    VkSwapchainKHR*    pSwapchains;
    uint32_t*          pImageIndices;
    VkResult*                pResults;
} VkPresentInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateSwapchainKHR)(VkDevice device, VkSwapchainCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain);
typedef void (VKAPI_PTR *PFN_vkDestroySwapchainKHR)(VkDevice device, VkSwapchainKHR swapchain, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainImagesKHR)(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages);
typedef VkResult (VKAPI_PTR *PFN_vkAcquireNextImageKHR)(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex);
typedef VkResult (VKAPI_PTR *PFN_vkQueuePresentKHR)(VkQueue queue, VkPresentInfoKHR* pPresentInfo);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateSwapchainKHR(
    VkDevice                                    device,
    VkSwapchainCreateInfoKHR*             pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchain);

VKAPI_ATTR void VKAPI_CALL vkDestroySwapchainKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkGetSwapchainImagesKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint32_t*                                   pSwapchainImageCount,
    VkImage*                                    pSwapchainImages);

VKAPI_ATTR VkResult VKAPI_CALL vkAcquireNextImageKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint64_t                                    timeout,
    VkSemaphore                                 semaphore,
    VkFence                                     fence,
    uint32_t*                                   pImageIndex);

VKAPI_ATTR VkResult VKAPI_CALL vkQueuePresentKHR(
    VkQueue                                     queue,
    VkPresentInfoKHR*                     pPresentInfo);
#endif

#define VK_KHR_display 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayKHR)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayModeKHR)

#define VK_KHR_DISPLAY_SPEC_VERSION       21
#define VK_KHR_DISPLAY_EXTENSION_NAME     "VK_KHR_display"


typedef enum VkDisplayPlaneAlphaFlagBitsKHR {
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
    VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkDisplayPlaneAlphaFlagBitsKHR;
typedef VkFlags VkDisplayPlaneAlphaFlagsKHR;
typedef VkFlags VkDisplayModeCreateFlagsKHR;
typedef VkFlags VkDisplaySurfaceCreateFlagsKHR;

typedef struct VkDisplayPropertiesKHR {
    VkDisplayKHR                  display;
    char*                   displayName;
    VkExtent2D                    physicalDimensions;
    VkExtent2D                    physicalResolution;
    VkSurfaceTransformFlagsKHR    supportedTransforms;
    VkBool32                      planeReorderPossible;
    VkBool32                      persistentContent;
} VkDisplayPropertiesKHR;

typedef struct VkDisplayModeParametersKHR {
    VkExtent2D    visibleRegion;
    uint32_t      refreshRate;
} VkDisplayModeParametersKHR;

typedef struct VkDisplayModePropertiesKHR {
    VkDisplayModeKHR              displayMode;
    VkDisplayModeParametersKHR    parameters;
} VkDisplayModePropertiesKHR;

typedef struct VkDisplayModeCreateInfoKHR {
    VkStructureType                sType;
    void*                    pNext;
    VkDisplayModeCreateFlagsKHR    flags;
    VkDisplayModeParametersKHR     parameters;
} VkDisplayModeCreateInfoKHR;

typedef struct VkDisplayPlaneCapabilitiesKHR {
    VkDisplayPlaneAlphaFlagsKHR    supportedAlpha;
    VkOffset2D                     minSrcPosition;
    VkOffset2D                     maxSrcPosition;
    VkExtent2D                     minSrcExtent;
    VkExtent2D                     maxSrcExtent;
    VkOffset2D                     minDstPosition;
    VkOffset2D                     maxDstPosition;
    VkExtent2D                     minDstExtent;
    VkExtent2D                     maxDstExtent;
} VkDisplayPlaneCapabilitiesKHR;

typedef struct VkDisplayPlanePropertiesKHR {
    VkDisplayKHR    currentDisplay;
    uint32_t        currentStackIndex;
} VkDisplayPlanePropertiesKHR;

typedef struct VkDisplaySurfaceCreateInfoKHR {
    VkStructureType                   sType;
    void*                       pNext;
    VkDisplaySurfaceCreateFlagsKHR    flags;
    VkDisplayModeKHR                  displayMode;
    uint32_t                          planeIndex;
    uint32_t                          planeStackIndex;
    VkSurfaceTransformFlagBitsKHR     transform;
    float                             globalAlpha;
    VkDisplayPlaneAlphaFlagBitsKHR    alphaMode;
    VkExtent2D                        imageExtent;
} VkDisplaySurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneSupportedDisplaysKHR)(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayModePropertiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayModeKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, VkDisplayModeCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayPlaneSurfaceKHR)(VkInstance instance, VkDisplaySurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPropertiesKHR*                     pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPlanePropertiesKHR*                pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    planeIndex,
    uint32_t*                                   pDisplayCount,
    VkDisplayKHR*                               pDisplays);

VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    uint32_t*                                   pPropertyCount,
    VkDisplayModePropertiesKHR*                 pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDisplayModeKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    VkDisplayModeCreateInfoKHR*           pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDisplayModeKHR*                           pMode);

VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayModeKHR                            mode,
    uint32_t                                    planeIndex,
    VkDisplayPlaneCapabilitiesKHR*              pCapabilities);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDisplayPlaneSurfaceKHR(
    VkInstance                                  instance,
    VkDisplaySurfaceCreateInfoKHR*        pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
#endif

#define VK_KHR_display_swapchain 1
#define VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION 9
#define VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME "VK_KHR_display_swapchain"

typedef struct VkDisplayPresentInfoKHR {
    VkStructureType    sType;
    void*        pNext;
    VkRect2D           srcRect;
    VkRect2D           dstRect;
    VkBool32           persistent;
} VkDisplayPresentInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateSharedSwapchainsKHR)(VkDevice device, uint32_t swapchainCount, VkSwapchainCreateInfoKHR* pCreateInfos, VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateSharedSwapchainsKHR(
    VkDevice                                    device,
    uint32_t                                    swapchainCount,
    VkSwapchainCreateInfoKHR*             pCreateInfos,
    VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchains);
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
#define VK_KHR_xlib_surface 1
#include <X11/Xlib.h>

#define VK_KHR_XLIB_SURFACE_SPEC_VERSION  6
#define VK_KHR_XLIB_SURFACE_EXTENSION_NAME "VK_KHR_xlib_surface"

typedef VkFlags VkXlibSurfaceCreateFlagsKHR;

typedef struct VkXlibSurfaceCreateInfoKHR {
    VkStructureType                sType;
    void*                    pNext;
    VkXlibSurfaceCreateFlagsKHR    flags;
    Display*                       dpy;
    Window                         window;
} VkXlibSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateXlibSurfaceKHR)(VkInstance instance, VkXlibSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateXlibSurfaceKHR(
    VkInstance                                  instance,
    VkXlibSurfaceCreateInfoKHR*           pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    Display*                                    dpy,
    VisualID                                    visualID);
#endif
#endif /* VK_USE_PLATFORM_XLIB_KHR */

#ifdef VK_USE_PLATFORM_XCB_KHR
#define VK_KHR_xcb_surface 1
#include <xcb/xcb.h>

#define VK_KHR_XCB_SURFACE_SPEC_VERSION   6
#define VK_KHR_XCB_SURFACE_EXTENSION_NAME "VK_KHR_xcb_surface"

typedef VkFlags VkXcbSurfaceCreateFlagsKHR;

typedef struct VkXcbSurfaceCreateInfoKHR {
    VkStructureType               sType;
    void*                   pNext;
    VkXcbSurfaceCreateFlagsKHR    flags;
    xcb_connection_t*             connection;
    xcb_window_t                  window;
} VkXcbSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateXcbSurfaceKHR)(VkInstance instance, VkXcbSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateXcbSurfaceKHR(
    VkInstance                                  instance,
    VkXcbSurfaceCreateInfoKHR*            pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    xcb_connection_t*                           connection,
    xcb_visualid_t                              visual_id);
#endif
#endif /* VK_USE_PLATFORM_XCB_KHR */

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
#define VK_KHR_wayland_surface 1
#include <wayland-client.h>

#define VK_KHR_WAYLAND_SURFACE_SPEC_VERSION 5
#define VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME "VK_KHR_wayland_surface"

typedef VkFlags VkWaylandSurfaceCreateFlagsKHR;

typedef struct VkWaylandSurfaceCreateInfoKHR {
    VkStructureType                   sType;
    void*                       pNext;
    VkWaylandSurfaceCreateFlagsKHR    flags;
    struct wl_display*                display;
    struct wl_surface*                surface;
} VkWaylandSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateWaylandSurfaceKHR)(VkInstance instance, VkWaylandSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display* display);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateWaylandSurfaceKHR(
    VkInstance                                  instance,
    VkWaylandSurfaceCreateInfoKHR*        pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    struct wl_display*                          display);
#endif
#endif /* VK_USE_PLATFORM_WAYLAND_KHR */

#ifdef VK_USE_PLATFORM_MIR_KHR
#define VK_KHR_mir_surface 1
#include <mir_toolkit/client_types.h>

#define VK_KHR_MIR_SURFACE_SPEC_VERSION   4
#define VK_KHR_MIR_SURFACE_EXTENSION_NAME "VK_KHR_mir_surface"

typedef VkFlags VkMirSurfaceCreateFlagsKHR;

typedef struct VkMirSurfaceCreateInfoKHR {
    VkStructureType               sType;
    void*                   pNext;
    VkMirSurfaceCreateFlagsKHR    flags;
    MirConnection*                connection;
    MirSurface*                   mirSurface;
} VkMirSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateMirSurfaceKHR)(VkInstance instance, VkMirSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceMirPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, MirConnection* connection);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateMirSurfaceKHR(
    VkInstance                                  instance,
    VkMirSurfaceCreateInfoKHR*            pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceMirPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    MirConnection*                              connection);
#endif
#endif /* VK_USE_PLATFORM_MIR_KHR */

#ifdef VK_USE_PLATFORM_ANDROID_KHR
#define VK_KHR_android_surface 1
#include <android/native_window.h>

#define VK_KHR_ANDROID_SURFACE_SPEC_VERSION 6
#define VK_KHR_ANDROID_SURFACE_EXTENSION_NAME "VK_KHR_android_surface"

typedef VkFlags VkAndroidSurfaceCreateFlagsKHR;

typedef struct VkAndroidSurfaceCreateInfoKHR {
    VkStructureType                   sType;
    void*                       pNext;
    VkAndroidSurfaceCreateFlagsKHR    flags;
    ANativeWindow*                    window;
} VkAndroidSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateAndroidSurfaceKHR)(VkInstance instance, VkAndroidSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateAndroidSurfaceKHR(
    VkInstance                                  instance,
    VkAndroidSurfaceCreateInfoKHR*        pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
#endif
#endif /* VK_USE_PLATFORM_ANDROID_KHR */

#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_KHR_win32_surface 1
#include <windows.h>

#define VK_KHR_WIN32_SURFACE_SPEC_VERSION 5
#define VK_KHR_WIN32_SURFACE_EXTENSION_NAME "VK_KHR_win32_surface"

typedef VkFlags VkWin32SurfaceCreateFlagsKHR;

typedef struct VkWin32SurfaceCreateInfoKHR {
    VkStructureType                 sType;
    void*                     pNext;
    VkWin32SurfaceCreateFlagsKHR    flags;
    HINSTANCE                       hinstance;
    HWND                            hwnd;
} VkWin32SurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateWin32SurfaceKHR)(VkInstance instance, VkWin32SurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateWin32SurfaceKHR(
    VkInstance                                  instance,
    VkWin32SurfaceCreateInfoKHR*          pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex);
#endif
#endif /* VK_USE_PLATFORM_WIN32_KHR */

#define VK_KHR_sampler_mirror_clamp_to_edge 1
#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION 1
#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME "VK_KHR_sampler_mirror_clamp_to_edge"


#define VK_EXT_debug_report 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugReportCallbackEXT)

#define VK_EXT_DEBUG_REPORT_SPEC_VERSION  4
#define VK_EXT_DEBUG_REPORT_EXTENSION_NAME "VK_EXT_debug_report"
#define VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT


typedef enum VkDebugReportObjectTypeEXT {
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT = (VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT - VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT + 1),
    VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportObjectTypeEXT;

typedef enum VkDebugReportErrorEXT {
    VK_DEBUG_REPORT_ERROR_NONE_EXT = 0,
    VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = 1,
    VK_DEBUG_REPORT_ERROR_BEGIN_RANGE_EXT = VK_DEBUG_REPORT_ERROR_NONE_EXT,
    VK_DEBUG_REPORT_ERROR_END_RANGE_EXT = VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT,
    VK_DEBUG_REPORT_ERROR_RANGE_SIZE_EXT = (VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT - VK_DEBUG_REPORT_ERROR_NONE_EXT + 1),
    VK_DEBUG_REPORT_ERROR_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportErrorEXT;


typedef enum VkDebugReportFlagBitsEXT {
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001,
    VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
    VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010,
    VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportFlagBitsEXT;
typedef VkFlags VkDebugReportFlagsEXT;

typedef VkBool32 (VKAPI_PTR *PFN_vkDebugReportCallbackEXT)(
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    char*                                 pLayerPrefix,
    char*                                 pMessage,
    void*                                       pUserData);


typedef struct VkDebugReportLayerFlagsEXT {
    VkStructureType    sType;
    void*        pNext;
    uint64_t           enabledValidationFlags;
} VkDebugReportLayerFlagsEXT;

typedef struct VkDebugReportCallbackCreateInfoEXT {
    VkStructureType                 sType;
    void*                     pNext;
    VkDebugReportFlagsEXT           flags;
    PFN_vkDebugReportCallbackEXT    pfnCallback;
    void*                           pUserData;
} VkDebugReportCallbackCreateInfoEXT;


typedef VkResult (VKAPI_PTR *PFN_vkCreateDebugReportCallbackEXT)(VkInstance instance, VkDebugReportCallbackCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback);
typedef void (VKAPI_PTR *PFN_vkDestroyDebugReportCallbackEXT)(VkInstance instance, VkDebugReportCallbackEXT callback, VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkDebugReportMessageEXT)(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, char* pLayerPrefix, char* pMessage);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateDebugReportCallbackEXT(
    VkInstance                                  instance,
    VkDebugReportCallbackCreateInfoEXT*   pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDebugReportCallbackEXT*                   pCallback);

VKAPI_ATTR void VKAPI_CALL vkDestroyDebugReportCallbackEXT(
    VkInstance                                  instance,
    VkDebugReportCallbackEXT                    callback,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR void VKAPI_CALL vkDebugReportMessageEXT(
    VkInstance                                  instance,
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    char*                                 pLayerPrefix,
    char*                                 pMessage);
#endif

#define VK_NV_glsl_shader 1
#define VK_NV_GLSL_SHADER_SPEC_VERSION    1
#define VK_NV_GLSL_SHADER_EXTENSION_NAME  "VK_NV_glsl_shader"


#define VK_IMG_filter_cubic 1
#define VK_IMG_FILTER_CUBIC_SPEC_VERSION  1
#define VK_IMG_FILTER_CUBIC_EXTENSION_NAME "VK_IMG_filter_cubic"


#define VK_AMD_rasterization_order 1
#define VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION 1
#define VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME "VK_AMD_rasterization_order"


typedef enum VkRasterizationOrderAMD {
    VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
    VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
    VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD = VK_RASTERIZATION_ORDER_STRICT_AMD,
    VK_RASTERIZATION_ORDER_END_RANGE_AMD = VK_RASTERIZATION_ORDER_RELAXED_AMD,
    VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD = (VK_RASTERIZATION_ORDER_RELAXED_AMD - VK_RASTERIZATION_ORDER_STRICT_AMD + 1),
    VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = 0x7FFFFFFF
} VkRasterizationOrderAMD;

typedef struct VkPipelineRasterizationStateRasterizationOrderAMD {
    VkStructureType            sType;
    void*                pNext;
    VkRasterizationOrderAMD    rasterizationOrder;
} VkPipelineRasterizationStateRasterizationOrderAMD;



#define VK_AMD_shader_trinary_minmax 1
#define VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION 1
#define VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME "VK_AMD_shader_trinary_minmax"


#define VK_AMD_shader_explicit_vertex_parameter 1
#define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION 1
#define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME "VK_AMD_shader_explicit_vertex_parameter"


#define VK_EXT_debug_marker 1
#define VK_EXT_DEBUG_MARKER_SPEC_VERSION  3
#define VK_EXT_DEBUG_MARKER_EXTENSION_NAME "VK_EXT_debug_marker"

typedef struct VkDebugMarkerObjectNameInfoEXT {
    VkStructureType               sType;
    void*                   pNext;
    VkDebugReportObjectTypeEXT    objectType;
    uint64_t                      object;
    char*                   pObjectName;
} VkDebugMarkerObjectNameInfoEXT;

typedef struct VkDebugMarkerObjectTagInfoEXT {
    VkStructureType               sType;
    void*                   pNext;
    VkDebugReportObjectTypeEXT    objectType;
    uint64_t                      object;
    uint64_t                      tagName;
    size_t                        tagSize;
    void*                   pTag;
} VkDebugMarkerObjectTagInfoEXT;

typedef struct VkDebugMarkerMarkerInfoEXT {
    VkStructureType    sType;
    void*        pNext;
    char*        pMarkerName;
    float              color[4];
} VkDebugMarkerMarkerInfoEXT;


typedef VkResult (VKAPI_PTR *PFN_vkDebugMarkerSetObjectTagEXT)(VkDevice device, VkDebugMarkerObjectTagInfoEXT* pTagInfo);
typedef VkResult (VKAPI_PTR *PFN_vkDebugMarkerSetObjectNameEXT)(VkDevice device, VkDebugMarkerObjectNameInfoEXT* pNameInfo);
typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerBeginEXT)(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT* pMarkerInfo);
typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerEndEXT)(VkCommandBuffer commandBuffer);
typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerInsertEXT)(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT* pMarkerInfo);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkDebugMarkerSetObjectTagEXT(
    VkDevice                                    device,
    VkDebugMarkerObjectTagInfoEXT*              pTagInfo);

VKAPI_ATTR VkResult VKAPI_CALL vkDebugMarkerSetObjectNameEXT(
    VkDevice                                    device,
    VkDebugMarkerObjectNameInfoEXT*             pNameInfo);

VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerBeginEXT(
    VkCommandBuffer                             commandBuffer,
    VkDebugMarkerMarkerInfoEXT*                 pMarkerInfo);

VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerEndEXT(
    VkCommandBuffer                             commandBuffer);

VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerInsertEXT(
    VkCommandBuffer                             commandBuffer,
    VkDebugMarkerMarkerInfoEXT*                 pMarkerInfo);
#endif

#define VK_AMD_gcn_shader 1
#define VK_AMD_GCN_SHADER_SPEC_VERSION    1
#define VK_AMD_GCN_SHADER_EXTENSION_NAME  "VK_AMD_gcn_shader"


#define VK_NV_dedicated_allocation 1
#define VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION 1
#define VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_NV_dedicated_allocation"

typedef struct VkDedicatedAllocationImageCreateInfoNV {
    VkStructureType    sType;
    void*        pNext;
    VkBool32           dedicatedAllocation;
} VkDedicatedAllocationImageCreateInfoNV;

typedef struct VkDedicatedAllocationBufferCreateInfoNV {
    VkStructureType    sType;
    void*        pNext;
    VkBool32           dedicatedAllocation;
} VkDedicatedAllocationBufferCreateInfoNV;

typedef struct VkDedicatedAllocationMemoryAllocateInfoNV {
    VkStructureType    sType;
    void*        pNext;
    VkImage            image;
    VkBuffer           buffer;
} VkDedicatedAllocationMemoryAllocateInfoNV;



#define VK_AMD_draw_indirect_count 1
#define VK_AMD_EXTENSION_DRAW_INDIRECT_COUNT_SPEC_VERSION 1
#define VK_AMD_EXTENSION_DRAW_INDIRECT_COUNT_EXTENSION_NAME "VK_AMD_draw_indirect_count"

typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirectCountAMD(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride);

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexedIndirectCountAMD(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride);
#endif

#define VK_IMG_format_pvrtc 1
#define VK_IMG_FORMAT_PVRTC_SPEC_VERSION  1
#define VK_IMG_FORMAT_PVRTC_EXTENSION_NAME "VK_IMG_format_pvrtc"


#define VK_NV_external_memory_capabilities 1
#define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_NV_external_memory_capabilities"


typedef enum VkExternalMemoryHandleTypeFlagBitsNV {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x00000001,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x00000004,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x00000008,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
} VkExternalMemoryHandleTypeFlagBitsNV;

typedef enum VkExternalMemoryFeatureFlagBitsNV {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x00000001,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x00000002,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x00000004,
    VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
} VkExternalMemoryFeatureFlagBitsNV;

typedef VkFlags VkExternalMemoryHandleTypeFlagsNV;
typedef VkFlags VkExternalMemoryFeatureFlagsNV;

typedef struct VkExternalImageFormatPropertiesNV {
    VkImageFormatProperties              imageFormatProperties;
    VkExternalMemoryFeatureFlagsNV       externalMemoryFeatures;
    VkExternalMemoryHandleTypeFlagsNV    exportFromImportedHandleTypes;
    VkExternalMemoryHandleTypeFlagsNV    compatibleHandleTypes;
} VkExternalImageFormatPropertiesNV;


typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkExternalMemoryHandleTypeFlagsNV           externalHandleType,
    VkExternalImageFormatPropertiesNV*          pExternalImageFormatProperties);
#endif

#define VK_NV_external_memory 1
#define VK_NV_EXTERNAL_MEMORY_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME "VK_NV_external_memory"

typedef struct VkExternalMemoryImageCreateInfoNV {
    VkStructureType                      sType;
    void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleTypes;
} VkExternalMemoryImageCreateInfoNV;

typedef struct VkExportMemoryAllocateInfoNV {
    VkStructureType                      sType;
    void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleTypes;
} VkExportMemoryAllocateInfoNV;



#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_NV_external_memory_win32 1
#define VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_NV_external_memory_win32"

typedef struct VkImportMemoryWin32HandleInfoNV {
    VkStructureType                      sType;
    void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleType;
    HANDLE                               handle;
} VkImportMemoryWin32HandleInfoNV;

typedef struct VkExportMemoryWin32HandleInfoNV {
    VkStructureType               sType;
    void*                   pNext;
    SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
} VkExportMemoryWin32HandleInfoNV;


typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleNV)(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryWin32HandleNV(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    HANDLE*                                     pHandle);
#endif
#endif /* VK_USE_PLATFORM_WIN32_KHR */

#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_NV_win32_keyed_mutex 1
#define VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION 1
#define VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME "VK_NV_win32_keyed_mutex"

typedef struct VkWin32KeyedMutexAcquireReleaseInfoNV {
    VkStructureType          sType;
    void*              pNext;
    uint32_t                 acquireCount;
    VkDeviceMemory*    pAcquireSyncs;
    uint64_t*          pAcquireKeys;
    uint32_t*          pAcquireTimeoutMilliseconds;
    uint32_t                 releaseCount;
    VkDeviceMemory*    pReleaseSyncs;
    uint64_t*          pReleaseKeys;
} VkWin32KeyedMutexAcquireReleaseInfoNV;


#endif /* VK_USE_PLATFORM_WIN32_KHR */

#ifdef __cplusplus
}
#endif

#endif
// END VULKAN H

static PFN_vkDestroyPipelineCache vkDestroyPipelineCache;
static PFN_vkCreatePipelineLayout vkCreatePipelineLayout;
static PFN_vkGetDeviceQueue vkGetDeviceQueue;
static PFN_vkCreateFramebuffer vkCreateFramebuffer;
static PFN_vkCmdSetScissor vkCmdSetScissor;
static PFN_vkCmdClearDepthStencilImage vkCmdClearDepthStencilImage;
static PFN_vkBeginCommandBuffer vkBeginCommandBuffer;
static PFN_vkCmdEndQuery vkCmdEndQuery;
static PFN_vkQueueBindSparse vkQueueBindSparse;
static PFN_vkGetDeviceProcAddr vkGetDeviceProcAddr;
static PFN_vkGetPhysicalDeviceImageFormatProperties vkGetPhysicalDeviceImageFormatProperties;
static PFN_vkCreateShaderModule vkCreateShaderModule;
static PFN_vkDestroyPipeline vkDestroyPipeline;
static PFN_vkCreateDescriptorSetLayout vkCreateDescriptorSetLayout;
static PFN_vkDestroyDescriptorSetLayout vkDestroyDescriptorSetLayout;
static PFN_vkCmdSetEvent vkCmdSetEvent;
static PFN_vkGetFenceStatus vkGetFenceStatus;
static PFN_vkCmdSetStencilCompareMask vkCmdSetStencilCompareMask;
static PFN_vkCmdCopyBuffer vkCmdCopyBuffer;
static PFN_vkCmdSetViewport vkCmdSetViewport;
static PFN_vkResetCommandBuffer vkResetCommandBuffer;
static PFN_vkCmdWriteTimestamp vkCmdWriteTimestamp;
static PFN_vkWaitForFences vkWaitForFences;
static PFN_vkCreateDevice vkCreateDevice;
static PFN_vkDestroyDescriptorPool vkDestroyDescriptorPool;
static PFN_vkDestroyPipelineLayout vkDestroyPipelineLayout;
static PFN_vkAllocateDescriptorSets vkAllocateDescriptorSets;
static PFN_vkCmdResetQueryPool vkCmdResetQueryPool;
static PFN_vkCreateRenderPass vkCreateRenderPass;
static PFN_vkCreateQueryPool vkCreateQueryPool;
static PFN_vkCmdDrawIndexedIndirect vkCmdDrawIndexedIndirect;
static PFN_vkDestroyRenderPass vkDestroyRenderPass;
static PFN_vkCmdClearAttachments vkCmdClearAttachments;
static PFN_vkCmdSetStencilWriteMask vkCmdSetStencilWriteMask;
static PFN_vkCmdEndRenderPass vkCmdEndRenderPass;
static PFN_vkCreateInstance vkCreateInstance;
static PFN_vkCmdCopyImageToBuffer vkCmdCopyImageToBuffer;
static PFN_vkDestroyDevice vkDestroyDevice;
static PFN_vkSetEvent vkSetEvent;
static PFN_vkCmdClearColorImage vkCmdClearColorImage;
static PFN_vkResetFences vkResetFences;
static PFN_vkResetDescriptorPool vkResetDescriptorPool;
static PFN_vkAllocateMemory vkAllocateMemory;
static PFN_vkCmdBindIndexBuffer vkCmdBindIndexBuffer;
static PFN_vkDestroyCommandPool vkDestroyCommandPool;
static PFN_vkCmdResetEvent vkCmdResetEvent;
static PFN_vkQueueWaitIdle vkQueueWaitIdle;
static PFN_vkCmdBindVertexBuffers vkCmdBindVertexBuffers;
static PFN_vkFreeMemory vkFreeMemory;
static PFN_vkGetQueryPoolResults vkGetQueryPoolResults;
static PFN_vkGetImageSubresourceLayout vkGetImageSubresourceLayout;
static PFN_vkFreeDescriptorSets vkFreeDescriptorSets;
static PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr;
static PFN_vkCmdDispatch vkCmdDispatch;
static PFN_vkCreateSemaphore vkCreateSemaphore;
static PFN_vkCmdResolveImage vkCmdResolveImage;
static PFN_vkDestroyEvent vkDestroyEvent;
static PFN_vkCmdCopyBufferToImage vkCmdCopyBufferToImage;
static PFN_vkDestroyFence vkDestroyFence;
static PFN_vkCreateBuffer vkCreateBuffer;
static PFN_vkCreateGraphicsPipelines vkCreateGraphicsPipelines;
static PFN_vkCmdBindPipeline vkCmdBindPipeline;
static PFN_vkCmdCopyQueryPoolResults vkCmdCopyQueryPoolResults;
static PFN_vkCmdSetDepthBounds vkCmdSetDepthBounds;
static PFN_vkCreateComputePipelines vkCreateComputePipelines;
static PFN_vkCmdPushConstants vkCmdPushConstants;
static PFN_vkCmdExecuteCommands vkCmdExecuteCommands;
static PFN_vkDestroySemaphore vkDestroySemaphore;
static PFN_vkCmdBeginQuery vkCmdBeginQuery;
static PFN_vkResetCommandPool vkResetCommandPool;
static PFN_vkResetEvent vkResetEvent;
static PFN_vkCreatePipelineCache vkCreatePipelineCache;
static PFN_vkCmdDrawIndexed vkCmdDrawIndexed;
static PFN_vkGetBufferMemoryRequirements vkGetBufferMemoryRequirements;
static PFN_vkCreateFence vkCreateFence;
static PFN_vkDestroyImage vkDestroyImage;
static PFN_vkGetPhysicalDeviceSparseImageFormatProperties vkGetPhysicalDeviceSparseImageFormatProperties;
static PFN_vkGetDeviceMemoryCommitment vkGetDeviceMemoryCommitment;
static PFN_vkCmdPipelineBarrier vkCmdPipelineBarrier;
static PFN_vkEnumerateDeviceExtensionProperties vkEnumerateDeviceExtensionProperties;
static PFN_vkDestroyQueryPool vkDestroyQueryPool;
static PFN_vkCmdFillBuffer vkCmdFillBuffer;
static PFN_vkQueueSubmit vkQueueSubmit;
static PFN_vkFlushMappedMemoryRanges vkFlushMappedMemoryRanges;
static PFN_vkGetPhysicalDeviceFormatProperties vkGetPhysicalDeviceFormatProperties;
static PFN_vkGetPipelineCacheData vkGetPipelineCacheData;
static PFN_vkCmdNextSubpass vkCmdNextSubpass;
static PFN_vkEnumerateInstanceLayerProperties vkEnumerateInstanceLayerProperties;
static PFN_vkUpdateDescriptorSets vkUpdateDescriptorSets;
static PFN_vkCmdBeginRenderPass vkCmdBeginRenderPass;
static PFN_vkGetPhysicalDeviceFeatures vkGetPhysicalDeviceFeatures;
static PFN_vkCmdBlitImage vkCmdBlitImage;
static PFN_vkInvalidateMappedMemoryRanges vkInvalidateMappedMemoryRanges;
static PFN_vkBindBufferMemory vkBindBufferMemory;
static PFN_vkEndCommandBuffer vkEndCommandBuffer;
static PFN_vkCmdCopyImage vkCmdCopyImage;
static PFN_vkCreateBufferView vkCreateBufferView;
static PFN_vkGetPhysicalDeviceProperties vkGetPhysicalDeviceProperties;
static PFN_vkCmdSetStencilReference vkCmdSetStencilReference;
static PFN_vkCmdDispatchIndirect vkCmdDispatchIndirect;
static PFN_vkCreateImage vkCreateImage;
static PFN_vkBindImageMemory vkBindImageMemory;
static PFN_vkCmdDrawIndirect vkCmdDrawIndirect;
static PFN_vkGetImageMemoryRequirements vkGetImageMemoryRequirements;
static PFN_vkGetRenderAreaGranularity vkGetRenderAreaGranularity;
static PFN_vkCreateImageView vkCreateImageView;
static PFN_vkCreateEvent vkCreateEvent;
static PFN_vkCmdBindDescriptorSets vkCmdBindDescriptorSets;
static PFN_vkEnumeratePhysicalDevices vkEnumeratePhysicalDevices;
static PFN_vkMapMemory vkMapMemory;
static PFN_vkDestroyInstance vkDestroyInstance;
static PFN_vkCmdUpdateBuffer vkCmdUpdateBuffer;
static PFN_vkGetPhysicalDeviceMemoryProperties vkGetPhysicalDeviceMemoryProperties;
static PFN_vkUnmapMemory vkUnmapMemory;
static PFN_vkCreateCommandPool vkCreateCommandPool;
static PFN_vkDestroyFramebuffer vkDestroyFramebuffer;
static PFN_vkDestroyImageView vkDestroyImageView;
static PFN_vkFreeCommandBuffers vkFreeCommandBuffers;
static PFN_vkEnumerateInstanceExtensionProperties vkEnumerateInstanceExtensionProperties;
static PFN_vkCreateSampler vkCreateSampler;
static PFN_vkDestroyBuffer vkDestroyBuffer;
static PFN_vkEnumerateDeviceLayerProperties vkEnumerateDeviceLayerProperties;
static PFN_vkCmdDraw vkCmdDraw;
static PFN_vkAllocateCommandBuffers vkAllocateCommandBuffers;
static PFN_vkCmdWaitEvents vkCmdWaitEvents;
static PFN_vkCmdSetDepthBias vkCmdSetDepthBias;
static PFN_vkCreateDescriptorPool vkCreateDescriptorPool;
static PFN_vkDeviceWaitIdle vkDeviceWaitIdle;
static PFN_vkDestroySampler vkDestroySampler;
static PFN_vkDestroyBufferView vkDestroyBufferView;
static PFN_vkGetPhysicalDeviceQueueFamilyProperties vkGetPhysicalDeviceQueueFamilyProperties;
static PFN_vkCmdSetBlendConstants vkCmdSetBlendConstants;
static PFN_vkMergePipelineCaches vkMergePipelineCaches;
static PFN_vkGetImageSparseMemoryRequirements vkGetImageSparseMemoryRequirements;
static PFN_vkCmdSetLineWidth vkCmdSetLineWidth;
static PFN_vkDestroyShaderModule vkDestroyShaderModule;
static PFN_vkGetEventStatus vkGetEventStatus;

        static PyObject * load_sdk(PyObject *self, PyObject *args) {
            void* vk_sdk = LOAD_SDK();
            if (vk_sdk == NULL) {
                PyErr_SetString(PyExc_ImportError,
                                "Can't find vulkan sdk");
                return NULL;
            }

            
                         vkDestroyPipelineCache = (PFN_vkDestroyPipelineCache)dlsym(vk_sdk, "vkDestroyPipelineCache");
                         if( vkDestroyPipelineCache == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyPipelineCache in sdk");
                             return NULL;
                         }
                         

                         vkCreatePipelineLayout = (PFN_vkCreatePipelineLayout)dlsym(vk_sdk, "vkCreatePipelineLayout");
                         if( vkCreatePipelineLayout == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreatePipelineLayout in sdk");
                             return NULL;
                         }
                         

                         vkGetDeviceQueue = (PFN_vkGetDeviceQueue)dlsym(vk_sdk, "vkGetDeviceQueue");
                         if( vkGetDeviceQueue == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetDeviceQueue in sdk");
                             return NULL;
                         }
                         

                         vkCreateFramebuffer = (PFN_vkCreateFramebuffer)dlsym(vk_sdk, "vkCreateFramebuffer");
                         if( vkCreateFramebuffer == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateFramebuffer in sdk");
                             return NULL;
                         }
                         

                         vkCmdSetScissor = (PFN_vkCmdSetScissor)dlsym(vk_sdk, "vkCmdSetScissor");
                         if( vkCmdSetScissor == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdSetScissor in sdk");
                             return NULL;
                         }
                         

                         vkCmdClearDepthStencilImage = (PFN_vkCmdClearDepthStencilImage)dlsym(vk_sdk, "vkCmdClearDepthStencilImage");
                         if( vkCmdClearDepthStencilImage == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdClearDepthStencilImage in sdk");
                             return NULL;
                         }
                         

                         vkBeginCommandBuffer = (PFN_vkBeginCommandBuffer)dlsym(vk_sdk, "vkBeginCommandBuffer");
                         if( vkBeginCommandBuffer == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkBeginCommandBuffer in sdk");
                             return NULL;
                         }
                         

                         vkCmdEndQuery = (PFN_vkCmdEndQuery)dlsym(vk_sdk, "vkCmdEndQuery");
                         if( vkCmdEndQuery == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdEndQuery in sdk");
                             return NULL;
                         }
                         

                         vkQueueBindSparse = (PFN_vkQueueBindSparse)dlsym(vk_sdk, "vkQueueBindSparse");
                         if( vkQueueBindSparse == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkQueueBindSparse in sdk");
                             return NULL;
                         }
                         

                         vkGetDeviceProcAddr = (PFN_vkGetDeviceProcAddr)dlsym(vk_sdk, "vkGetDeviceProcAddr");
                         if( vkGetDeviceProcAddr == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetDeviceProcAddr in sdk");
                             return NULL;
                         }
                         

                         vkGetPhysicalDeviceImageFormatProperties = (PFN_vkGetPhysicalDeviceImageFormatProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceImageFormatProperties");
                         if( vkGetPhysicalDeviceImageFormatProperties == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetPhysicalDeviceImageFormatProperties in sdk");
                             return NULL;
                         }
                         

                         vkCreateShaderModule = (PFN_vkCreateShaderModule)dlsym(vk_sdk, "vkCreateShaderModule");
                         if( vkCreateShaderModule == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateShaderModule in sdk");
                             return NULL;
                         }
                         

                         vkDestroyPipeline = (PFN_vkDestroyPipeline)dlsym(vk_sdk, "vkDestroyPipeline");
                         if( vkDestroyPipeline == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyPipeline in sdk");
                             return NULL;
                         }
                         

                         vkCreateDescriptorSetLayout = (PFN_vkCreateDescriptorSetLayout)dlsym(vk_sdk, "vkCreateDescriptorSetLayout");
                         if( vkCreateDescriptorSetLayout == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateDescriptorSetLayout in sdk");
                             return NULL;
                         }
                         

                         vkDestroyDescriptorSetLayout = (PFN_vkDestroyDescriptorSetLayout)dlsym(vk_sdk, "vkDestroyDescriptorSetLayout");
                         if( vkDestroyDescriptorSetLayout == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyDescriptorSetLayout in sdk");
                             return NULL;
                         }
                         

                         vkCmdSetEvent = (PFN_vkCmdSetEvent)dlsym(vk_sdk, "vkCmdSetEvent");
                         if( vkCmdSetEvent == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdSetEvent in sdk");
                             return NULL;
                         }
                         

                         vkGetFenceStatus = (PFN_vkGetFenceStatus)dlsym(vk_sdk, "vkGetFenceStatus");
                         if( vkGetFenceStatus == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetFenceStatus in sdk");
                             return NULL;
                         }
                         

                         vkCmdSetStencilCompareMask = (PFN_vkCmdSetStencilCompareMask)dlsym(vk_sdk, "vkCmdSetStencilCompareMask");
                         if( vkCmdSetStencilCompareMask == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdSetStencilCompareMask in sdk");
                             return NULL;
                         }
                         

                         vkCmdCopyBuffer = (PFN_vkCmdCopyBuffer)dlsym(vk_sdk, "vkCmdCopyBuffer");
                         if( vkCmdCopyBuffer == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdCopyBuffer in sdk");
                             return NULL;
                         }
                         

                         vkCmdSetViewport = (PFN_vkCmdSetViewport)dlsym(vk_sdk, "vkCmdSetViewport");
                         if( vkCmdSetViewport == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdSetViewport in sdk");
                             return NULL;
                         }
                         

                         vkResetCommandBuffer = (PFN_vkResetCommandBuffer)dlsym(vk_sdk, "vkResetCommandBuffer");
                         if( vkResetCommandBuffer == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkResetCommandBuffer in sdk");
                             return NULL;
                         }
                         

                         vkCmdWriteTimestamp = (PFN_vkCmdWriteTimestamp)dlsym(vk_sdk, "vkCmdWriteTimestamp");
                         if( vkCmdWriteTimestamp == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdWriteTimestamp in sdk");
                             return NULL;
                         }
                         

                         vkWaitForFences = (PFN_vkWaitForFences)dlsym(vk_sdk, "vkWaitForFences");
                         if( vkWaitForFences == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkWaitForFences in sdk");
                             return NULL;
                         }
                         

                         vkCreateDevice = (PFN_vkCreateDevice)dlsym(vk_sdk, "vkCreateDevice");
                         if( vkCreateDevice == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateDevice in sdk");
                             return NULL;
                         }
                         

                         vkDestroyDescriptorPool = (PFN_vkDestroyDescriptorPool)dlsym(vk_sdk, "vkDestroyDescriptorPool");
                         if( vkDestroyDescriptorPool == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyDescriptorPool in sdk");
                             return NULL;
                         }
                         

                         vkDestroyPipelineLayout = (PFN_vkDestroyPipelineLayout)dlsym(vk_sdk, "vkDestroyPipelineLayout");
                         if( vkDestroyPipelineLayout == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyPipelineLayout in sdk");
                             return NULL;
                         }
                         

                         vkAllocateDescriptorSets = (PFN_vkAllocateDescriptorSets)dlsym(vk_sdk, "vkAllocateDescriptorSets");
                         if( vkAllocateDescriptorSets == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkAllocateDescriptorSets in sdk");
                             return NULL;
                         }
                         

                         vkCmdResetQueryPool = (PFN_vkCmdResetQueryPool)dlsym(vk_sdk, "vkCmdResetQueryPool");
                         if( vkCmdResetQueryPool == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdResetQueryPool in sdk");
                             return NULL;
                         }
                         

                         vkCreateRenderPass = (PFN_vkCreateRenderPass)dlsym(vk_sdk, "vkCreateRenderPass");
                         if( vkCreateRenderPass == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateRenderPass in sdk");
                             return NULL;
                         }
                         

                         vkCreateQueryPool = (PFN_vkCreateQueryPool)dlsym(vk_sdk, "vkCreateQueryPool");
                         if( vkCreateQueryPool == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateQueryPool in sdk");
                             return NULL;
                         }
                         

                         vkCmdDrawIndexedIndirect = (PFN_vkCmdDrawIndexedIndirect)dlsym(vk_sdk, "vkCmdDrawIndexedIndirect");
                         if( vkCmdDrawIndexedIndirect == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdDrawIndexedIndirect in sdk");
                             return NULL;
                         }
                         

                         vkDestroyRenderPass = (PFN_vkDestroyRenderPass)dlsym(vk_sdk, "vkDestroyRenderPass");
                         if( vkDestroyRenderPass == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyRenderPass in sdk");
                             return NULL;
                         }
                         

                         vkCmdClearAttachments = (PFN_vkCmdClearAttachments)dlsym(vk_sdk, "vkCmdClearAttachments");
                         if( vkCmdClearAttachments == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdClearAttachments in sdk");
                             return NULL;
                         }
                         

                         vkCmdSetStencilWriteMask = (PFN_vkCmdSetStencilWriteMask)dlsym(vk_sdk, "vkCmdSetStencilWriteMask");
                         if( vkCmdSetStencilWriteMask == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdSetStencilWriteMask in sdk");
                             return NULL;
                         }
                         

                         vkCmdEndRenderPass = (PFN_vkCmdEndRenderPass)dlsym(vk_sdk, "vkCmdEndRenderPass");
                         if( vkCmdEndRenderPass == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdEndRenderPass in sdk");
                             return NULL;
                         }
                         

                         vkCreateInstance = (PFN_vkCreateInstance)dlsym(vk_sdk, "vkCreateInstance");
                         if( vkCreateInstance == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateInstance in sdk");
                             return NULL;
                         }
                         

                         vkCmdCopyImageToBuffer = (PFN_vkCmdCopyImageToBuffer)dlsym(vk_sdk, "vkCmdCopyImageToBuffer");
                         if( vkCmdCopyImageToBuffer == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdCopyImageToBuffer in sdk");
                             return NULL;
                         }
                         

                         vkDestroyDevice = (PFN_vkDestroyDevice)dlsym(vk_sdk, "vkDestroyDevice");
                         if( vkDestroyDevice == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyDevice in sdk");
                             return NULL;
                         }
                         

                         vkSetEvent = (PFN_vkSetEvent)dlsym(vk_sdk, "vkSetEvent");
                         if( vkSetEvent == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkSetEvent in sdk");
                             return NULL;
                         }
                         

                         vkCmdClearColorImage = (PFN_vkCmdClearColorImage)dlsym(vk_sdk, "vkCmdClearColorImage");
                         if( vkCmdClearColorImage == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdClearColorImage in sdk");
                             return NULL;
                         }
                         

                         vkResetFences = (PFN_vkResetFences)dlsym(vk_sdk, "vkResetFences");
                         if( vkResetFences == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkResetFences in sdk");
                             return NULL;
                         }
                         

                         vkResetDescriptorPool = (PFN_vkResetDescriptorPool)dlsym(vk_sdk, "vkResetDescriptorPool");
                         if( vkResetDescriptorPool == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkResetDescriptorPool in sdk");
                             return NULL;
                         }
                         

                         vkAllocateMemory = (PFN_vkAllocateMemory)dlsym(vk_sdk, "vkAllocateMemory");
                         if( vkAllocateMemory == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkAllocateMemory in sdk");
                             return NULL;
                         }
                         

                         vkCmdBindIndexBuffer = (PFN_vkCmdBindIndexBuffer)dlsym(vk_sdk, "vkCmdBindIndexBuffer");
                         if( vkCmdBindIndexBuffer == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdBindIndexBuffer in sdk");
                             return NULL;
                         }
                         

                         vkDestroyCommandPool = (PFN_vkDestroyCommandPool)dlsym(vk_sdk, "vkDestroyCommandPool");
                         if( vkDestroyCommandPool == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyCommandPool in sdk");
                             return NULL;
                         }
                         

                         vkCmdResetEvent = (PFN_vkCmdResetEvent)dlsym(vk_sdk, "vkCmdResetEvent");
                         if( vkCmdResetEvent == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdResetEvent in sdk");
                             return NULL;
                         }
                         

                         vkQueueWaitIdle = (PFN_vkQueueWaitIdle)dlsym(vk_sdk, "vkQueueWaitIdle");
                         if( vkQueueWaitIdle == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkQueueWaitIdle in sdk");
                             return NULL;
                         }
                         

                         vkCmdBindVertexBuffers = (PFN_vkCmdBindVertexBuffers)dlsym(vk_sdk, "vkCmdBindVertexBuffers");
                         if( vkCmdBindVertexBuffers == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdBindVertexBuffers in sdk");
                             return NULL;
                         }
                         

                         vkFreeMemory = (PFN_vkFreeMemory)dlsym(vk_sdk, "vkFreeMemory");
                         if( vkFreeMemory == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkFreeMemory in sdk");
                             return NULL;
                         }
                         

                         vkGetQueryPoolResults = (PFN_vkGetQueryPoolResults)dlsym(vk_sdk, "vkGetQueryPoolResults");
                         if( vkGetQueryPoolResults == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetQueryPoolResults in sdk");
                             return NULL;
                         }
                         

                         vkGetImageSubresourceLayout = (PFN_vkGetImageSubresourceLayout)dlsym(vk_sdk, "vkGetImageSubresourceLayout");
                         if( vkGetImageSubresourceLayout == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetImageSubresourceLayout in sdk");
                             return NULL;
                         }
                         

                         vkFreeDescriptorSets = (PFN_vkFreeDescriptorSets)dlsym(vk_sdk, "vkFreeDescriptorSets");
                         if( vkFreeDescriptorSets == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkFreeDescriptorSets in sdk");
                             return NULL;
                         }
                         

                         vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)dlsym(vk_sdk, "vkGetInstanceProcAddr");
                         if( vkGetInstanceProcAddr == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetInstanceProcAddr in sdk");
                             return NULL;
                         }
                         

                         vkCmdDispatch = (PFN_vkCmdDispatch)dlsym(vk_sdk, "vkCmdDispatch");
                         if( vkCmdDispatch == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdDispatch in sdk");
                             return NULL;
                         }
                         

                         vkCreateSemaphore = (PFN_vkCreateSemaphore)dlsym(vk_sdk, "vkCreateSemaphore");
                         if( vkCreateSemaphore == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateSemaphore in sdk");
                             return NULL;
                         }
                         

                         vkCmdResolveImage = (PFN_vkCmdResolveImage)dlsym(vk_sdk, "vkCmdResolveImage");
                         if( vkCmdResolveImage == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdResolveImage in sdk");
                             return NULL;
                         }
                         

                         vkDestroyEvent = (PFN_vkDestroyEvent)dlsym(vk_sdk, "vkDestroyEvent");
                         if( vkDestroyEvent == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyEvent in sdk");
                             return NULL;
                         }
                         

                         vkCmdCopyBufferToImage = (PFN_vkCmdCopyBufferToImage)dlsym(vk_sdk, "vkCmdCopyBufferToImage");
                         if( vkCmdCopyBufferToImage == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdCopyBufferToImage in sdk");
                             return NULL;
                         }
                         

                         vkDestroyFence = (PFN_vkDestroyFence)dlsym(vk_sdk, "vkDestroyFence");
                         if( vkDestroyFence == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyFence in sdk");
                             return NULL;
                         }
                         

                         vkCreateBuffer = (PFN_vkCreateBuffer)dlsym(vk_sdk, "vkCreateBuffer");
                         if( vkCreateBuffer == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateBuffer in sdk");
                             return NULL;
                         }
                         

                         vkCreateGraphicsPipelines = (PFN_vkCreateGraphicsPipelines)dlsym(vk_sdk, "vkCreateGraphicsPipelines");
                         if( vkCreateGraphicsPipelines == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateGraphicsPipelines in sdk");
                             return NULL;
                         }
                         

                         vkCmdBindPipeline = (PFN_vkCmdBindPipeline)dlsym(vk_sdk, "vkCmdBindPipeline");
                         if( vkCmdBindPipeline == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdBindPipeline in sdk");
                             return NULL;
                         }
                         

                         vkCmdCopyQueryPoolResults = (PFN_vkCmdCopyQueryPoolResults)dlsym(vk_sdk, "vkCmdCopyQueryPoolResults");
                         if( vkCmdCopyQueryPoolResults == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdCopyQueryPoolResults in sdk");
                             return NULL;
                         }
                         

                         vkCmdSetDepthBounds = (PFN_vkCmdSetDepthBounds)dlsym(vk_sdk, "vkCmdSetDepthBounds");
                         if( vkCmdSetDepthBounds == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdSetDepthBounds in sdk");
                             return NULL;
                         }
                         

                         vkCreateComputePipelines = (PFN_vkCreateComputePipelines)dlsym(vk_sdk, "vkCreateComputePipelines");
                         if( vkCreateComputePipelines == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateComputePipelines in sdk");
                             return NULL;
                         }
                         

                         vkCmdPushConstants = (PFN_vkCmdPushConstants)dlsym(vk_sdk, "vkCmdPushConstants");
                         if( vkCmdPushConstants == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdPushConstants in sdk");
                             return NULL;
                         }
                         

                         vkCmdExecuteCommands = (PFN_vkCmdExecuteCommands)dlsym(vk_sdk, "vkCmdExecuteCommands");
                         if( vkCmdExecuteCommands == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdExecuteCommands in sdk");
                             return NULL;
                         }
                         

                         vkDestroySemaphore = (PFN_vkDestroySemaphore)dlsym(vk_sdk, "vkDestroySemaphore");
                         if( vkDestroySemaphore == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroySemaphore in sdk");
                             return NULL;
                         }
                         

                         vkCmdBeginQuery = (PFN_vkCmdBeginQuery)dlsym(vk_sdk, "vkCmdBeginQuery");
                         if( vkCmdBeginQuery == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdBeginQuery in sdk");
                             return NULL;
                         }
                         

                         vkResetCommandPool = (PFN_vkResetCommandPool)dlsym(vk_sdk, "vkResetCommandPool");
                         if( vkResetCommandPool == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkResetCommandPool in sdk");
                             return NULL;
                         }
                         

                         vkResetEvent = (PFN_vkResetEvent)dlsym(vk_sdk, "vkResetEvent");
                         if( vkResetEvent == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkResetEvent in sdk");
                             return NULL;
                         }
                         

                         vkCreatePipelineCache = (PFN_vkCreatePipelineCache)dlsym(vk_sdk, "vkCreatePipelineCache");
                         if( vkCreatePipelineCache == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreatePipelineCache in sdk");
                             return NULL;
                         }
                         

                         vkCmdDrawIndexed = (PFN_vkCmdDrawIndexed)dlsym(vk_sdk, "vkCmdDrawIndexed");
                         if( vkCmdDrawIndexed == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdDrawIndexed in sdk");
                             return NULL;
                         }
                         

                         vkGetBufferMemoryRequirements = (PFN_vkGetBufferMemoryRequirements)dlsym(vk_sdk, "vkGetBufferMemoryRequirements");
                         if( vkGetBufferMemoryRequirements == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetBufferMemoryRequirements in sdk");
                             return NULL;
                         }
                         

                         vkCreateFence = (PFN_vkCreateFence)dlsym(vk_sdk, "vkCreateFence");
                         if( vkCreateFence == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateFence in sdk");
                             return NULL;
                         }
                         

                         vkDestroyImage = (PFN_vkDestroyImage)dlsym(vk_sdk, "vkDestroyImage");
                         if( vkDestroyImage == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyImage in sdk");
                             return NULL;
                         }
                         

                         vkGetPhysicalDeviceSparseImageFormatProperties = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceSparseImageFormatProperties");
                         if( vkGetPhysicalDeviceSparseImageFormatProperties == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetPhysicalDeviceSparseImageFormatProperties in sdk");
                             return NULL;
                         }
                         

                         vkGetDeviceMemoryCommitment = (PFN_vkGetDeviceMemoryCommitment)dlsym(vk_sdk, "vkGetDeviceMemoryCommitment");
                         if( vkGetDeviceMemoryCommitment == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetDeviceMemoryCommitment in sdk");
                             return NULL;
                         }
                         

                         vkCmdPipelineBarrier = (PFN_vkCmdPipelineBarrier)dlsym(vk_sdk, "vkCmdPipelineBarrier");
                         if( vkCmdPipelineBarrier == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdPipelineBarrier in sdk");
                             return NULL;
                         }
                         

                         vkEnumerateDeviceExtensionProperties = (PFN_vkEnumerateDeviceExtensionProperties)dlsym(vk_sdk, "vkEnumerateDeviceExtensionProperties");
                         if( vkEnumerateDeviceExtensionProperties == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkEnumerateDeviceExtensionProperties in sdk");
                             return NULL;
                         }
                         

                         vkDestroyQueryPool = (PFN_vkDestroyQueryPool)dlsym(vk_sdk, "vkDestroyQueryPool");
                         if( vkDestroyQueryPool == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyQueryPool in sdk");
                             return NULL;
                         }
                         

                         vkCmdFillBuffer = (PFN_vkCmdFillBuffer)dlsym(vk_sdk, "vkCmdFillBuffer");
                         if( vkCmdFillBuffer == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdFillBuffer in sdk");
                             return NULL;
                         }
                         

                         vkQueueSubmit = (PFN_vkQueueSubmit)dlsym(vk_sdk, "vkQueueSubmit");
                         if( vkQueueSubmit == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkQueueSubmit in sdk");
                             return NULL;
                         }
                         

                         vkFlushMappedMemoryRanges = (PFN_vkFlushMappedMemoryRanges)dlsym(vk_sdk, "vkFlushMappedMemoryRanges");
                         if( vkFlushMappedMemoryRanges == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkFlushMappedMemoryRanges in sdk");
                             return NULL;
                         }
                         

                         vkGetPhysicalDeviceFormatProperties = (PFN_vkGetPhysicalDeviceFormatProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceFormatProperties");
                         if( vkGetPhysicalDeviceFormatProperties == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetPhysicalDeviceFormatProperties in sdk");
                             return NULL;
                         }
                         

                         vkGetPipelineCacheData = (PFN_vkGetPipelineCacheData)dlsym(vk_sdk, "vkGetPipelineCacheData");
                         if( vkGetPipelineCacheData == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetPipelineCacheData in sdk");
                             return NULL;
                         }
                         

                         vkCmdNextSubpass = (PFN_vkCmdNextSubpass)dlsym(vk_sdk, "vkCmdNextSubpass");
                         if( vkCmdNextSubpass == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdNextSubpass in sdk");
                             return NULL;
                         }
                         

                         vkEnumerateInstanceLayerProperties = (PFN_vkEnumerateInstanceLayerProperties)dlsym(vk_sdk, "vkEnumerateInstanceLayerProperties");
                         if( vkEnumerateInstanceLayerProperties == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkEnumerateInstanceLayerProperties in sdk");
                             return NULL;
                         }
                         

                         vkUpdateDescriptorSets = (PFN_vkUpdateDescriptorSets)dlsym(vk_sdk, "vkUpdateDescriptorSets");
                         if( vkUpdateDescriptorSets == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkUpdateDescriptorSets in sdk");
                             return NULL;
                         }
                         

                         vkCmdBeginRenderPass = (PFN_vkCmdBeginRenderPass)dlsym(vk_sdk, "vkCmdBeginRenderPass");
                         if( vkCmdBeginRenderPass == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdBeginRenderPass in sdk");
                             return NULL;
                         }
                         

                         vkGetPhysicalDeviceFeatures = (PFN_vkGetPhysicalDeviceFeatures)dlsym(vk_sdk, "vkGetPhysicalDeviceFeatures");
                         if( vkGetPhysicalDeviceFeatures == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetPhysicalDeviceFeatures in sdk");
                             return NULL;
                         }
                         

                         vkCmdBlitImage = (PFN_vkCmdBlitImage)dlsym(vk_sdk, "vkCmdBlitImage");
                         if( vkCmdBlitImage == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdBlitImage in sdk");
                             return NULL;
                         }
                         

                         vkInvalidateMappedMemoryRanges = (PFN_vkInvalidateMappedMemoryRanges)dlsym(vk_sdk, "vkInvalidateMappedMemoryRanges");
                         if( vkInvalidateMappedMemoryRanges == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkInvalidateMappedMemoryRanges in sdk");
                             return NULL;
                         }
                         

                         vkBindBufferMemory = (PFN_vkBindBufferMemory)dlsym(vk_sdk, "vkBindBufferMemory");
                         if( vkBindBufferMemory == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkBindBufferMemory in sdk");
                             return NULL;
                         }
                         

                         vkEndCommandBuffer = (PFN_vkEndCommandBuffer)dlsym(vk_sdk, "vkEndCommandBuffer");
                         if( vkEndCommandBuffer == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkEndCommandBuffer in sdk");
                             return NULL;
                         }
                         

                         vkCmdCopyImage = (PFN_vkCmdCopyImage)dlsym(vk_sdk, "vkCmdCopyImage");
                         if( vkCmdCopyImage == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdCopyImage in sdk");
                             return NULL;
                         }
                         

                         vkCreateBufferView = (PFN_vkCreateBufferView)dlsym(vk_sdk, "vkCreateBufferView");
                         if( vkCreateBufferView == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateBufferView in sdk");
                             return NULL;
                         }
                         

                         vkGetPhysicalDeviceProperties = (PFN_vkGetPhysicalDeviceProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceProperties");
                         if( vkGetPhysicalDeviceProperties == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetPhysicalDeviceProperties in sdk");
                             return NULL;
                         }
                         

                         vkCmdSetStencilReference = (PFN_vkCmdSetStencilReference)dlsym(vk_sdk, "vkCmdSetStencilReference");
                         if( vkCmdSetStencilReference == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdSetStencilReference in sdk");
                             return NULL;
                         }
                         

                         vkCmdDispatchIndirect = (PFN_vkCmdDispatchIndirect)dlsym(vk_sdk, "vkCmdDispatchIndirect");
                         if( vkCmdDispatchIndirect == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdDispatchIndirect in sdk");
                             return NULL;
                         }
                         

                         vkCreateImage = (PFN_vkCreateImage)dlsym(vk_sdk, "vkCreateImage");
                         if( vkCreateImage == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateImage in sdk");
                             return NULL;
                         }
                         

                         vkBindImageMemory = (PFN_vkBindImageMemory)dlsym(vk_sdk, "vkBindImageMemory");
                         if( vkBindImageMemory == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkBindImageMemory in sdk");
                             return NULL;
                         }
                         

                         vkCmdDrawIndirect = (PFN_vkCmdDrawIndirect)dlsym(vk_sdk, "vkCmdDrawIndirect");
                         if( vkCmdDrawIndirect == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdDrawIndirect in sdk");
                             return NULL;
                         }
                         

                         vkGetImageMemoryRequirements = (PFN_vkGetImageMemoryRequirements)dlsym(vk_sdk, "vkGetImageMemoryRequirements");
                         if( vkGetImageMemoryRequirements == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetImageMemoryRequirements in sdk");
                             return NULL;
                         }
                         

                         vkGetRenderAreaGranularity = (PFN_vkGetRenderAreaGranularity)dlsym(vk_sdk, "vkGetRenderAreaGranularity");
                         if( vkGetRenderAreaGranularity == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetRenderAreaGranularity in sdk");
                             return NULL;
                         }
                         

                         vkCreateImageView = (PFN_vkCreateImageView)dlsym(vk_sdk, "vkCreateImageView");
                         if( vkCreateImageView == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateImageView in sdk");
                             return NULL;
                         }
                         

                         vkCreateEvent = (PFN_vkCreateEvent)dlsym(vk_sdk, "vkCreateEvent");
                         if( vkCreateEvent == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateEvent in sdk");
                             return NULL;
                         }
                         

                         vkCmdBindDescriptorSets = (PFN_vkCmdBindDescriptorSets)dlsym(vk_sdk, "vkCmdBindDescriptorSets");
                         if( vkCmdBindDescriptorSets == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdBindDescriptorSets in sdk");
                             return NULL;
                         }
                         

                         vkEnumeratePhysicalDevices = (PFN_vkEnumeratePhysicalDevices)dlsym(vk_sdk, "vkEnumeratePhysicalDevices");
                         if( vkEnumeratePhysicalDevices == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkEnumeratePhysicalDevices in sdk");
                             return NULL;
                         }
                         

                         vkMapMemory = (PFN_vkMapMemory)dlsym(vk_sdk, "vkMapMemory");
                         if( vkMapMemory == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkMapMemory in sdk");
                             return NULL;
                         }
                         

                         vkDestroyInstance = (PFN_vkDestroyInstance)dlsym(vk_sdk, "vkDestroyInstance");
                         if( vkDestroyInstance == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyInstance in sdk");
                             return NULL;
                         }
                         

                         vkCmdUpdateBuffer = (PFN_vkCmdUpdateBuffer)dlsym(vk_sdk, "vkCmdUpdateBuffer");
                         if( vkCmdUpdateBuffer == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdUpdateBuffer in sdk");
                             return NULL;
                         }
                         

                         vkGetPhysicalDeviceMemoryProperties = (PFN_vkGetPhysicalDeviceMemoryProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceMemoryProperties");
                         if( vkGetPhysicalDeviceMemoryProperties == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetPhysicalDeviceMemoryProperties in sdk");
                             return NULL;
                         }
                         

                         vkUnmapMemory = (PFN_vkUnmapMemory)dlsym(vk_sdk, "vkUnmapMemory");
                         if( vkUnmapMemory == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkUnmapMemory in sdk");
                             return NULL;
                         }
                         

                         vkCreateCommandPool = (PFN_vkCreateCommandPool)dlsym(vk_sdk, "vkCreateCommandPool");
                         if( vkCreateCommandPool == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateCommandPool in sdk");
                             return NULL;
                         }
                         

                         vkDestroyFramebuffer = (PFN_vkDestroyFramebuffer)dlsym(vk_sdk, "vkDestroyFramebuffer");
                         if( vkDestroyFramebuffer == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyFramebuffer in sdk");
                             return NULL;
                         }
                         

                         vkDestroyImageView = (PFN_vkDestroyImageView)dlsym(vk_sdk, "vkDestroyImageView");
                         if( vkDestroyImageView == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyImageView in sdk");
                             return NULL;
                         }
                         

                         vkFreeCommandBuffers = (PFN_vkFreeCommandBuffers)dlsym(vk_sdk, "vkFreeCommandBuffers");
                         if( vkFreeCommandBuffers == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkFreeCommandBuffers in sdk");
                             return NULL;
                         }
                         

                         vkEnumerateInstanceExtensionProperties = (PFN_vkEnumerateInstanceExtensionProperties)dlsym(vk_sdk, "vkEnumerateInstanceExtensionProperties");
                         if( vkEnumerateInstanceExtensionProperties == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkEnumerateInstanceExtensionProperties in sdk");
                             return NULL;
                         }
                         

                         vkCreateSampler = (PFN_vkCreateSampler)dlsym(vk_sdk, "vkCreateSampler");
                         if( vkCreateSampler == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateSampler in sdk");
                             return NULL;
                         }
                         

                         vkDestroyBuffer = (PFN_vkDestroyBuffer)dlsym(vk_sdk, "vkDestroyBuffer");
                         if( vkDestroyBuffer == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyBuffer in sdk");
                             return NULL;
                         }
                         

                         vkEnumerateDeviceLayerProperties = (PFN_vkEnumerateDeviceLayerProperties)dlsym(vk_sdk, "vkEnumerateDeviceLayerProperties");
                         if( vkEnumerateDeviceLayerProperties == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkEnumerateDeviceLayerProperties in sdk");
                             return NULL;
                         }
                         

                         vkCmdDraw = (PFN_vkCmdDraw)dlsym(vk_sdk, "vkCmdDraw");
                         if( vkCmdDraw == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdDraw in sdk");
                             return NULL;
                         }
                         

                         vkAllocateCommandBuffers = (PFN_vkAllocateCommandBuffers)dlsym(vk_sdk, "vkAllocateCommandBuffers");
                         if( vkAllocateCommandBuffers == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkAllocateCommandBuffers in sdk");
                             return NULL;
                         }
                         

                         vkCmdWaitEvents = (PFN_vkCmdWaitEvents)dlsym(vk_sdk, "vkCmdWaitEvents");
                         if( vkCmdWaitEvents == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdWaitEvents in sdk");
                             return NULL;
                         }
                         

                         vkCmdSetDepthBias = (PFN_vkCmdSetDepthBias)dlsym(vk_sdk, "vkCmdSetDepthBias");
                         if( vkCmdSetDepthBias == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdSetDepthBias in sdk");
                             return NULL;
                         }
                         

                         vkCreateDescriptorPool = (PFN_vkCreateDescriptorPool)dlsym(vk_sdk, "vkCreateDescriptorPool");
                         if( vkCreateDescriptorPool == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCreateDescriptorPool in sdk");
                             return NULL;
                         }
                         

                         vkDeviceWaitIdle = (PFN_vkDeviceWaitIdle)dlsym(vk_sdk, "vkDeviceWaitIdle");
                         if( vkDeviceWaitIdle == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDeviceWaitIdle in sdk");
                             return NULL;
                         }
                         

                         vkDestroySampler = (PFN_vkDestroySampler)dlsym(vk_sdk, "vkDestroySampler");
                         if( vkDestroySampler == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroySampler in sdk");
                             return NULL;
                         }
                         

                         vkDestroyBufferView = (PFN_vkDestroyBufferView)dlsym(vk_sdk, "vkDestroyBufferView");
                         if( vkDestroyBufferView == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyBufferView in sdk");
                             return NULL;
                         }
                         

                         vkGetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceQueueFamilyProperties");
                         if( vkGetPhysicalDeviceQueueFamilyProperties == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetPhysicalDeviceQueueFamilyProperties in sdk");
                             return NULL;
                         }
                         

                         vkCmdSetBlendConstants = (PFN_vkCmdSetBlendConstants)dlsym(vk_sdk, "vkCmdSetBlendConstants");
                         if( vkCmdSetBlendConstants == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdSetBlendConstants in sdk");
                             return NULL;
                         }
                         

                         vkMergePipelineCaches = (PFN_vkMergePipelineCaches)dlsym(vk_sdk, "vkMergePipelineCaches");
                         if( vkMergePipelineCaches == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkMergePipelineCaches in sdk");
                             return NULL;
                         }
                         

                         vkGetImageSparseMemoryRequirements = (PFN_vkGetImageSparseMemoryRequirements)dlsym(vk_sdk, "vkGetImageSparseMemoryRequirements");
                         if( vkGetImageSparseMemoryRequirements == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetImageSparseMemoryRequirements in sdk");
                             return NULL;
                         }
                         

                         vkCmdSetLineWidth = (PFN_vkCmdSetLineWidth)dlsym(vk_sdk, "vkCmdSetLineWidth");
                         if( vkCmdSetLineWidth == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkCmdSetLineWidth in sdk");
                             return NULL;
                         }
                         

                         vkDestroyShaderModule = (PFN_vkDestroyShaderModule)dlsym(vk_sdk, "vkDestroyShaderModule");
                         if( vkDestroyShaderModule == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkDestroyShaderModule in sdk");
                             return NULL;
                         }
                         

                         vkGetEventStatus = (PFN_vkGetEventStatus)dlsym(vk_sdk, "vkGetEventStatus");
                         if( vkGetEventStatus == NULL ) {
                             PyErr_SetString(PyExc_ImportError,
                                             "Can't load vkGetEventStatus in sdk");
                             return NULL;
                         }
                         

            Py_INCREF(Py_None);
            return Py_None;
        }
    
            static PyObject* PyHandle_VkShaderModule (PyObject *self, PyObject *args) {
                  VkShaderModule* handle = malloc(sizeof(VkShaderModule));
                  PyObject* value = PyCapsule_New(handle, "VkShaderModule", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkImageView (PyObject *self, PyObject *args) {
                  VkImageView* handle = malloc(sizeof(VkImageView));
                  PyObject* value = PyCapsule_New(handle, "VkImageView", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkBufferView (PyObject *self, PyObject *args) {
                  VkBufferView* handle = malloc(sizeof(VkBufferView));
                  PyObject* value = PyCapsule_New(handle, "VkBufferView", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkPhysicalDevice (PyObject *self, PyObject *args) {
                  VkPhysicalDevice* handle = malloc(sizeof(VkPhysicalDevice));
                  PyObject* value = PyCapsule_New(handle, "VkPhysicalDevice", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkBuffer (PyObject *self, PyObject *args) {
                  VkBuffer* handle = malloc(sizeof(VkBuffer));
                  PyObject* value = PyCapsule_New(handle, "VkBuffer", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkEvent (PyObject *self, PyObject *args) {
                  VkEvent* handle = malloc(sizeof(VkEvent));
                  PyObject* value = PyCapsule_New(handle, "VkEvent", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkQueryPool (PyObject *self, PyObject *args) {
                  VkQueryPool* handle = malloc(sizeof(VkQueryPool));
                  PyObject* value = PyCapsule_New(handle, "VkQueryPool", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkSampler (PyObject *self, PyObject *args) {
                  VkSampler* handle = malloc(sizeof(VkSampler));
                  PyObject* value = PyCapsule_New(handle, "VkSampler", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkCommandBuffer (PyObject *self, PyObject *args) {
                  VkCommandBuffer* handle = malloc(sizeof(VkCommandBuffer));
                  PyObject* value = PyCapsule_New(handle, "VkCommandBuffer", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkDescriptorSet (PyObject *self, PyObject *args) {
                  VkDescriptorSet* handle = malloc(sizeof(VkDescriptorSet));
                  PyObject* value = PyCapsule_New(handle, "VkDescriptorSet", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkDeviceMemory (PyObject *self, PyObject *args) {
                  VkDeviceMemory* handle = malloc(sizeof(VkDeviceMemory));
                  PyObject* value = PyCapsule_New(handle, "VkDeviceMemory", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkCommandPool (PyObject *self, PyObject *args) {
                  VkCommandPool* handle = malloc(sizeof(VkCommandPool));
                  PyObject* value = PyCapsule_New(handle, "VkCommandPool", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkSurfaceKHR (PyObject *self, PyObject *args) {
                  VkSurfaceKHR* handle = malloc(sizeof(VkSurfaceKHR));
                  PyObject* value = PyCapsule_New(handle, "VkSurfaceKHR", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkPipelineCache (PyObject *self, PyObject *args) {
                  VkPipelineCache* handle = malloc(sizeof(VkPipelineCache));
                  PyObject* value = PyCapsule_New(handle, "VkPipelineCache", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkInstance (PyObject *self, PyObject *args) {
                  VkInstance* handle = malloc(sizeof(VkInstance));
                  PyObject* value = PyCapsule_New(handle, "VkInstance", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkDebugReportCallbackEXT (PyObject *self, PyObject *args) {
                  VkDebugReportCallbackEXT* handle = malloc(sizeof(VkDebugReportCallbackEXT));
                  PyObject* value = PyCapsule_New(handle, "VkDebugReportCallbackEXT", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkFence (PyObject *self, PyObject *args) {
                  VkFence* handle = malloc(sizeof(VkFence));
                  PyObject* value = PyCapsule_New(handle, "VkFence", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkFramebuffer (PyObject *self, PyObject *args) {
                  VkFramebuffer* handle = malloc(sizeof(VkFramebuffer));
                  PyObject* value = PyCapsule_New(handle, "VkFramebuffer", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkDisplayModeKHR (PyObject *self, PyObject *args) {
                  VkDisplayModeKHR* handle = malloc(sizeof(VkDisplayModeKHR));
                  PyObject* value = PyCapsule_New(handle, "VkDisplayModeKHR", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkDescriptorPool (PyObject *self, PyObject *args) {
                  VkDescriptorPool* handle = malloc(sizeof(VkDescriptorPool));
                  PyObject* value = PyCapsule_New(handle, "VkDescriptorPool", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkSwapchainKHR (PyObject *self, PyObject *args) {
                  VkSwapchainKHR* handle = malloc(sizeof(VkSwapchainKHR));
                  PyObject* value = PyCapsule_New(handle, "VkSwapchainKHR", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkDescriptorSetLayout (PyObject *self, PyObject *args) {
                  VkDescriptorSetLayout* handle = malloc(sizeof(VkDescriptorSetLayout));
                  PyObject* value = PyCapsule_New(handle, "VkDescriptorSetLayout", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkImage (PyObject *self, PyObject *args) {
                  VkImage* handle = malloc(sizeof(VkImage));
                  PyObject* value = PyCapsule_New(handle, "VkImage", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkSemaphore (PyObject *self, PyObject *args) {
                  VkSemaphore* handle = malloc(sizeof(VkSemaphore));
                  PyObject* value = PyCapsule_New(handle, "VkSemaphore", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkDevice (PyObject *self, PyObject *args) {
                  VkDevice* handle = malloc(sizeof(VkDevice));
                  PyObject* value = PyCapsule_New(handle, "VkDevice", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkDisplayKHR (PyObject *self, PyObject *args) {
                  VkDisplayKHR* handle = malloc(sizeof(VkDisplayKHR));
                  PyObject* value = PyCapsule_New(handle, "VkDisplayKHR", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkQueue (PyObject *self, PyObject *args) {
                  VkQueue* handle = malloc(sizeof(VkQueue));
                  PyObject* value = PyCapsule_New(handle, "VkQueue", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkPipeline (PyObject *self, PyObject *args) {
                  VkPipeline* handle = malloc(sizeof(VkPipeline));
                  PyObject* value = PyCapsule_New(handle, "VkPipeline", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkPipelineLayout (PyObject *self, PyObject *args) {
                  VkPipelineLayout* handle = malloc(sizeof(VkPipelineLayout));
                  PyObject* value = PyCapsule_New(handle, "VkPipelineLayout", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            static PyObject* PyHandle_VkRenderPass (PyObject *self, PyObject *args) {
                  VkRenderPass* handle = malloc(sizeof(VkRenderPass));
                  PyObject* value = PyCapsule_New(handle, "VkRenderPass", NULL);
                  if (value == NULL) return NULL;
                  return value;
            }
            
            typedef struct { PyObject_HEAD VkOffset2D *base; }
            PyVkOffset2D;
            
            typedef struct { PyObject_HEAD VkOffset3D *base; }
            PyVkOffset3D;
            
            typedef struct { PyObject_HEAD VkExtent2D *base; }
            PyVkExtent2D;
            
            typedef struct { PyObject_HEAD VkExtent3D *base; }
            PyVkExtent3D;
            
            typedef struct { PyObject_HEAD VkViewport *base; }
            PyVkViewport;
            
            typedef struct { PyObject_HEAD VkRect2D *base; }
            PyVkRect2D;
            
#ifdef hackdefine

            typedef struct { PyObject_HEAD VkRect3D *base; }
            PyVkRect3D;
            
#endif

            typedef struct { PyObject_HEAD VkClearRect *base; }
            PyVkClearRect;
            
            typedef struct { PyObject_HEAD VkComponentMapping *base; }
            PyVkComponentMapping;
            
            typedef struct { PyObject_HEAD VkPhysicalDeviceProperties *base; }
            PyVkPhysicalDeviceProperties;
            
            typedef struct { PyObject_HEAD VkExtensionProperties *base; }
            PyVkExtensionProperties;
            
            typedef struct { PyObject_HEAD VkLayerProperties *base; }
            PyVkLayerProperties;
            
            typedef struct { PyObject_HEAD VkApplicationInfo *base; }
            PyVkApplicationInfo;
            
            typedef struct { PyObject_HEAD VkAllocationCallbacks *base; }
            PyVkAllocationCallbacks;
            
            typedef struct { PyObject_HEAD VkDeviceQueueCreateInfo *base; }
            PyVkDeviceQueueCreateInfo;
            
            typedef struct { PyObject_HEAD VkDeviceCreateInfo *base; }
            PyVkDeviceCreateInfo;
            
            typedef struct { PyObject_HEAD VkInstanceCreateInfo *base; }
            PyVkInstanceCreateInfo;
            
            typedef struct { PyObject_HEAD VkQueueFamilyProperties *base; }
            PyVkQueueFamilyProperties;
            
            typedef struct { PyObject_HEAD VkPhysicalDeviceMemoryProperties *base; }
            PyVkPhysicalDeviceMemoryProperties;
            
            typedef struct { PyObject_HEAD VkMemoryAllocateInfo *base; }
            PyVkMemoryAllocateInfo;
            
            typedef struct { PyObject_HEAD VkMemoryRequirements *base; }
            PyVkMemoryRequirements;
            
            typedef struct { PyObject_HEAD VkSparseImageFormatProperties *base; }
            PyVkSparseImageFormatProperties;
            
            typedef struct { PyObject_HEAD VkSparseImageMemoryRequirements *base; }
            PyVkSparseImageMemoryRequirements;
            
            typedef struct { PyObject_HEAD VkMemoryType *base; }
            PyVkMemoryType;
            
            typedef struct { PyObject_HEAD VkMemoryHeap *base; }
            PyVkMemoryHeap;
            
            typedef struct { PyObject_HEAD VkMappedMemoryRange *base; }
            PyVkMappedMemoryRange;
            
            typedef struct { PyObject_HEAD VkFormatProperties *base; }
            PyVkFormatProperties;
            
            typedef struct { PyObject_HEAD VkImageFormatProperties *base; }
            PyVkImageFormatProperties;
            
            typedef struct { PyObject_HEAD VkDescriptorBufferInfo *base; }
            PyVkDescriptorBufferInfo;
            
            typedef struct { PyObject_HEAD VkDescriptorImageInfo *base; }
            PyVkDescriptorImageInfo;
            
            typedef struct { PyObject_HEAD VkWriteDescriptorSet *base; }
            PyVkWriteDescriptorSet;
            
            typedef struct { PyObject_HEAD VkCopyDescriptorSet *base; }
            PyVkCopyDescriptorSet;
            
            typedef struct { PyObject_HEAD VkBufferCreateInfo *base; }
            PyVkBufferCreateInfo;
            
            typedef struct { PyObject_HEAD VkBufferViewCreateInfo *base; }
            PyVkBufferViewCreateInfo;
            
            typedef struct { PyObject_HEAD VkImageSubresource *base; }
            PyVkImageSubresource;
            
            typedef struct { PyObject_HEAD VkImageSubresourceLayers *base; }
            PyVkImageSubresourceLayers;
            
            typedef struct { PyObject_HEAD VkImageSubresourceRange *base; }
            PyVkImageSubresourceRange;
            
            typedef struct { PyObject_HEAD VkMemoryBarrier *base; }
            PyVkMemoryBarrier;
            
            typedef struct { PyObject_HEAD VkBufferMemoryBarrier *base; }
            PyVkBufferMemoryBarrier;
            
            typedef struct { PyObject_HEAD VkImageMemoryBarrier *base; }
            PyVkImageMemoryBarrier;
            
            typedef struct { PyObject_HEAD VkImageCreateInfo *base; }
            PyVkImageCreateInfo;
            
            typedef struct { PyObject_HEAD VkSubresourceLayout *base; }
            PyVkSubresourceLayout;
            
            typedef struct { PyObject_HEAD VkImageViewCreateInfo *base; }
            PyVkImageViewCreateInfo;
            
            typedef struct { PyObject_HEAD VkBufferCopy *base; }
            PyVkBufferCopy;
            
            typedef struct { PyObject_HEAD VkSparseMemoryBind *base; }
            PyVkSparseMemoryBind;
            
            typedef struct { PyObject_HEAD VkSparseImageMemoryBind *base; }
            PyVkSparseImageMemoryBind;
            
            typedef struct { PyObject_HEAD VkSparseBufferMemoryBindInfo *base; }
            PyVkSparseBufferMemoryBindInfo;
            
            typedef struct { PyObject_HEAD VkSparseImageOpaqueMemoryBindInfo *base; }
            PyVkSparseImageOpaqueMemoryBindInfo;
            
            typedef struct { PyObject_HEAD VkSparseImageMemoryBindInfo *base; }
            PyVkSparseImageMemoryBindInfo;
            
            typedef struct { PyObject_HEAD VkBindSparseInfo *base; }
            PyVkBindSparseInfo;
            
            typedef struct { PyObject_HEAD VkImageCopy *base; }
            PyVkImageCopy;
            
            typedef struct { PyObject_HEAD VkImageBlit *base; }
            PyVkImageBlit;
            
            typedef struct { PyObject_HEAD VkBufferImageCopy *base; }
            PyVkBufferImageCopy;
            
            typedef struct { PyObject_HEAD VkImageResolve *base; }
            PyVkImageResolve;
            
            typedef struct { PyObject_HEAD VkShaderModuleCreateInfo *base; }
            PyVkShaderModuleCreateInfo;
            
            typedef struct { PyObject_HEAD VkDescriptorSetLayoutBinding *base; }
            PyVkDescriptorSetLayoutBinding;
            
            typedef struct { PyObject_HEAD VkDescriptorSetLayoutCreateInfo *base; }
            PyVkDescriptorSetLayoutCreateInfo;
            
            typedef struct { PyObject_HEAD VkDescriptorPoolSize *base; }
            PyVkDescriptorPoolSize;
            
            typedef struct { PyObject_HEAD VkDescriptorPoolCreateInfo *base; }
            PyVkDescriptorPoolCreateInfo;
            
            typedef struct { PyObject_HEAD VkDescriptorSetAllocateInfo *base; }
            PyVkDescriptorSetAllocateInfo;
            
            typedef struct { PyObject_HEAD VkSpecializationMapEntry *base; }
            PyVkSpecializationMapEntry;
            
            typedef struct { PyObject_HEAD VkSpecializationInfo *base; }
            PyVkSpecializationInfo;
            
            typedef struct { PyObject_HEAD VkPipelineShaderStageCreateInfo *base; }
            PyVkPipelineShaderStageCreateInfo;
            
            typedef struct { PyObject_HEAD VkComputePipelineCreateInfo *base; }
            PyVkComputePipelineCreateInfo;
            
            typedef struct { PyObject_HEAD VkVertexInputBindingDescription *base; }
            PyVkVertexInputBindingDescription;
            
            typedef struct { PyObject_HEAD VkVertexInputAttributeDescription *base; }
            PyVkVertexInputAttributeDescription;
            
            typedef struct { PyObject_HEAD VkPipelineVertexInputStateCreateInfo *base; }
            PyVkPipelineVertexInputStateCreateInfo;
            
            typedef struct { PyObject_HEAD VkPipelineInputAssemblyStateCreateInfo *base; }
            PyVkPipelineInputAssemblyStateCreateInfo;
            
            typedef struct { PyObject_HEAD VkPipelineTessellationStateCreateInfo *base; }
            PyVkPipelineTessellationStateCreateInfo;
            
            typedef struct { PyObject_HEAD VkPipelineViewportStateCreateInfo *base; }
            PyVkPipelineViewportStateCreateInfo;
            
            typedef struct { PyObject_HEAD VkPipelineRasterizationStateCreateInfo *base; }
            PyVkPipelineRasterizationStateCreateInfo;
            
            typedef struct { PyObject_HEAD VkPipelineMultisampleStateCreateInfo *base; }
            PyVkPipelineMultisampleStateCreateInfo;
            
            typedef struct { PyObject_HEAD VkPipelineColorBlendAttachmentState *base; }
            PyVkPipelineColorBlendAttachmentState;
            
            typedef struct { PyObject_HEAD VkPipelineColorBlendStateCreateInfo *base; }
            PyVkPipelineColorBlendStateCreateInfo;
            
            typedef struct { PyObject_HEAD VkPipelineDynamicStateCreateInfo *base; }
            PyVkPipelineDynamicStateCreateInfo;
            
            typedef struct { PyObject_HEAD VkStencilOpState *base; }
            PyVkStencilOpState;
            
            typedef struct { PyObject_HEAD VkPipelineDepthStencilStateCreateInfo *base; }
            PyVkPipelineDepthStencilStateCreateInfo;
            
            typedef struct { PyObject_HEAD VkGraphicsPipelineCreateInfo *base; }
            PyVkGraphicsPipelineCreateInfo;
            
            typedef struct { PyObject_HEAD VkPipelineCacheCreateInfo *base; }
            PyVkPipelineCacheCreateInfo;
            
            typedef struct { PyObject_HEAD VkPushConstantRange *base; }
            PyVkPushConstantRange;
            
            typedef struct { PyObject_HEAD VkPipelineLayoutCreateInfo *base; }
            PyVkPipelineLayoutCreateInfo;
            
            typedef struct { PyObject_HEAD VkSamplerCreateInfo *base; }
            PyVkSamplerCreateInfo;
            
            typedef struct { PyObject_HEAD VkCommandPoolCreateInfo *base; }
            PyVkCommandPoolCreateInfo;
            
            typedef struct { PyObject_HEAD VkCommandBufferAllocateInfo *base; }
            PyVkCommandBufferAllocateInfo;
            
            typedef struct { PyObject_HEAD VkCommandBufferInheritanceInfo *base; }
            PyVkCommandBufferInheritanceInfo;
            
            typedef struct { PyObject_HEAD VkCommandBufferBeginInfo *base; }
            PyVkCommandBufferBeginInfo;
            
            typedef struct { PyObject_HEAD VkRenderPassBeginInfo *base; }
            PyVkRenderPassBeginInfo;
            
            typedef struct { PyObject_HEAD VkClearDepthStencilValue *base; }
            PyVkClearDepthStencilValue;
            
            typedef struct { PyObject_HEAD VkClearAttachment *base; }
            PyVkClearAttachment;
            
            typedef struct { PyObject_HEAD VkAttachmentDescription *base; }
            PyVkAttachmentDescription;
            
            typedef struct { PyObject_HEAD VkAttachmentReference *base; }
            PyVkAttachmentReference;
            
            typedef struct { PyObject_HEAD VkSubpassDescription *base; }
            PyVkSubpassDescription;
            
            typedef struct { PyObject_HEAD VkSubpassDependency *base; }
            PyVkSubpassDependency;
            
            typedef struct { PyObject_HEAD VkRenderPassCreateInfo *base; }
            PyVkRenderPassCreateInfo;
            
            typedef struct { PyObject_HEAD VkEventCreateInfo *base; }
            PyVkEventCreateInfo;
            
            typedef struct { PyObject_HEAD VkFenceCreateInfo *base; }
            PyVkFenceCreateInfo;
            
            typedef struct { PyObject_HEAD VkPhysicalDeviceFeatures *base; }
            PyVkPhysicalDeviceFeatures;
            
            typedef struct { PyObject_HEAD VkPhysicalDeviceSparseProperties *base; }
            PyVkPhysicalDeviceSparseProperties;
            
            typedef struct { PyObject_HEAD VkPhysicalDeviceLimits *base; }
            PyVkPhysicalDeviceLimits;
            
            typedef struct { PyObject_HEAD VkSemaphoreCreateInfo *base; }
            PyVkSemaphoreCreateInfo;
            
            typedef struct { PyObject_HEAD VkQueryPoolCreateInfo *base; }
            PyVkQueryPoolCreateInfo;
            
            typedef struct { PyObject_HEAD VkFramebufferCreateInfo *base; }
            PyVkFramebufferCreateInfo;
            
            typedef struct { PyObject_HEAD VkDrawIndirectCommand *base; }
            PyVkDrawIndirectCommand;
            
            typedef struct { PyObject_HEAD VkDrawIndexedIndirectCommand *base; }
            PyVkDrawIndexedIndirectCommand;
            
            typedef struct { PyObject_HEAD VkDispatchIndirectCommand *base; }
            PyVkDispatchIndirectCommand;
            
            typedef struct { PyObject_HEAD VkSubmitInfo *base; }
            PyVkSubmitInfo;
            
            typedef struct { PyObject_HEAD VkDisplayPropertiesKHR *base; }
            PyVkDisplayPropertiesKHR;
            
            typedef struct { PyObject_HEAD VkDisplayPlanePropertiesKHR *base; }
            PyVkDisplayPlanePropertiesKHR;
            
            typedef struct { PyObject_HEAD VkDisplayModeParametersKHR *base; }
            PyVkDisplayModeParametersKHR;
            
            typedef struct { PyObject_HEAD VkDisplayModePropertiesKHR *base; }
            PyVkDisplayModePropertiesKHR;
            
            typedef struct { PyObject_HEAD VkDisplayModeCreateInfoKHR *base; }
            PyVkDisplayModeCreateInfoKHR;
            
            typedef struct { PyObject_HEAD VkDisplayPlaneCapabilitiesKHR *base; }
            PyVkDisplayPlaneCapabilitiesKHR;
            
            typedef struct { PyObject_HEAD VkDisplaySurfaceCreateInfoKHR *base; }
            PyVkDisplaySurfaceCreateInfoKHR;
            
            typedef struct { PyObject_HEAD VkDisplayPresentInfoKHR *base; }
            PyVkDisplayPresentInfoKHR;
            
            typedef struct { PyObject_HEAD VkSurfaceCapabilitiesKHR *base; }
            PyVkSurfaceCapabilitiesKHR;
            
#ifdef VK_USE_PLATFORM_ANDROID_KHR

            typedef struct { PyObject_HEAD VkAndroidSurfaceCreateInfoKHR *base; }
            PyVkAndroidSurfaceCreateInfoKHR;
            
#endif

#ifdef VK_USE_PLATFORM_MIR_KHR

            typedef struct { PyObject_HEAD VkMirSurfaceCreateInfoKHR *base; }
            PyVkMirSurfaceCreateInfoKHR;
            
#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

            typedef struct { PyObject_HEAD VkWaylandSurfaceCreateInfoKHR *base; }
            PyVkWaylandSurfaceCreateInfoKHR;
            
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

            typedef struct { PyObject_HEAD VkWin32SurfaceCreateInfoKHR *base; }
            PyVkWin32SurfaceCreateInfoKHR;
            
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR

            typedef struct { PyObject_HEAD VkXlibSurfaceCreateInfoKHR *base; }
            PyVkXlibSurfaceCreateInfoKHR;
            
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

            typedef struct { PyObject_HEAD VkXcbSurfaceCreateInfoKHR *base; }
            PyVkXcbSurfaceCreateInfoKHR;
            
#endif

            typedef struct { PyObject_HEAD VkSurfaceFormatKHR *base; }
            PyVkSurfaceFormatKHR;
            
            typedef struct { PyObject_HEAD VkSwapchainCreateInfoKHR *base; }
            PyVkSwapchainCreateInfoKHR;
            
            typedef struct { PyObject_HEAD VkPresentInfoKHR *base; }
            PyVkPresentInfoKHR;
            
            typedef struct { PyObject_HEAD VkDebugReportCallbackCreateInfoEXT *base; }
            PyVkDebugReportCallbackCreateInfoEXT;
            
            typedef struct { PyObject_HEAD VkDebugReportLayerFlagsEXT *base; }
            PyVkDebugReportLayerFlagsEXT;
            
            typedef struct { PyObject_HEAD VkPipelineRasterizationStateRasterizationOrderAMD *base; }
            PyVkPipelineRasterizationStateRasterizationOrderAMD;
            
            typedef struct { PyObject_HEAD VkDebugMarkerObjectNameInfoEXT *base; }
            PyVkDebugMarkerObjectNameInfoEXT;
            
            typedef struct { PyObject_HEAD VkDebugMarkerObjectTagInfoEXT *base; }
            PyVkDebugMarkerObjectTagInfoEXT;
            
            typedef struct { PyObject_HEAD VkDebugMarkerMarkerInfoEXT *base; }
            PyVkDebugMarkerMarkerInfoEXT;
            
            typedef struct { PyObject_HEAD VkDedicatedAllocationImageCreateInfoNV *base; }
            PyVkDedicatedAllocationImageCreateInfoNV;
            
            typedef struct { PyObject_HEAD VkDedicatedAllocationBufferCreateInfoNV *base; }
            PyVkDedicatedAllocationBufferCreateInfoNV;
            
            typedef struct { PyObject_HEAD VkDedicatedAllocationMemoryAllocateInfoNV *base; }
            PyVkDedicatedAllocationMemoryAllocateInfoNV;
            
            typedef struct { PyObject_HEAD VkExternalImageFormatPropertiesNV *base; }
            PyVkExternalImageFormatPropertiesNV;
            
            typedef struct { PyObject_HEAD VkExternalMemoryImageCreateInfoNV *base; }
            PyVkExternalMemoryImageCreateInfoNV;
            
            typedef struct { PyObject_HEAD VkExportMemoryAllocateInfoNV *base; }
            PyVkExportMemoryAllocateInfoNV;
            
#ifdef VK_USE_PLATFORM_WIN32_KHR

            typedef struct { PyObject_HEAD VkImportMemoryWin32HandleInfoNV *base; }
            PyVkImportMemoryWin32HandleInfoNV;
            
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

            typedef struct { PyObject_HEAD VkExportMemoryWin32HandleInfoNV *base; }
            PyVkExportMemoryWin32HandleInfoNV;
            
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

            typedef struct { PyObject_HEAD VkWin32KeyedMutexAcquireReleaseInfoNV *base; }
            PyVkWin32KeyedMutexAcquireReleaseInfoNV;
            
#endif

            typedef struct { PyObject_HEAD VkClearColorValue *base; }
            PyVkClearColorValue;
            
            typedef struct { PyObject_HEAD VkClearValue *base; }
            PyVkClearValue;
            
            static void PyVkOffset2D_del(PyVkOffset2D* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkOffset2D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkOffset2D *self;
                self = (PyVkOffset2D *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkOffset2D));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkOffset2D");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkOffset2D_getx(PyVkOffset2D *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->x);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkOffset2D_gety(PyVkOffset2D *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->y);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkOffset2D_getsetters[] = {
                
                    { "x", (getter)PyVkOffset2D_getx, NULL, "", NULL},
                
                    { "y", (getter)PyVkOffset2D_gety, NULL, "", NULL},
                {NULL}};

            static int
            PyVkOffset2D_init(PyVkOffset2D *self, PyObject *args, PyObject *kwds) {
            PyObject* x = NULL;
PyObject* y = NULL;
static char *kwlist[] = {"x","y",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OO", kwlist, &x, &y)) return -1;

                if (x != NULL && x != Py_None) {
                (self->base)->x = (int32_t) PyLong_AsLong(x);
 } 

                if (y != NULL && y != Py_None) {
                (self->base)->y = (int32_t) PyLong_AsLong(y);
 } 

return 0; }
            static PyTypeObject PyVkOffset2DType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkOffset2D", sizeof(PyVkOffset2D), 0,
                (destructor)PyVkOffset2D_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkOffset2D object",0,0,0,0,0,0,0,0,
                PyVkOffset2D_getsetters,0,0,0,0,0,(initproc)PyVkOffset2D_init,0,PyVkOffset2D_new,};
        
            static void PyVkOffset3D_del(PyVkOffset3D* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkOffset3D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkOffset3D *self;
                self = (PyVkOffset3D *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkOffset3D));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkOffset3D");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkOffset3D_getx(PyVkOffset3D *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->x);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkOffset3D_gety(PyVkOffset3D *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->y);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkOffset3D_getz(PyVkOffset3D *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->z);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkOffset3D_getsetters[] = {
                
                    { "x", (getter)PyVkOffset3D_getx, NULL, "", NULL},
                
                    { "y", (getter)PyVkOffset3D_gety, NULL, "", NULL},
                
                    { "z", (getter)PyVkOffset3D_getz, NULL, "", NULL},
                {NULL}};

            static int
            PyVkOffset3D_init(PyVkOffset3D *self, PyObject *args, PyObject *kwds) {
            PyObject* x = NULL;
PyObject* y = NULL;
PyObject* z = NULL;
static char *kwlist[] = {"x","y","z",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &x, &y, &z)) return -1;

                if (x != NULL && x != Py_None) {
                (self->base)->x = (int32_t) PyLong_AsLong(x);
 } 

                if (y != NULL && y != Py_None) {
                (self->base)->y = (int32_t) PyLong_AsLong(y);
 } 

                if (z != NULL && z != Py_None) {
                (self->base)->z = (int32_t) PyLong_AsLong(z);
 } 

return 0; }
            static PyTypeObject PyVkOffset3DType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkOffset3D", sizeof(PyVkOffset3D), 0,
                (destructor)PyVkOffset3D_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkOffset3D object",0,0,0,0,0,0,0,0,
                PyVkOffset3D_getsetters,0,0,0,0,0,(initproc)PyVkOffset3D_init,0,PyVkOffset3D_new,};
        
            static void PyVkExtent2D_del(PyVkExtent2D* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkExtent2D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkExtent2D *self;
                self = (PyVkExtent2D *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkExtent2D));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkExtent2D");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkExtent2D_getwidth(PyVkExtent2D *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->width);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkExtent2D_getheight(PyVkExtent2D *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->height);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkExtent2D_getsetters[] = {
                
                    { "width", (getter)PyVkExtent2D_getwidth, NULL, "", NULL},
                
                    { "height", (getter)PyVkExtent2D_getheight, NULL, "", NULL},
                {NULL}};

            static int
            PyVkExtent2D_init(PyVkExtent2D *self, PyObject *args, PyObject *kwds) {
            PyObject* width = NULL;
PyObject* height = NULL;
static char *kwlist[] = {"width","height",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OO", kwlist, &width, &height)) return -1;

                if (width != NULL && width != Py_None) {
                (self->base)->width = (uint32_t) PyLong_AsLong(width);
 } 

                if (height != NULL && height != Py_None) {
                (self->base)->height = (uint32_t) PyLong_AsLong(height);
 } 

return 0; }
            static PyTypeObject PyVkExtent2DType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkExtent2D", sizeof(PyVkExtent2D), 0,
                (destructor)PyVkExtent2D_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkExtent2D object",0,0,0,0,0,0,0,0,
                PyVkExtent2D_getsetters,0,0,0,0,0,(initproc)PyVkExtent2D_init,0,PyVkExtent2D_new,};
        
            static void PyVkExtent3D_del(PyVkExtent3D* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkExtent3D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkExtent3D *self;
                self = (PyVkExtent3D *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkExtent3D));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkExtent3D");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkExtent3D_getwidth(PyVkExtent3D *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->width);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkExtent3D_getheight(PyVkExtent3D *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->height);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkExtent3D_getdepth(PyVkExtent3D *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->depth);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkExtent3D_getsetters[] = {
                
                    { "width", (getter)PyVkExtent3D_getwidth, NULL, "", NULL},
                
                    { "height", (getter)PyVkExtent3D_getheight, NULL, "", NULL},
                
                    { "depth", (getter)PyVkExtent3D_getdepth, NULL, "", NULL},
                {NULL}};

            static int
            PyVkExtent3D_init(PyVkExtent3D *self, PyObject *args, PyObject *kwds) {
            PyObject* width = NULL;
PyObject* height = NULL;
PyObject* depth = NULL;
static char *kwlist[] = {"width","height","depth",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &width, &height, &depth)) return -1;

                if (width != NULL && width != Py_None) {
                (self->base)->width = (uint32_t) PyLong_AsLong(width);
 } 

                if (height != NULL && height != Py_None) {
                (self->base)->height = (uint32_t) PyLong_AsLong(height);
 } 

                if (depth != NULL && depth != Py_None) {
                (self->base)->depth = (uint32_t) PyLong_AsLong(depth);
 } 

return 0; }
            static PyTypeObject PyVkExtent3DType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkExtent3D", sizeof(PyVkExtent3D), 0,
                (destructor)PyVkExtent3D_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkExtent3D object",0,0,0,0,0,0,0,0,
                PyVkExtent3D_getsetters,0,0,0,0,0,(initproc)PyVkExtent3D_init,0,PyVkExtent3D_new,};
        
            static void PyVkViewport_del(PyVkViewport* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkViewport_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkViewport *self;
                self = (PyVkViewport *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkViewport));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkViewport");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkViewport_getx(PyVkViewport *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->x);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkViewport_gety(PyVkViewport *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->y);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkViewport_getwidth(PyVkViewport *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->width);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkViewport_getheight(PyVkViewport *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->height);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkViewport_getminDepth(PyVkViewport *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->minDepth);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkViewport_getmaxDepth(PyVkViewport *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->maxDepth);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkViewport_getsetters[] = {
                
                    { "x", (getter)PyVkViewport_getx, NULL, "", NULL},
                
                    { "y", (getter)PyVkViewport_gety, NULL, "", NULL},
                
                    { "width", (getter)PyVkViewport_getwidth, NULL, "", NULL},
                
                    { "height", (getter)PyVkViewport_getheight, NULL, "", NULL},
                
                    { "minDepth", (getter)PyVkViewport_getminDepth, NULL, "", NULL},
                
                    { "maxDepth", (getter)PyVkViewport_getmaxDepth, NULL, "", NULL},
                {NULL}};

            static int
            PyVkViewport_init(PyVkViewport *self, PyObject *args, PyObject *kwds) {
            PyObject* x = NULL;
PyObject* y = NULL;
PyObject* width = NULL;
PyObject* height = NULL;
PyObject* minDepth = NULL;
PyObject* maxDepth = NULL;
static char *kwlist[] = {"x","y","width","height","minDepth","maxDepth",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOO", kwlist, &x, &y, &width, &height, &minDepth, &maxDepth)) return -1;

                if (x != NULL && x != Py_None) {
                (self->base)->x = (float) PyFloat_AsDouble(x);
 } 

                if (y != NULL && y != Py_None) {
                (self->base)->y = (float) PyFloat_AsDouble(y);
 } 

                if (width != NULL && width != Py_None) {
                (self->base)->width = (float) PyFloat_AsDouble(width);
 } 

                if (height != NULL && height != Py_None) {
                (self->base)->height = (float) PyFloat_AsDouble(height);
 } 

                if (minDepth != NULL && minDepth != Py_None) {
                (self->base)->minDepth = (float) PyFloat_AsDouble(minDepth);
 } 

                if (maxDepth != NULL && maxDepth != Py_None) {
                (self->base)->maxDepth = (float) PyFloat_AsDouble(maxDepth);
 } 

return 0; }
            static PyTypeObject PyVkViewportType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkViewport", sizeof(PyVkViewport), 0,
                (destructor)PyVkViewport_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkViewport object",0,0,0,0,0,0,0,0,
                PyVkViewport_getsetters,0,0,0,0,0,(initproc)PyVkViewport_init,0,PyVkViewport_new,};
        
            static void PyVkRect2D_del(PyVkRect2D* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkRect2D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkRect2D *self;
                self = (PyVkRect2D *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkRect2D));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkRect2D");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkRect2D_getsetters[] = {
                {NULL}};

            static int
            PyVkRect2D_init(PyVkRect2D *self, PyObject *args, PyObject *kwds) {
            PyObject* offset = NULL;
PyObject* extent = NULL;
static char *kwlist[] = {"offset","extent",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OO", kwlist, &offset, &extent)) return -1;

                if (offset != NULL && offset != Py_None) {
                
                    (self->base)->offset = *(((PyVkOffset2D*)offset)->base);
                
 } 

                if (extent != NULL && extent != Py_None) {
                
                    (self->base)->extent = *(((PyVkExtent2D*)extent)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkRect2DType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkRect2D", sizeof(PyVkRect2D), 0,
                (destructor)PyVkRect2D_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkRect2D object",0,0,0,0,0,0,0,0,
                PyVkRect2D_getsetters,0,0,0,0,0,(initproc)PyVkRect2D_init,0,PyVkRect2D_new,};
        
#ifdef hackdefine

            static void PyVkRect3D_del(PyVkRect3D* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkRect3D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkRect3D *self;
                self = (PyVkRect3D *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkRect3D));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkRect3D");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkRect3D_getsetters[] = {
                {NULL}};

            static int
            PyVkRect3D_init(PyVkRect3D *self, PyObject *args, PyObject *kwds) {
            PyObject* offset = NULL;
PyObject* extent = NULL;
static char *kwlist[] = {"offset","extent",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OO", kwlist, &offset, &extent)) return -1;

                if (offset != NULL && offset != Py_None) {
                
                    (self->base)->offset = *(((PyVkOffset3D*)offset)->base);
                
 } 

                if (extent != NULL && extent != Py_None) {
                
                    (self->base)->extent = *(((PyVkExtent3D*)extent)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkRect3DType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkRect3D", sizeof(PyVkRect3D), 0,
                (destructor)PyVkRect3D_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkRect3D object",0,0,0,0,0,0,0,0,
                PyVkRect3D_getsetters,0,0,0,0,0,(initproc)PyVkRect3D_init,0,PyVkRect3D_new,};
        
#endif

            static void PyVkClearRect_del(PyVkClearRect* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkClearRect_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkClearRect *self;
                self = (PyVkClearRect *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkClearRect));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkClearRect");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkClearRect_getbaseArrayLayer(PyVkClearRect *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->baseArrayLayer);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkClearRect_getlayerCount(PyVkClearRect *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->layerCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkClearRect_getsetters[] = {
                
                    { "baseArrayLayer", (getter)PyVkClearRect_getbaseArrayLayer, NULL, "", NULL},
                
                    { "layerCount", (getter)PyVkClearRect_getlayerCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkClearRect_init(PyVkClearRect *self, PyObject *args, PyObject *kwds) {
            PyObject* rect = NULL;
PyObject* baseArrayLayer = NULL;
PyObject* layerCount = NULL;
static char *kwlist[] = {"rect","baseArrayLayer","layerCount",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &rect, &baseArrayLayer, &layerCount)) return -1;

                if (rect != NULL && rect != Py_None) {
                
                    (self->base)->rect = *(((PyVkRect2D*)rect)->base);
                
 } 

                if (baseArrayLayer != NULL && baseArrayLayer != Py_None) {
                (self->base)->baseArrayLayer = (uint32_t) PyLong_AsLong(baseArrayLayer);
 } 

                if (layerCount != NULL && layerCount != Py_None) {
                (self->base)->layerCount = (uint32_t) PyLong_AsLong(layerCount);
 } 

return 0; }
            static PyTypeObject PyVkClearRectType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkClearRect", sizeof(PyVkClearRect), 0,
                (destructor)PyVkClearRect_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkClearRect object",0,0,0,0,0,0,0,0,
                PyVkClearRect_getsetters,0,0,0,0,0,(initproc)PyVkClearRect_init,0,PyVkClearRect_new,};
        
            static void PyVkComponentMapping_del(PyVkComponentMapping* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkComponentMapping_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkComponentMapping *self;
                self = (PyVkComponentMapping *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkComponentMapping));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkComponentMapping");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkComponentMapping_getsetters[] = {
                {NULL}};

            static int
            PyVkComponentMapping_init(PyVkComponentMapping *self, PyObject *args, PyObject *kwds) {
            PyObject* r = NULL;
PyObject* g = NULL;
PyObject* b = NULL;
PyObject* a = NULL;
static char *kwlist[] = {"r","g","b","a",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &r, &g, &b, &a)) return -1;

                if (r != NULL && r != Py_None) {
                
                    (self->base)->r = PyLong_AsLong(r);
                
 } 

                if (g != NULL && g != Py_None) {
                
                    (self->base)->g = PyLong_AsLong(g);
                
 } 

                if (b != NULL && b != Py_None) {
                
                    (self->base)->b = PyLong_AsLong(b);
                
 } 

                if (a != NULL && a != Py_None) {
                
                    (self->base)->a = PyLong_AsLong(a);
                
 } 

return 0; }
            static PyTypeObject PyVkComponentMappingType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkComponentMapping", sizeof(PyVkComponentMapping), 0,
                (destructor)PyVkComponentMapping_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkComponentMapping object",0,0,0,0,0,0,0,0,
                PyVkComponentMapping_getsetters,0,0,0,0,0,(initproc)PyVkComponentMapping_init,0,PyVkComponentMapping_new,};
        
            static void PyVkPhysicalDeviceProperties_del(PyVkPhysicalDeviceProperties* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPhysicalDeviceProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPhysicalDeviceProperties *self;
                self = (PyVkPhysicalDeviceProperties *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPhysicalDeviceProperties));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPhysicalDeviceProperties");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPhysicalDeviceProperties_getapiVersion(PyVkPhysicalDeviceProperties *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->apiVersion);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceProperties_getdriverVersion(PyVkPhysicalDeviceProperties *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->driverVersion);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceProperties_getvendorID(PyVkPhysicalDeviceProperties *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->vendorID);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceProperties_getdeviceID(PyVkPhysicalDeviceProperties *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->deviceID);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceProperties_getdeviceName(PyVkPhysicalDeviceProperties *self, void *closure){
            PyObject* value = PyUnicode_FromString((const char *) (self->base)->deviceName);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceProperties_getpipelineCacheUUID(PyVkPhysicalDeviceProperties *self, void *closure){
            
        PyObject* value = PyList_New(0);
        int nb = sizeof((self->base)->pipelineCacheUUID) / sizeof((self->base)->pipelineCacheUUID[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* py_tmp = PyLong_FromLong((long) (self->base)->pipelineCacheUUID[i]);
            PyList_Append(value, py_tmp);
        }
        
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPhysicalDeviceProperties_getsetters[] = {
                
                    { "apiVersion", (getter)PyVkPhysicalDeviceProperties_getapiVersion, NULL, "", NULL},
                
                    { "driverVersion", (getter)PyVkPhysicalDeviceProperties_getdriverVersion, NULL, "", NULL},
                
                    { "vendorID", (getter)PyVkPhysicalDeviceProperties_getvendorID, NULL, "", NULL},
                
                    { "deviceID", (getter)PyVkPhysicalDeviceProperties_getdeviceID, NULL, "", NULL},
                
                    { "deviceName", (getter)PyVkPhysicalDeviceProperties_getdeviceName, NULL, "", NULL},
                
                    { "pipelineCacheUUID", (getter)PyVkPhysicalDeviceProperties_getpipelineCacheUUID, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPhysicalDeviceProperties_init(PyVkPhysicalDeviceProperties *self, PyObject *args, PyObject *kwds) {
            return 0; }
            static PyTypeObject PyVkPhysicalDevicePropertiesType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPhysicalDeviceProperties", sizeof(PyVkPhysicalDeviceProperties), 0,
                (destructor)PyVkPhysicalDeviceProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPhysicalDeviceProperties object",0,0,0,0,0,0,0,0,
                PyVkPhysicalDeviceProperties_getsetters,0,0,0,0,0,(initproc)PyVkPhysicalDeviceProperties_init,0,PyVkPhysicalDeviceProperties_new,};
        
            static void PyVkExtensionProperties_del(PyVkExtensionProperties* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkExtensionProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkExtensionProperties *self;
                self = (PyVkExtensionProperties *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkExtensionProperties));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkExtensionProperties");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkExtensionProperties_getextensionName(PyVkExtensionProperties *self, void *closure){
            PyObject* value = PyUnicode_FromString((const char *) (self->base)->extensionName);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkExtensionProperties_getspecVersion(PyVkExtensionProperties *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->specVersion);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkExtensionProperties_getsetters[] = {
                
                    { "extensionName", (getter)PyVkExtensionProperties_getextensionName, NULL, "", NULL},
                
                    { "specVersion", (getter)PyVkExtensionProperties_getspecVersion, NULL, "", NULL},
                {NULL}};

            static int
            PyVkExtensionProperties_init(PyVkExtensionProperties *self, PyObject *args, PyObject *kwds) {
            return 0; }
            static PyTypeObject PyVkExtensionPropertiesType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkExtensionProperties", sizeof(PyVkExtensionProperties), 0,
                (destructor)PyVkExtensionProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkExtensionProperties object",0,0,0,0,0,0,0,0,
                PyVkExtensionProperties_getsetters,0,0,0,0,0,(initproc)PyVkExtensionProperties_init,0,PyVkExtensionProperties_new,};
        
            static void PyVkLayerProperties_del(PyVkLayerProperties* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkLayerProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkLayerProperties *self;
                self = (PyVkLayerProperties *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkLayerProperties));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkLayerProperties");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkLayerProperties_getlayerName(PyVkLayerProperties *self, void *closure){
            PyObject* value = PyUnicode_FromString((const char *) (self->base)->layerName);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkLayerProperties_getspecVersion(PyVkLayerProperties *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->specVersion);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkLayerProperties_getimplementationVersion(PyVkLayerProperties *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->implementationVersion);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkLayerProperties_getdescription(PyVkLayerProperties *self, void *closure){
            PyObject* value = PyUnicode_FromString((const char *) (self->base)->description);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkLayerProperties_getsetters[] = {
                
                    { "layerName", (getter)PyVkLayerProperties_getlayerName, NULL, "", NULL},
                
                    { "specVersion", (getter)PyVkLayerProperties_getspecVersion, NULL, "", NULL},
                
                    { "implementationVersion", (getter)PyVkLayerProperties_getimplementationVersion, NULL, "", NULL},
                
                    { "description", (getter)PyVkLayerProperties_getdescription, NULL, "", NULL},
                {NULL}};

            static int
            PyVkLayerProperties_init(PyVkLayerProperties *self, PyObject *args, PyObject *kwds) {
            return 0; }
            static PyTypeObject PyVkLayerPropertiesType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkLayerProperties", sizeof(PyVkLayerProperties), 0,
                (destructor)PyVkLayerProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkLayerProperties object",0,0,0,0,0,0,0,0,
                PyVkLayerProperties_getsetters,0,0,0,0,0,(initproc)PyVkLayerProperties_init,0,PyVkLayerProperties_new,};
        
            static void PyVkApplicationInfo_del(PyVkApplicationInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkApplicationInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkApplicationInfo *self;
                self = (PyVkApplicationInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkApplicationInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkApplicationInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkApplicationInfo_getpNext(PyVkApplicationInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkApplicationInfo_getpApplicationName(PyVkApplicationInfo *self, void *closure){
            PyObject* value = PyUnicode_FromString((const char *) (self->base)->pApplicationName);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkApplicationInfo_getapplicationVersion(PyVkApplicationInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->applicationVersion);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkApplicationInfo_getpEngineName(PyVkApplicationInfo *self, void *closure){
            PyObject* value = PyUnicode_FromString((const char *) (self->base)->pEngineName);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkApplicationInfo_getengineVersion(PyVkApplicationInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->engineVersion);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkApplicationInfo_getapiVersion(PyVkApplicationInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->apiVersion);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkApplicationInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkApplicationInfo_getpNext, NULL, "", NULL},
                
                    { "pApplicationName", (getter)PyVkApplicationInfo_getpApplicationName, NULL, "", NULL},
                
                    { "applicationVersion", (getter)PyVkApplicationInfo_getapplicationVersion, NULL, "", NULL},
                
                    { "pEngineName", (getter)PyVkApplicationInfo_getpEngineName, NULL, "", NULL},
                
                    { "engineVersion", (getter)PyVkApplicationInfo_getengineVersion, NULL, "", NULL},
                
                    { "apiVersion", (getter)PyVkApplicationInfo_getapiVersion, NULL, "", NULL},
                {NULL}};

            static int
            PyVkApplicationInfo_init(PyVkApplicationInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* pApplicationName = NULL;
PyObject* applicationVersion = NULL;
PyObject* pEngineName = NULL;
PyObject* engineVersion = NULL;
PyObject* apiVersion = NULL;
static char *kwlist[] = {"sType","pNext","pApplicationName","applicationVersion","pEngineName","engineVersion","apiVersion",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOO", kwlist, &sType, &pNext, &pApplicationName, &applicationVersion, &pEngineName, &engineVersion, &apiVersion)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (pApplicationName != NULL && pApplicationName != Py_None) {
                
        PyObject * tmp58762925 = PyUnicode_AsASCIIString(pApplicationName);
        char* tmp59430983 = PyBytes_AsString(tmp58762925);
        strcpy((self->base)->pApplicationName, tmp59430983);
        Py_DECREF(tmp58762925);
        
 } 

                if (applicationVersion != NULL && applicationVersion != Py_None) {
                (self->base)->applicationVersion = (uint32_t) PyLong_AsLong(applicationVersion);
 } 

                if (pEngineName != NULL && pEngineName != Py_None) {
                
        PyObject * tmp26963750 = PyUnicode_AsASCIIString(pEngineName);
        char* tmp75917554 = PyBytes_AsString(tmp26963750);
        strcpy((self->base)->pEngineName, tmp75917554);
        Py_DECREF(tmp26963750);
        
 } 

                if (engineVersion != NULL && engineVersion != Py_None) {
                (self->base)->engineVersion = (uint32_t) PyLong_AsLong(engineVersion);
 } 

                if (apiVersion != NULL && apiVersion != Py_None) {
                (self->base)->apiVersion = (uint32_t) PyLong_AsLong(apiVersion);
 } 

return 0; }
            static PyTypeObject PyVkApplicationInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkApplicationInfo", sizeof(PyVkApplicationInfo), 0,
                (destructor)PyVkApplicationInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkApplicationInfo object",0,0,0,0,0,0,0,0,
                PyVkApplicationInfo_getsetters,0,0,0,0,0,(initproc)PyVkApplicationInfo_init,0,PyVkApplicationInfo_new,};
        
            static void PyVkAllocationCallbacks_del(PyVkAllocationCallbacks* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkAllocationCallbacks_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkAllocationCallbacks *self;
                self = (PyVkAllocationCallbacks *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkAllocationCallbacks));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkAllocationCallbacks");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkAllocationCallbacks_getpUserData(PyVkAllocationCallbacks *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkAllocationCallbacks_getsetters[] = {
                
                    { "pUserData", (getter)PyVkAllocationCallbacks_getpUserData, NULL, "", NULL},
                {NULL}};

            static int
            PyVkAllocationCallbacks_init(PyVkAllocationCallbacks *self, PyObject *args, PyObject *kwds) {
            PyObject* pUserData = NULL;
PyObject* pfnAllocation = NULL;
PyObject* pfnReallocation = NULL;
PyObject* pfnFree = NULL;
PyObject* pfnInternalAllocation = NULL;
PyObject* pfnInternalFree = NULL;
static char *kwlist[] = {"pUserData","pfnAllocation","pfnReallocation","pfnFree","pfnInternalAllocation","pfnInternalFree",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOO", kwlist, &pUserData, &pfnAllocation, &pfnReallocation, &pfnFree, &pfnInternalAllocation, &pfnInternalFree)) return -1;

                if (pUserData != NULL && pUserData != Py_None) {
                (self->base)->pUserData = NULL;
 } 

return 0; }
            static PyTypeObject PyVkAllocationCallbacksType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkAllocationCallbacks", sizeof(PyVkAllocationCallbacks), 0,
                (destructor)PyVkAllocationCallbacks_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkAllocationCallbacks object",0,0,0,0,0,0,0,0,
                PyVkAllocationCallbacks_getsetters,0,0,0,0,0,(initproc)PyVkAllocationCallbacks_init,0,PyVkAllocationCallbacks_new,};
        
            static void PyVkDeviceQueueCreateInfo_del(PyVkDeviceQueueCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDeviceQueueCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDeviceQueueCreateInfo *self;
                self = (PyVkDeviceQueueCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDeviceQueueCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDeviceQueueCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDeviceQueueCreateInfo_getpNext(PyVkDeviceQueueCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDeviceQueueCreateInfo_getqueueFamilyIndex(PyVkDeviceQueueCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->queueFamilyIndex);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDeviceQueueCreateInfo_getqueueCount(PyVkDeviceQueueCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->queueCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDeviceQueueCreateInfo_getpQueuePriorities(PyVkDeviceQueueCreateInfo *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (*((self->base)->pQueuePriorities)));
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDeviceQueueCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkDeviceQueueCreateInfo_getpNext, NULL, "", NULL},
                
                    { "queueFamilyIndex", (getter)PyVkDeviceQueueCreateInfo_getqueueFamilyIndex, NULL, "", NULL},
                
                    { "queueCount", (getter)PyVkDeviceQueueCreateInfo_getqueueCount, NULL, "", NULL},
                
                    { "pQueuePriorities", (getter)PyVkDeviceQueueCreateInfo_getpQueuePriorities, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDeviceQueueCreateInfo_init(PyVkDeviceQueueCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* queueFamilyIndex = NULL;
PyObject* queueCount = NULL;
PyObject* pQueuePriorities = NULL;
static char *kwlist[] = {"sType","pNext","flags","queueFamilyIndex","queueCount","pQueuePriorities",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOO", kwlist, &sType, &pNext, &flags, &queueFamilyIndex, &queueCount, &pQueuePriorities)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (queueFamilyIndex != NULL && queueFamilyIndex != Py_None) {
                (self->base)->queueFamilyIndex = (uint32_t) PyLong_AsLong(queueFamilyIndex);
 } 

                if (queueCount != NULL && queueCount != Py_None) {
                (self->base)->queueCount = (uint32_t) PyLong_AsLong(queueCount);
 } 

                if (pQueuePriorities != NULL && pQueuePriorities != Py_None) {
                
        float tmp96827622 = (float) PyFloat_AsDouble(pQueuePriorities);
        float *tmp50573123 = malloc(sizeof(float));
        memcpy(tmp50573123, &tmp96827622, sizeof(float));
        (self->base)->pQueuePriorities = tmp50573123;
        
 } 

return 0; }
            static PyTypeObject PyVkDeviceQueueCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDeviceQueueCreateInfo", sizeof(PyVkDeviceQueueCreateInfo), 0,
                (destructor)PyVkDeviceQueueCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDeviceQueueCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkDeviceQueueCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkDeviceQueueCreateInfo_init,0,PyVkDeviceQueueCreateInfo_new,};
        
            static void PyVkDeviceCreateInfo_del(PyVkDeviceCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDeviceCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDeviceCreateInfo *self;
                self = (PyVkDeviceCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDeviceCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDeviceCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDeviceCreateInfo_getpNext(PyVkDeviceCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDeviceCreateInfo_getqueueCreateInfoCount(PyVkDeviceCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->queueCreateInfoCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDeviceCreateInfo_getenabledLayerCount(PyVkDeviceCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->enabledLayerCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDeviceCreateInfo_getppEnabledLayerNames(PyVkDeviceCreateInfo *self, void *closure){
            
        if ((self->base)->ppEnabledLayerNames[0] == NULL) return PyList_New(0);;
        PyObject* value = PyList_New(0);
        int i = 0;
        while ((self->base)->ppEnabledLayerNames[i] != NULL) {
            PyObject* py_tmp = PyUnicode_FromString((const char *) (self->base)->ppEnabledLayerNames[i]);
            PyList_Append(value, py_tmp);
            i++;
        }
        
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDeviceCreateInfo_getenabledExtensionCount(PyVkDeviceCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->enabledExtensionCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDeviceCreateInfo_getppEnabledExtensionNames(PyVkDeviceCreateInfo *self, void *closure){
            
        if ((self->base)->ppEnabledExtensionNames[0] == NULL) return PyList_New(0);;
        PyObject* value = PyList_New(0);
        int i = 0;
        while ((self->base)->ppEnabledExtensionNames[i] != NULL) {
            PyObject* py_tmp = PyUnicode_FromString((const char *) (self->base)->ppEnabledExtensionNames[i]);
            PyList_Append(value, py_tmp);
            i++;
        }
        
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDeviceCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkDeviceCreateInfo_getpNext, NULL, "", NULL},
                
                    { "queueCreateInfoCount", (getter)PyVkDeviceCreateInfo_getqueueCreateInfoCount, NULL, "", NULL},
                
                    { "enabledLayerCount", (getter)PyVkDeviceCreateInfo_getenabledLayerCount, NULL, "", NULL},
                
                    { "ppEnabledLayerNames", (getter)PyVkDeviceCreateInfo_getppEnabledLayerNames, NULL, "", NULL},
                
                    { "enabledExtensionCount", (getter)PyVkDeviceCreateInfo_getenabledExtensionCount, NULL, "", NULL},
                
                    { "ppEnabledExtensionNames", (getter)PyVkDeviceCreateInfo_getppEnabledExtensionNames, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDeviceCreateInfo_init(PyVkDeviceCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* queueCreateInfoCount = NULL;
PyObject* pQueueCreateInfos = NULL;
PyObject* enabledLayerCount = NULL;
PyObject* ppEnabledLayerNames = NULL;
PyObject* enabledExtensionCount = NULL;
PyObject* ppEnabledExtensionNames = NULL;
PyObject* pEnabledFeatures = NULL;
static char *kwlist[] = {"sType","pNext","flags","queueCreateInfoCount","pQueueCreateInfos","enabledLayerCount","ppEnabledLayerNames","enabledExtensionCount","ppEnabledExtensionNames","pEnabledFeatures",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOOO", kwlist, &sType, &pNext, &flags, &queueCreateInfoCount, &pQueueCreateInfos, &enabledLayerCount, &ppEnabledLayerNames, &enabledExtensionCount, &ppEnabledExtensionNames, &pEnabledFeatures)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (queueCreateInfoCount != NULL && queueCreateInfoCount != Py_None) {
                (self->base)->queueCreateInfoCount = (uint32_t) PyLong_AsLong(queueCreateInfoCount);
 } 

                if (pQueueCreateInfos != NULL && pQueueCreateInfos != Py_None) {
                
                    (self->base)->pQueueCreateInfos = (((PyVkDeviceQueueCreateInfo*)pQueueCreateInfos)->base);
                
 } 

                if (enabledLayerCount != NULL && enabledLayerCount != Py_None) {
                (self->base)->enabledLayerCount = (uint32_t) PyLong_AsLong(enabledLayerCount);
 } 

                if (ppEnabledLayerNames != NULL && ppEnabledLayerNames != Py_None) {
                
        int tmp7834791 = PyList_Size(ppEnabledLayerNames);
        char** tmp75460728 = malloc(sizeof(char*)*tmp7834791 + 1);
        int tmp41519311;
        for (tmp41519311 = 0; tmp41519311 < tmp7834791; tmp41519311++) {
            PyObject* ascii_str = PyUnicode_AsASCIIString(
            PyList_GetItem(ppEnabledLayerNames, tmp41519311));
            char* tmp2 = PyBytes_AsString(ascii_str);
            tmp75460728[tmp41519311] = strdup(tmp2);
            Py_DECREF(ascii_str);
        }
        tmp75460728[tmp41519311] = NULL; // sentinel
        (self->base)->ppEnabledLayerNames = tmp75460728;
        
 } 

                if (enabledExtensionCount != NULL && enabledExtensionCount != Py_None) {
                (self->base)->enabledExtensionCount = (uint32_t) PyLong_AsLong(enabledExtensionCount);
 } 

                if (ppEnabledExtensionNames != NULL && ppEnabledExtensionNames != Py_None) {
                
        int tmp3082241 = PyList_Size(ppEnabledExtensionNames);
        char** tmp14915604 = malloc(sizeof(char*)*tmp3082241 + 1);
        int tmp73776868;
        for (tmp73776868 = 0; tmp73776868 < tmp3082241; tmp73776868++) {
            PyObject* ascii_str = PyUnicode_AsASCIIString(
            PyList_GetItem(ppEnabledExtensionNames, tmp73776868));
            char* tmp2 = PyBytes_AsString(ascii_str);
            tmp14915604[tmp73776868] = strdup(tmp2);
            Py_DECREF(ascii_str);
        }
        tmp14915604[tmp73776868] = NULL; // sentinel
        (self->base)->ppEnabledExtensionNames = tmp14915604;
        
 } 

                if (pEnabledFeatures != NULL && pEnabledFeatures != Py_None) {
                
                    (self->base)->pEnabledFeatures = (((PyVkPhysicalDeviceFeatures*)pEnabledFeatures)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkDeviceCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDeviceCreateInfo", sizeof(PyVkDeviceCreateInfo), 0,
                (destructor)PyVkDeviceCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDeviceCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkDeviceCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkDeviceCreateInfo_init,0,PyVkDeviceCreateInfo_new,};
        
            static void PyVkInstanceCreateInfo_del(PyVkInstanceCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkInstanceCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkInstanceCreateInfo *self;
                self = (PyVkInstanceCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkInstanceCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkInstanceCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkInstanceCreateInfo_getpNext(PyVkInstanceCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkInstanceCreateInfo_getenabledLayerCount(PyVkInstanceCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->enabledLayerCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkInstanceCreateInfo_getppEnabledLayerNames(PyVkInstanceCreateInfo *self, void *closure){
            
        if ((self->base)->ppEnabledLayerNames[0] == NULL) return PyList_New(0);;
        PyObject* value = PyList_New(0);
        int i = 0;
        while ((self->base)->ppEnabledLayerNames[i] != NULL) {
            PyObject* py_tmp = PyUnicode_FromString((const char *) (self->base)->ppEnabledLayerNames[i]);
            PyList_Append(value, py_tmp);
            i++;
        }
        
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkInstanceCreateInfo_getenabledExtensionCount(PyVkInstanceCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->enabledExtensionCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkInstanceCreateInfo_getppEnabledExtensionNames(PyVkInstanceCreateInfo *self, void *closure){
            
        if ((self->base)->ppEnabledExtensionNames[0] == NULL) return PyList_New(0);;
        PyObject* value = PyList_New(0);
        int i = 0;
        while ((self->base)->ppEnabledExtensionNames[i] != NULL) {
            PyObject* py_tmp = PyUnicode_FromString((const char *) (self->base)->ppEnabledExtensionNames[i]);
            PyList_Append(value, py_tmp);
            i++;
        }
        
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkInstanceCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkInstanceCreateInfo_getpNext, NULL, "", NULL},
                
                    { "enabledLayerCount", (getter)PyVkInstanceCreateInfo_getenabledLayerCount, NULL, "", NULL},
                
                    { "ppEnabledLayerNames", (getter)PyVkInstanceCreateInfo_getppEnabledLayerNames, NULL, "", NULL},
                
                    { "enabledExtensionCount", (getter)PyVkInstanceCreateInfo_getenabledExtensionCount, NULL, "", NULL},
                
                    { "ppEnabledExtensionNames", (getter)PyVkInstanceCreateInfo_getppEnabledExtensionNames, NULL, "", NULL},
                {NULL}};

            static int
            PyVkInstanceCreateInfo_init(PyVkInstanceCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* pApplicationInfo = NULL;
PyObject* enabledLayerCount = NULL;
PyObject* ppEnabledLayerNames = NULL;
PyObject* enabledExtensionCount = NULL;
PyObject* ppEnabledExtensionNames = NULL;
static char *kwlist[] = {"sType","pNext","flags","pApplicationInfo","enabledLayerCount","ppEnabledLayerNames","enabledExtensionCount","ppEnabledExtensionNames",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOO", kwlist, &sType, &pNext, &flags, &pApplicationInfo, &enabledLayerCount, &ppEnabledLayerNames, &enabledExtensionCount, &ppEnabledExtensionNames)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (pApplicationInfo != NULL && pApplicationInfo != Py_None) {
                
                    (self->base)->pApplicationInfo = (((PyVkApplicationInfo*)pApplicationInfo)->base);
                
 } 

                if (enabledLayerCount != NULL && enabledLayerCount != Py_None) {
                (self->base)->enabledLayerCount = (uint32_t) PyLong_AsLong(enabledLayerCount);
 } 

                if (ppEnabledLayerNames != NULL && ppEnabledLayerNames != Py_None) {
                
        int tmp30565252 = PyList_Size(ppEnabledLayerNames);
        char** tmp7669114 = malloc(sizeof(char*)*tmp30565252 + 1);
        int tmp35779376;
        for (tmp35779376 = 0; tmp35779376 < tmp30565252; tmp35779376++) {
            PyObject* ascii_str = PyUnicode_AsASCIIString(
            PyList_GetItem(ppEnabledLayerNames, tmp35779376));
            char* tmp2 = PyBytes_AsString(ascii_str);
            tmp7669114[tmp35779376] = strdup(tmp2);
            Py_DECREF(ascii_str);
        }
        tmp7669114[tmp35779376] = NULL; // sentinel
        (self->base)->ppEnabledLayerNames = tmp7669114;
        
 } 

                if (enabledExtensionCount != NULL && enabledExtensionCount != Py_None) {
                (self->base)->enabledExtensionCount = (uint32_t) PyLong_AsLong(enabledExtensionCount);
 } 

                if (ppEnabledExtensionNames != NULL && ppEnabledExtensionNames != Py_None) {
                
        int tmp39902083 = PyList_Size(ppEnabledExtensionNames);
        char** tmp66086341 = malloc(sizeof(char*)*tmp39902083 + 1);
        int tmp42587824;
        for (tmp42587824 = 0; tmp42587824 < tmp39902083; tmp42587824++) {
            PyObject* ascii_str = PyUnicode_AsASCIIString(
            PyList_GetItem(ppEnabledExtensionNames, tmp42587824));
            char* tmp2 = PyBytes_AsString(ascii_str);
            tmp66086341[tmp42587824] = strdup(tmp2);
            Py_DECREF(ascii_str);
        }
        tmp66086341[tmp42587824] = NULL; // sentinel
        (self->base)->ppEnabledExtensionNames = tmp66086341;
        
 } 

return 0; }
            static PyTypeObject PyVkInstanceCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkInstanceCreateInfo", sizeof(PyVkInstanceCreateInfo), 0,
                (destructor)PyVkInstanceCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkInstanceCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkInstanceCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkInstanceCreateInfo_init,0,PyVkInstanceCreateInfo_new,};
        
            static void PyVkQueueFamilyProperties_del(PyVkQueueFamilyProperties* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkQueueFamilyProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkQueueFamilyProperties *self;
                self = (PyVkQueueFamilyProperties *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkQueueFamilyProperties));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkQueueFamilyProperties");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkQueueFamilyProperties_getqueueCount(PyVkQueueFamilyProperties *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->queueCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkQueueFamilyProperties_gettimestampValidBits(PyVkQueueFamilyProperties *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->timestampValidBits);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkQueueFamilyProperties_getsetters[] = {
                
                    { "queueCount", (getter)PyVkQueueFamilyProperties_getqueueCount, NULL, "", NULL},
                
                    { "timestampValidBits", (getter)PyVkQueueFamilyProperties_gettimestampValidBits, NULL, "", NULL},
                {NULL}};

            static int
            PyVkQueueFamilyProperties_init(PyVkQueueFamilyProperties *self, PyObject *args, PyObject *kwds) {
            return 0; }
            static PyTypeObject PyVkQueueFamilyPropertiesType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkQueueFamilyProperties", sizeof(PyVkQueueFamilyProperties), 0,
                (destructor)PyVkQueueFamilyProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkQueueFamilyProperties object",0,0,0,0,0,0,0,0,
                PyVkQueueFamilyProperties_getsetters,0,0,0,0,0,(initproc)PyVkQueueFamilyProperties_init,0,PyVkQueueFamilyProperties_new,};
        
            static void PyVkPhysicalDeviceMemoryProperties_del(PyVkPhysicalDeviceMemoryProperties* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPhysicalDeviceMemoryProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPhysicalDeviceMemoryProperties *self;
                self = (PyVkPhysicalDeviceMemoryProperties *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPhysicalDeviceMemoryProperties));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPhysicalDeviceMemoryProperties");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPhysicalDeviceMemoryProperties_getmemoryTypeCount(PyVkPhysicalDeviceMemoryProperties *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->memoryTypeCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceMemoryProperties_getmemoryHeapCount(PyVkPhysicalDeviceMemoryProperties *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->memoryHeapCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPhysicalDeviceMemoryProperties_getsetters[] = {
                
                    { "memoryTypeCount", (getter)PyVkPhysicalDeviceMemoryProperties_getmemoryTypeCount, NULL, "", NULL},
                
                    { "memoryHeapCount", (getter)PyVkPhysicalDeviceMemoryProperties_getmemoryHeapCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPhysicalDeviceMemoryProperties_init(PyVkPhysicalDeviceMemoryProperties *self, PyObject *args, PyObject *kwds) {
            return 0; }
            static PyTypeObject PyVkPhysicalDeviceMemoryPropertiesType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPhysicalDeviceMemoryProperties", sizeof(PyVkPhysicalDeviceMemoryProperties), 0,
                (destructor)PyVkPhysicalDeviceMemoryProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPhysicalDeviceMemoryProperties object",0,0,0,0,0,0,0,0,
                PyVkPhysicalDeviceMemoryProperties_getsetters,0,0,0,0,0,(initproc)PyVkPhysicalDeviceMemoryProperties_init,0,PyVkPhysicalDeviceMemoryProperties_new,};
        
            static void PyVkMemoryAllocateInfo_del(PyVkMemoryAllocateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkMemoryAllocateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkMemoryAllocateInfo *self;
                self = (PyVkMemoryAllocateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkMemoryAllocateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkMemoryAllocateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkMemoryAllocateInfo_getpNext(PyVkMemoryAllocateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkMemoryAllocateInfo_getmemoryTypeIndex(PyVkMemoryAllocateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->memoryTypeIndex);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkMemoryAllocateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkMemoryAllocateInfo_getpNext, NULL, "", NULL},
                
                    { "memoryTypeIndex", (getter)PyVkMemoryAllocateInfo_getmemoryTypeIndex, NULL, "", NULL},
                {NULL}};

            static int
            PyVkMemoryAllocateInfo_init(PyVkMemoryAllocateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* allocationSize = NULL;
PyObject* memoryTypeIndex = NULL;
static char *kwlist[] = {"sType","pNext","allocationSize","memoryTypeIndex",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &sType, &pNext, &allocationSize, &memoryTypeIndex)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (allocationSize != NULL && allocationSize != Py_None) {
                
                    (self->base)->allocationSize = PyLong_AsLong(allocationSize);
                
 } 

                if (memoryTypeIndex != NULL && memoryTypeIndex != Py_None) {
                (self->base)->memoryTypeIndex = (uint32_t) PyLong_AsLong(memoryTypeIndex);
 } 

return 0; }
            static PyTypeObject PyVkMemoryAllocateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkMemoryAllocateInfo", sizeof(PyVkMemoryAllocateInfo), 0,
                (destructor)PyVkMemoryAllocateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkMemoryAllocateInfo object",0,0,0,0,0,0,0,0,
                PyVkMemoryAllocateInfo_getsetters,0,0,0,0,0,(initproc)PyVkMemoryAllocateInfo_init,0,PyVkMemoryAllocateInfo_new,};
        
            static void PyVkMemoryRequirements_del(PyVkMemoryRequirements* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkMemoryRequirements_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkMemoryRequirements *self;
                self = (PyVkMemoryRequirements *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkMemoryRequirements));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkMemoryRequirements");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkMemoryRequirements_getmemoryTypeBits(PyVkMemoryRequirements *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->memoryTypeBits);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkMemoryRequirements_getsetters[] = {
                
                    { "memoryTypeBits", (getter)PyVkMemoryRequirements_getmemoryTypeBits, NULL, "", NULL},
                {NULL}};

            static int
            PyVkMemoryRequirements_init(PyVkMemoryRequirements *self, PyObject *args, PyObject *kwds) {
            return 0; }
            static PyTypeObject PyVkMemoryRequirementsType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkMemoryRequirements", sizeof(PyVkMemoryRequirements), 0,
                (destructor)PyVkMemoryRequirements_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkMemoryRequirements object",0,0,0,0,0,0,0,0,
                PyVkMemoryRequirements_getsetters,0,0,0,0,0,(initproc)PyVkMemoryRequirements_init,0,PyVkMemoryRequirements_new,};
        
            static void PyVkSparseImageFormatProperties_del(PyVkSparseImageFormatProperties* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSparseImageFormatProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSparseImageFormatProperties *self;
                self = (PyVkSparseImageFormatProperties *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSparseImageFormatProperties));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSparseImageFormatProperties");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkSparseImageFormatProperties_getsetters[] = {
                {NULL}};

            static int
            PyVkSparseImageFormatProperties_init(PyVkSparseImageFormatProperties *self, PyObject *args, PyObject *kwds) {
            return 0; }
            static PyTypeObject PyVkSparseImageFormatPropertiesType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSparseImageFormatProperties", sizeof(PyVkSparseImageFormatProperties), 0,
                (destructor)PyVkSparseImageFormatProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSparseImageFormatProperties object",0,0,0,0,0,0,0,0,
                PyVkSparseImageFormatProperties_getsetters,0,0,0,0,0,(initproc)PyVkSparseImageFormatProperties_init,0,PyVkSparseImageFormatProperties_new,};
        
            static void PyVkSparseImageMemoryRequirements_del(PyVkSparseImageMemoryRequirements* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSparseImageMemoryRequirements_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSparseImageMemoryRequirements *self;
                self = (PyVkSparseImageMemoryRequirements *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSparseImageMemoryRequirements));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSparseImageMemoryRequirements");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkSparseImageMemoryRequirements_getimageMipTailFirstLod(PyVkSparseImageMemoryRequirements *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->imageMipTailFirstLod);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkSparseImageMemoryRequirements_getsetters[] = {
                
                    { "imageMipTailFirstLod", (getter)PyVkSparseImageMemoryRequirements_getimageMipTailFirstLod, NULL, "", NULL},
                {NULL}};

            static int
            PyVkSparseImageMemoryRequirements_init(PyVkSparseImageMemoryRequirements *self, PyObject *args, PyObject *kwds) {
            return 0; }
            static PyTypeObject PyVkSparseImageMemoryRequirementsType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSparseImageMemoryRequirements", sizeof(PyVkSparseImageMemoryRequirements), 0,
                (destructor)PyVkSparseImageMemoryRequirements_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSparseImageMemoryRequirements object",0,0,0,0,0,0,0,0,
                PyVkSparseImageMemoryRequirements_getsetters,0,0,0,0,0,(initproc)PyVkSparseImageMemoryRequirements_init,0,PyVkSparseImageMemoryRequirements_new,};
        
            static void PyVkMemoryType_del(PyVkMemoryType* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkMemoryType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkMemoryType *self;
                self = (PyVkMemoryType *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkMemoryType));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkMemoryType");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkMemoryType_getheapIndex(PyVkMemoryType *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->heapIndex);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkMemoryType_getsetters[] = {
                
                    { "heapIndex", (getter)PyVkMemoryType_getheapIndex, NULL, "", NULL},
                {NULL}};

            static int
            PyVkMemoryType_init(PyVkMemoryType *self, PyObject *args, PyObject *kwds) {
            return 0; }
            static PyTypeObject PyVkMemoryTypeType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkMemoryType", sizeof(PyVkMemoryType), 0,
                (destructor)PyVkMemoryType_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkMemoryType object",0,0,0,0,0,0,0,0,
                PyVkMemoryType_getsetters,0,0,0,0,0,(initproc)PyVkMemoryType_init,0,PyVkMemoryType_new,};
        
            static void PyVkMemoryHeap_del(PyVkMemoryHeap* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkMemoryHeap_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkMemoryHeap *self;
                self = (PyVkMemoryHeap *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkMemoryHeap));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkMemoryHeap");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkMemoryHeap_getsetters[] = {
                {NULL}};

            static int
            PyVkMemoryHeap_init(PyVkMemoryHeap *self, PyObject *args, PyObject *kwds) {
            return 0; }
            static PyTypeObject PyVkMemoryHeapType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkMemoryHeap", sizeof(PyVkMemoryHeap), 0,
                (destructor)PyVkMemoryHeap_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkMemoryHeap object",0,0,0,0,0,0,0,0,
                PyVkMemoryHeap_getsetters,0,0,0,0,0,(initproc)PyVkMemoryHeap_init,0,PyVkMemoryHeap_new,};
        
            static void PyVkMappedMemoryRange_del(PyVkMappedMemoryRange* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkMappedMemoryRange_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkMappedMemoryRange *self;
                self = (PyVkMappedMemoryRange *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkMappedMemoryRange));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkMappedMemoryRange");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkMappedMemoryRange_getpNext(PyVkMappedMemoryRange *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkMappedMemoryRange_getsetters[] = {
                
                    { "pNext", (getter)PyVkMappedMemoryRange_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkMappedMemoryRange_init(PyVkMappedMemoryRange *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* memory = NULL;
PyObject* offset = NULL;
PyObject* size = NULL;
static char *kwlist[] = {"sType","pNext","memory","offset","size",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &memory, &offset, &size)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (memory != NULL && memory != Py_None) {
                
                (self->base)->memory = PyCapsule_GetPointer(memory, "VkDeviceMemory");
            
 } 

                if (offset != NULL && offset != Py_None) {
                
                    (self->base)->offset = PyLong_AsLong(offset);
                
 } 

                if (size != NULL && size != Py_None) {
                
                    (self->base)->size = PyLong_AsLong(size);
                
 } 

return 0; }
            static PyTypeObject PyVkMappedMemoryRangeType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkMappedMemoryRange", sizeof(PyVkMappedMemoryRange), 0,
                (destructor)PyVkMappedMemoryRange_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkMappedMemoryRange object",0,0,0,0,0,0,0,0,
                PyVkMappedMemoryRange_getsetters,0,0,0,0,0,(initproc)PyVkMappedMemoryRange_init,0,PyVkMappedMemoryRange_new,};
        
            static void PyVkFormatProperties_del(PyVkFormatProperties* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkFormatProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkFormatProperties *self;
                self = (PyVkFormatProperties *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkFormatProperties));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkFormatProperties");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkFormatProperties_getsetters[] = {
                {NULL}};

            static int
            PyVkFormatProperties_init(PyVkFormatProperties *self, PyObject *args, PyObject *kwds) {
            return 0; }
            static PyTypeObject PyVkFormatPropertiesType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkFormatProperties", sizeof(PyVkFormatProperties), 0,
                (destructor)PyVkFormatProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkFormatProperties object",0,0,0,0,0,0,0,0,
                PyVkFormatProperties_getsetters,0,0,0,0,0,(initproc)PyVkFormatProperties_init,0,PyVkFormatProperties_new,};
        
            static void PyVkImageFormatProperties_del(PyVkImageFormatProperties* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkImageFormatProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkImageFormatProperties *self;
                self = (PyVkImageFormatProperties *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkImageFormatProperties));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageFormatProperties");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkImageFormatProperties_getmaxMipLevels(PyVkImageFormatProperties *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxMipLevels);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkImageFormatProperties_getmaxArrayLayers(PyVkImageFormatProperties *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxArrayLayers);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkImageFormatProperties_getsetters[] = {
                
                    { "maxMipLevels", (getter)PyVkImageFormatProperties_getmaxMipLevels, NULL, "", NULL},
                
                    { "maxArrayLayers", (getter)PyVkImageFormatProperties_getmaxArrayLayers, NULL, "", NULL},
                {NULL}};

            static int
            PyVkImageFormatProperties_init(PyVkImageFormatProperties *self, PyObject *args, PyObject *kwds) {
            return 0; }
            static PyTypeObject PyVkImageFormatPropertiesType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageFormatProperties", sizeof(PyVkImageFormatProperties), 0,
                (destructor)PyVkImageFormatProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageFormatProperties object",0,0,0,0,0,0,0,0,
                PyVkImageFormatProperties_getsetters,0,0,0,0,0,(initproc)PyVkImageFormatProperties_init,0,PyVkImageFormatProperties_new,};
        
            static void PyVkDescriptorBufferInfo_del(PyVkDescriptorBufferInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDescriptorBufferInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDescriptorBufferInfo *self;
                self = (PyVkDescriptorBufferInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDescriptorBufferInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDescriptorBufferInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkDescriptorBufferInfo_getsetters[] = {
                {NULL}};

            static int
            PyVkDescriptorBufferInfo_init(PyVkDescriptorBufferInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* buffer = NULL;
PyObject* offset = NULL;
PyObject* range = NULL;
static char *kwlist[] = {"buffer","offset","range",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &buffer, &offset, &range)) return -1;

                if (buffer != NULL && buffer != Py_None) {
                
                (self->base)->buffer = PyCapsule_GetPointer(buffer, "VkBuffer");
            
 } 

                if (offset != NULL && offset != Py_None) {
                
                    (self->base)->offset = PyLong_AsLong(offset);
                
 } 

                if (range != NULL && range != Py_None) {
                
                    (self->base)->range = PyLong_AsLong(range);
                
 } 

return 0; }
            static PyTypeObject PyVkDescriptorBufferInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDescriptorBufferInfo", sizeof(PyVkDescriptorBufferInfo), 0,
                (destructor)PyVkDescriptorBufferInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDescriptorBufferInfo object",0,0,0,0,0,0,0,0,
                PyVkDescriptorBufferInfo_getsetters,0,0,0,0,0,(initproc)PyVkDescriptorBufferInfo_init,0,PyVkDescriptorBufferInfo_new,};
        
            static void PyVkDescriptorImageInfo_del(PyVkDescriptorImageInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDescriptorImageInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDescriptorImageInfo *self;
                self = (PyVkDescriptorImageInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDescriptorImageInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDescriptorImageInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkDescriptorImageInfo_getsetters[] = {
                {NULL}};

            static int
            PyVkDescriptorImageInfo_init(PyVkDescriptorImageInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sampler = NULL;
PyObject* imageView = NULL;
PyObject* imageLayout = NULL;
static char *kwlist[] = {"sampler","imageView","imageLayout",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &sampler, &imageView, &imageLayout)) return -1;

                if (sampler != NULL && sampler != Py_None) {
                
                (self->base)->sampler = PyCapsule_GetPointer(sampler, "VkSampler");
            
 } 

                if (imageView != NULL && imageView != Py_None) {
                
                (self->base)->imageView = PyCapsule_GetPointer(imageView, "VkImageView");
            
 } 

                if (imageLayout != NULL && imageLayout != Py_None) {
                
                    (self->base)->imageLayout = PyLong_AsLong(imageLayout);
                
 } 

return 0; }
            static PyTypeObject PyVkDescriptorImageInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDescriptorImageInfo", sizeof(PyVkDescriptorImageInfo), 0,
                (destructor)PyVkDescriptorImageInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDescriptorImageInfo object",0,0,0,0,0,0,0,0,
                PyVkDescriptorImageInfo_getsetters,0,0,0,0,0,(initproc)PyVkDescriptorImageInfo_init,0,PyVkDescriptorImageInfo_new,};
        
            static void PyVkWriteDescriptorSet_del(PyVkWriteDescriptorSet* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkWriteDescriptorSet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkWriteDescriptorSet *self;
                self = (PyVkWriteDescriptorSet *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkWriteDescriptorSet));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkWriteDescriptorSet");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkWriteDescriptorSet_getpNext(PyVkWriteDescriptorSet *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkWriteDescriptorSet_getdstBinding(PyVkWriteDescriptorSet *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->dstBinding);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkWriteDescriptorSet_getdstArrayElement(PyVkWriteDescriptorSet *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->dstArrayElement);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkWriteDescriptorSet_getdescriptorCount(PyVkWriteDescriptorSet *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->descriptorCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkWriteDescriptorSet_getsetters[] = {
                
                    { "pNext", (getter)PyVkWriteDescriptorSet_getpNext, NULL, "", NULL},
                
                    { "dstBinding", (getter)PyVkWriteDescriptorSet_getdstBinding, NULL, "", NULL},
                
                    { "dstArrayElement", (getter)PyVkWriteDescriptorSet_getdstArrayElement, NULL, "", NULL},
                
                    { "descriptorCount", (getter)PyVkWriteDescriptorSet_getdescriptorCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkWriteDescriptorSet_init(PyVkWriteDescriptorSet *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* dstSet = NULL;
PyObject* dstBinding = NULL;
PyObject* dstArrayElement = NULL;
PyObject* descriptorCount = NULL;
PyObject* descriptorType = NULL;
PyObject* pImageInfo = NULL;
PyObject* pBufferInfo = NULL;
PyObject* pTexelBufferView = NULL;
static char *kwlist[] = {"sType","pNext","dstSet","dstBinding","dstArrayElement","descriptorCount","descriptorType","pImageInfo","pBufferInfo","pTexelBufferView",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOOO", kwlist, &sType, &pNext, &dstSet, &dstBinding, &dstArrayElement, &descriptorCount, &descriptorType, &pImageInfo, &pBufferInfo, &pTexelBufferView)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (dstSet != NULL && dstSet != Py_None) {
                
                (self->base)->dstSet = PyCapsule_GetPointer(dstSet, "VkDescriptorSet");
            
 } 

                if (dstBinding != NULL && dstBinding != Py_None) {
                (self->base)->dstBinding = (uint32_t) PyLong_AsLong(dstBinding);
 } 

                if (dstArrayElement != NULL && dstArrayElement != Py_None) {
                (self->base)->dstArrayElement = (uint32_t) PyLong_AsLong(dstArrayElement);
 } 

                if (descriptorCount != NULL && descriptorCount != Py_None) {
                (self->base)->descriptorCount = (uint32_t) PyLong_AsLong(descriptorCount);
 } 

                if (descriptorType != NULL && descriptorType != Py_None) {
                
                    (self->base)->descriptorType = PyLong_AsLong(descriptorType);
                
 } 

                if (pImageInfo != NULL && pImageInfo != Py_None) {
                
                    (self->base)->pImageInfo = (((PyVkDescriptorImageInfo*)pImageInfo)->base);
                
 } 

                if (pBufferInfo != NULL && pBufferInfo != Py_None) {
                
                    (self->base)->pBufferInfo = (((PyVkDescriptorBufferInfo*)pBufferInfo)->base);
                
 } 

                if (pTexelBufferView != NULL && pTexelBufferView != Py_None) {
                
                (self->base)->pTexelBufferView = PyCapsule_GetPointer(pTexelBufferView, "VkBufferView");
            
 } 

return 0; }
            static PyTypeObject PyVkWriteDescriptorSetType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkWriteDescriptorSet", sizeof(PyVkWriteDescriptorSet), 0,
                (destructor)PyVkWriteDescriptorSet_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkWriteDescriptorSet object",0,0,0,0,0,0,0,0,
                PyVkWriteDescriptorSet_getsetters,0,0,0,0,0,(initproc)PyVkWriteDescriptorSet_init,0,PyVkWriteDescriptorSet_new,};
        
            static void PyVkCopyDescriptorSet_del(PyVkCopyDescriptorSet* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkCopyDescriptorSet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkCopyDescriptorSet *self;
                self = (PyVkCopyDescriptorSet *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkCopyDescriptorSet));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkCopyDescriptorSet");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkCopyDescriptorSet_getpNext(PyVkCopyDescriptorSet *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkCopyDescriptorSet_getsrcBinding(PyVkCopyDescriptorSet *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->srcBinding);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkCopyDescriptorSet_getsrcArrayElement(PyVkCopyDescriptorSet *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->srcArrayElement);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkCopyDescriptorSet_getdstBinding(PyVkCopyDescriptorSet *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->dstBinding);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkCopyDescriptorSet_getdstArrayElement(PyVkCopyDescriptorSet *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->dstArrayElement);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkCopyDescriptorSet_getdescriptorCount(PyVkCopyDescriptorSet *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->descriptorCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkCopyDescriptorSet_getsetters[] = {
                
                    { "pNext", (getter)PyVkCopyDescriptorSet_getpNext, NULL, "", NULL},
                
                    { "srcBinding", (getter)PyVkCopyDescriptorSet_getsrcBinding, NULL, "", NULL},
                
                    { "srcArrayElement", (getter)PyVkCopyDescriptorSet_getsrcArrayElement, NULL, "", NULL},
                
                    { "dstBinding", (getter)PyVkCopyDescriptorSet_getdstBinding, NULL, "", NULL},
                
                    { "dstArrayElement", (getter)PyVkCopyDescriptorSet_getdstArrayElement, NULL, "", NULL},
                
                    { "descriptorCount", (getter)PyVkCopyDescriptorSet_getdescriptorCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkCopyDescriptorSet_init(PyVkCopyDescriptorSet *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* srcSet = NULL;
PyObject* srcBinding = NULL;
PyObject* srcArrayElement = NULL;
PyObject* dstSet = NULL;
PyObject* dstBinding = NULL;
PyObject* dstArrayElement = NULL;
PyObject* descriptorCount = NULL;
static char *kwlist[] = {"sType","pNext","srcSet","srcBinding","srcArrayElement","dstSet","dstBinding","dstArrayElement","descriptorCount",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOO", kwlist, &sType, &pNext, &srcSet, &srcBinding, &srcArrayElement, &dstSet, &dstBinding, &dstArrayElement, &descriptorCount)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (srcSet != NULL && srcSet != Py_None) {
                
                (self->base)->srcSet = PyCapsule_GetPointer(srcSet, "VkDescriptorSet");
            
 } 

                if (srcBinding != NULL && srcBinding != Py_None) {
                (self->base)->srcBinding = (uint32_t) PyLong_AsLong(srcBinding);
 } 

                if (srcArrayElement != NULL && srcArrayElement != Py_None) {
                (self->base)->srcArrayElement = (uint32_t) PyLong_AsLong(srcArrayElement);
 } 

                if (dstSet != NULL && dstSet != Py_None) {
                
                (self->base)->dstSet = PyCapsule_GetPointer(dstSet, "VkDescriptorSet");
            
 } 

                if (dstBinding != NULL && dstBinding != Py_None) {
                (self->base)->dstBinding = (uint32_t) PyLong_AsLong(dstBinding);
 } 

                if (dstArrayElement != NULL && dstArrayElement != Py_None) {
                (self->base)->dstArrayElement = (uint32_t) PyLong_AsLong(dstArrayElement);
 } 

                if (descriptorCount != NULL && descriptorCount != Py_None) {
                (self->base)->descriptorCount = (uint32_t) PyLong_AsLong(descriptorCount);
 } 

return 0; }
            static PyTypeObject PyVkCopyDescriptorSetType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkCopyDescriptorSet", sizeof(PyVkCopyDescriptorSet), 0,
                (destructor)PyVkCopyDescriptorSet_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkCopyDescriptorSet object",0,0,0,0,0,0,0,0,
                PyVkCopyDescriptorSet_getsetters,0,0,0,0,0,(initproc)PyVkCopyDescriptorSet_init,0,PyVkCopyDescriptorSet_new,};
        
            static void PyVkBufferCreateInfo_del(PyVkBufferCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkBufferCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkBufferCreateInfo *self;
                self = (PyVkBufferCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkBufferCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkBufferCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkBufferCreateInfo_getpNext(PyVkBufferCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkBufferCreateInfo_getqueueFamilyIndexCount(PyVkBufferCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->queueFamilyIndexCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkBufferCreateInfo_getpQueueFamilyIndices(PyVkBufferCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (*((self->base)->pQueueFamilyIndices)));
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkBufferCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkBufferCreateInfo_getpNext, NULL, "", NULL},
                
                    { "queueFamilyIndexCount", (getter)PyVkBufferCreateInfo_getqueueFamilyIndexCount, NULL, "", NULL},
                
                    { "pQueueFamilyIndices", (getter)PyVkBufferCreateInfo_getpQueueFamilyIndices, NULL, "", NULL},
                {NULL}};

            static int
            PyVkBufferCreateInfo_init(PyVkBufferCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* size = NULL;
PyObject* usage = NULL;
PyObject* sharingMode = NULL;
PyObject* queueFamilyIndexCount = NULL;
PyObject* pQueueFamilyIndices = NULL;
static char *kwlist[] = {"sType","pNext","flags","size","usage","sharingMode","queueFamilyIndexCount","pQueueFamilyIndices",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOO", kwlist, &sType, &pNext, &flags, &size, &usage, &sharingMode, &queueFamilyIndexCount, &pQueueFamilyIndices)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (size != NULL && size != Py_None) {
                
                    (self->base)->size = PyLong_AsLong(size);
                
 } 

                if (usage != NULL && usage != Py_None) {
                
                    (self->base)->usage = PyLong_AsLong(usage);
                
 } 

                if (sharingMode != NULL && sharingMode != Py_None) {
                
                    (self->base)->sharingMode = PyLong_AsLong(sharingMode);
                
 } 

                if (queueFamilyIndexCount != NULL && queueFamilyIndexCount != Py_None) {
                (self->base)->queueFamilyIndexCount = (uint32_t) PyLong_AsLong(queueFamilyIndexCount);
 } 

                if (pQueueFamilyIndices != NULL && pQueueFamilyIndices != Py_None) {
                
        uint32_t tmp18874618 = (uint32_t) PyLong_AsLong(pQueueFamilyIndices);
        uint32_t *tmp89007244 = malloc(sizeof(uint32_t));
        memcpy(tmp89007244, &tmp18874618, sizeof(uint32_t));
        (self->base)->pQueueFamilyIndices = tmp89007244;
        
 } 

return 0; }
            static PyTypeObject PyVkBufferCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkBufferCreateInfo", sizeof(PyVkBufferCreateInfo), 0,
                (destructor)PyVkBufferCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkBufferCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkBufferCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkBufferCreateInfo_init,0,PyVkBufferCreateInfo_new,};
        
            static void PyVkBufferViewCreateInfo_del(PyVkBufferViewCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkBufferViewCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkBufferViewCreateInfo *self;
                self = (PyVkBufferViewCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkBufferViewCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkBufferViewCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkBufferViewCreateInfo_getpNext(PyVkBufferViewCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkBufferViewCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkBufferViewCreateInfo_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkBufferViewCreateInfo_init(PyVkBufferViewCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* buffer = NULL;
PyObject* format = NULL;
PyObject* offset = NULL;
PyObject* range = NULL;
static char *kwlist[] = {"sType","pNext","flags","buffer","format","offset","range",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOO", kwlist, &sType, &pNext, &flags, &buffer, &format, &offset, &range)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (buffer != NULL && buffer != Py_None) {
                
                (self->base)->buffer = PyCapsule_GetPointer(buffer, "VkBuffer");
            
 } 

                if (format != NULL && format != Py_None) {
                
                    (self->base)->format = PyLong_AsLong(format);
                
 } 

                if (offset != NULL && offset != Py_None) {
                
                    (self->base)->offset = PyLong_AsLong(offset);
                
 } 

                if (range != NULL && range != Py_None) {
                
                    (self->base)->range = PyLong_AsLong(range);
                
 } 

return 0; }
            static PyTypeObject PyVkBufferViewCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkBufferViewCreateInfo", sizeof(PyVkBufferViewCreateInfo), 0,
                (destructor)PyVkBufferViewCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkBufferViewCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkBufferViewCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkBufferViewCreateInfo_init,0,PyVkBufferViewCreateInfo_new,};
        
            static void PyVkImageSubresource_del(PyVkImageSubresource* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkImageSubresource_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkImageSubresource *self;
                self = (PyVkImageSubresource *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkImageSubresource));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageSubresource");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkImageSubresource_getmipLevel(PyVkImageSubresource *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->mipLevel);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkImageSubresource_getarrayLayer(PyVkImageSubresource *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->arrayLayer);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkImageSubresource_getsetters[] = {
                
                    { "mipLevel", (getter)PyVkImageSubresource_getmipLevel, NULL, "", NULL},
                
                    { "arrayLayer", (getter)PyVkImageSubresource_getarrayLayer, NULL, "", NULL},
                {NULL}};

            static int
            PyVkImageSubresource_init(PyVkImageSubresource *self, PyObject *args, PyObject *kwds) {
            PyObject* aspectMask = NULL;
PyObject* mipLevel = NULL;
PyObject* arrayLayer = NULL;
static char *kwlist[] = {"aspectMask","mipLevel","arrayLayer",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &aspectMask, &mipLevel, &arrayLayer)) return -1;

                if (aspectMask != NULL && aspectMask != Py_None) {
                
                    (self->base)->aspectMask = PyLong_AsLong(aspectMask);
                
 } 

                if (mipLevel != NULL && mipLevel != Py_None) {
                (self->base)->mipLevel = (uint32_t) PyLong_AsLong(mipLevel);
 } 

                if (arrayLayer != NULL && arrayLayer != Py_None) {
                (self->base)->arrayLayer = (uint32_t) PyLong_AsLong(arrayLayer);
 } 

return 0; }
            static PyTypeObject PyVkImageSubresourceType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageSubresource", sizeof(PyVkImageSubresource), 0,
                (destructor)PyVkImageSubresource_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageSubresource object",0,0,0,0,0,0,0,0,
                PyVkImageSubresource_getsetters,0,0,0,0,0,(initproc)PyVkImageSubresource_init,0,PyVkImageSubresource_new,};
        
            static void PyVkImageSubresourceLayers_del(PyVkImageSubresourceLayers* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkImageSubresourceLayers_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkImageSubresourceLayers *self;
                self = (PyVkImageSubresourceLayers *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkImageSubresourceLayers));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageSubresourceLayers");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkImageSubresourceLayers_getmipLevel(PyVkImageSubresourceLayers *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->mipLevel);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkImageSubresourceLayers_getbaseArrayLayer(PyVkImageSubresourceLayers *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->baseArrayLayer);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkImageSubresourceLayers_getlayerCount(PyVkImageSubresourceLayers *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->layerCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkImageSubresourceLayers_getsetters[] = {
                
                    { "mipLevel", (getter)PyVkImageSubresourceLayers_getmipLevel, NULL, "", NULL},
                
                    { "baseArrayLayer", (getter)PyVkImageSubresourceLayers_getbaseArrayLayer, NULL, "", NULL},
                
                    { "layerCount", (getter)PyVkImageSubresourceLayers_getlayerCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkImageSubresourceLayers_init(PyVkImageSubresourceLayers *self, PyObject *args, PyObject *kwds) {
            PyObject* aspectMask = NULL;
PyObject* mipLevel = NULL;
PyObject* baseArrayLayer = NULL;
PyObject* layerCount = NULL;
static char *kwlist[] = {"aspectMask","mipLevel","baseArrayLayer","layerCount",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &aspectMask, &mipLevel, &baseArrayLayer, &layerCount)) return -1;

                if (aspectMask != NULL && aspectMask != Py_None) {
                
                    (self->base)->aspectMask = PyLong_AsLong(aspectMask);
                
 } 

                if (mipLevel != NULL && mipLevel != Py_None) {
                (self->base)->mipLevel = (uint32_t) PyLong_AsLong(mipLevel);
 } 

                if (baseArrayLayer != NULL && baseArrayLayer != Py_None) {
                (self->base)->baseArrayLayer = (uint32_t) PyLong_AsLong(baseArrayLayer);
 } 

                if (layerCount != NULL && layerCount != Py_None) {
                (self->base)->layerCount = (uint32_t) PyLong_AsLong(layerCount);
 } 

return 0; }
            static PyTypeObject PyVkImageSubresourceLayersType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageSubresourceLayers", sizeof(PyVkImageSubresourceLayers), 0,
                (destructor)PyVkImageSubresourceLayers_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageSubresourceLayers object",0,0,0,0,0,0,0,0,
                PyVkImageSubresourceLayers_getsetters,0,0,0,0,0,(initproc)PyVkImageSubresourceLayers_init,0,PyVkImageSubresourceLayers_new,};
        
            static void PyVkImageSubresourceRange_del(PyVkImageSubresourceRange* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkImageSubresourceRange_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkImageSubresourceRange *self;
                self = (PyVkImageSubresourceRange *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkImageSubresourceRange));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageSubresourceRange");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkImageSubresourceRange_getbaseMipLevel(PyVkImageSubresourceRange *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->baseMipLevel);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkImageSubresourceRange_getlevelCount(PyVkImageSubresourceRange *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->levelCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkImageSubresourceRange_getbaseArrayLayer(PyVkImageSubresourceRange *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->baseArrayLayer);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkImageSubresourceRange_getlayerCount(PyVkImageSubresourceRange *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->layerCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkImageSubresourceRange_getsetters[] = {
                
                    { "baseMipLevel", (getter)PyVkImageSubresourceRange_getbaseMipLevel, NULL, "", NULL},
                
                    { "levelCount", (getter)PyVkImageSubresourceRange_getlevelCount, NULL, "", NULL},
                
                    { "baseArrayLayer", (getter)PyVkImageSubresourceRange_getbaseArrayLayer, NULL, "", NULL},
                
                    { "layerCount", (getter)PyVkImageSubresourceRange_getlayerCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkImageSubresourceRange_init(PyVkImageSubresourceRange *self, PyObject *args, PyObject *kwds) {
            PyObject* aspectMask = NULL;
PyObject* baseMipLevel = NULL;
PyObject* levelCount = NULL;
PyObject* baseArrayLayer = NULL;
PyObject* layerCount = NULL;
static char *kwlist[] = {"aspectMask","baseMipLevel","levelCount","baseArrayLayer","layerCount",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &aspectMask, &baseMipLevel, &levelCount, &baseArrayLayer, &layerCount)) return -1;

                if (aspectMask != NULL && aspectMask != Py_None) {
                
                    (self->base)->aspectMask = PyLong_AsLong(aspectMask);
                
 } 

                if (baseMipLevel != NULL && baseMipLevel != Py_None) {
                (self->base)->baseMipLevel = (uint32_t) PyLong_AsLong(baseMipLevel);
 } 

                if (levelCount != NULL && levelCount != Py_None) {
                (self->base)->levelCount = (uint32_t) PyLong_AsLong(levelCount);
 } 

                if (baseArrayLayer != NULL && baseArrayLayer != Py_None) {
                (self->base)->baseArrayLayer = (uint32_t) PyLong_AsLong(baseArrayLayer);
 } 

                if (layerCount != NULL && layerCount != Py_None) {
                (self->base)->layerCount = (uint32_t) PyLong_AsLong(layerCount);
 } 

return 0; }
            static PyTypeObject PyVkImageSubresourceRangeType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageSubresourceRange", sizeof(PyVkImageSubresourceRange), 0,
                (destructor)PyVkImageSubresourceRange_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageSubresourceRange object",0,0,0,0,0,0,0,0,
                PyVkImageSubresourceRange_getsetters,0,0,0,0,0,(initproc)PyVkImageSubresourceRange_init,0,PyVkImageSubresourceRange_new,};
        
            static void PyVkMemoryBarrier_del(PyVkMemoryBarrier* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkMemoryBarrier_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkMemoryBarrier *self;
                self = (PyVkMemoryBarrier *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkMemoryBarrier));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkMemoryBarrier");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkMemoryBarrier_getpNext(PyVkMemoryBarrier *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkMemoryBarrier_getsetters[] = {
                
                    { "pNext", (getter)PyVkMemoryBarrier_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkMemoryBarrier_init(PyVkMemoryBarrier *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* srcAccessMask = NULL;
PyObject* dstAccessMask = NULL;
static char *kwlist[] = {"sType","pNext","srcAccessMask","dstAccessMask",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &sType, &pNext, &srcAccessMask, &dstAccessMask)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (srcAccessMask != NULL && srcAccessMask != Py_None) {
                
                    (self->base)->srcAccessMask = PyLong_AsLong(srcAccessMask);
                
 } 

                if (dstAccessMask != NULL && dstAccessMask != Py_None) {
                
                    (self->base)->dstAccessMask = PyLong_AsLong(dstAccessMask);
                
 } 

return 0; }
            static PyTypeObject PyVkMemoryBarrierType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkMemoryBarrier", sizeof(PyVkMemoryBarrier), 0,
                (destructor)PyVkMemoryBarrier_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkMemoryBarrier object",0,0,0,0,0,0,0,0,
                PyVkMemoryBarrier_getsetters,0,0,0,0,0,(initproc)PyVkMemoryBarrier_init,0,PyVkMemoryBarrier_new,};
        
            static void PyVkBufferMemoryBarrier_del(PyVkBufferMemoryBarrier* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkBufferMemoryBarrier_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkBufferMemoryBarrier *self;
                self = (PyVkBufferMemoryBarrier *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkBufferMemoryBarrier));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkBufferMemoryBarrier");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkBufferMemoryBarrier_getpNext(PyVkBufferMemoryBarrier *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkBufferMemoryBarrier_getsrcQueueFamilyIndex(PyVkBufferMemoryBarrier *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->srcQueueFamilyIndex);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkBufferMemoryBarrier_getdstQueueFamilyIndex(PyVkBufferMemoryBarrier *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->dstQueueFamilyIndex);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkBufferMemoryBarrier_getsetters[] = {
                
                    { "pNext", (getter)PyVkBufferMemoryBarrier_getpNext, NULL, "", NULL},
                
                    { "srcQueueFamilyIndex", (getter)PyVkBufferMemoryBarrier_getsrcQueueFamilyIndex, NULL, "", NULL},
                
                    { "dstQueueFamilyIndex", (getter)PyVkBufferMemoryBarrier_getdstQueueFamilyIndex, NULL, "", NULL},
                {NULL}};

            static int
            PyVkBufferMemoryBarrier_init(PyVkBufferMemoryBarrier *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* srcAccessMask = NULL;
PyObject* dstAccessMask = NULL;
PyObject* srcQueueFamilyIndex = NULL;
PyObject* dstQueueFamilyIndex = NULL;
PyObject* buffer = NULL;
PyObject* offset = NULL;
PyObject* size = NULL;
static char *kwlist[] = {"sType","pNext","srcAccessMask","dstAccessMask","srcQueueFamilyIndex","dstQueueFamilyIndex","buffer","offset","size",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOO", kwlist, &sType, &pNext, &srcAccessMask, &dstAccessMask, &srcQueueFamilyIndex, &dstQueueFamilyIndex, &buffer, &offset, &size)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (srcAccessMask != NULL && srcAccessMask != Py_None) {
                
                    (self->base)->srcAccessMask = PyLong_AsLong(srcAccessMask);
                
 } 

                if (dstAccessMask != NULL && dstAccessMask != Py_None) {
                
                    (self->base)->dstAccessMask = PyLong_AsLong(dstAccessMask);
                
 } 

                if (srcQueueFamilyIndex != NULL && srcQueueFamilyIndex != Py_None) {
                (self->base)->srcQueueFamilyIndex = (uint32_t) PyLong_AsLong(srcQueueFamilyIndex);
 } 

                if (dstQueueFamilyIndex != NULL && dstQueueFamilyIndex != Py_None) {
                (self->base)->dstQueueFamilyIndex = (uint32_t) PyLong_AsLong(dstQueueFamilyIndex);
 } 

                if (buffer != NULL && buffer != Py_None) {
                
                (self->base)->buffer = PyCapsule_GetPointer(buffer, "VkBuffer");
            
 } 

                if (offset != NULL && offset != Py_None) {
                
                    (self->base)->offset = PyLong_AsLong(offset);
                
 } 

                if (size != NULL && size != Py_None) {
                
                    (self->base)->size = PyLong_AsLong(size);
                
 } 

return 0; }
            static PyTypeObject PyVkBufferMemoryBarrierType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkBufferMemoryBarrier", sizeof(PyVkBufferMemoryBarrier), 0,
                (destructor)PyVkBufferMemoryBarrier_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkBufferMemoryBarrier object",0,0,0,0,0,0,0,0,
                PyVkBufferMemoryBarrier_getsetters,0,0,0,0,0,(initproc)PyVkBufferMemoryBarrier_init,0,PyVkBufferMemoryBarrier_new,};
        
            static void PyVkImageMemoryBarrier_del(PyVkImageMemoryBarrier* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkImageMemoryBarrier_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkImageMemoryBarrier *self;
                self = (PyVkImageMemoryBarrier *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkImageMemoryBarrier));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageMemoryBarrier");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkImageMemoryBarrier_getpNext(PyVkImageMemoryBarrier *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkImageMemoryBarrier_getsrcQueueFamilyIndex(PyVkImageMemoryBarrier *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->srcQueueFamilyIndex);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkImageMemoryBarrier_getdstQueueFamilyIndex(PyVkImageMemoryBarrier *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->dstQueueFamilyIndex);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkImageMemoryBarrier_getsetters[] = {
                
                    { "pNext", (getter)PyVkImageMemoryBarrier_getpNext, NULL, "", NULL},
                
                    { "srcQueueFamilyIndex", (getter)PyVkImageMemoryBarrier_getsrcQueueFamilyIndex, NULL, "", NULL},
                
                    { "dstQueueFamilyIndex", (getter)PyVkImageMemoryBarrier_getdstQueueFamilyIndex, NULL, "", NULL},
                {NULL}};

            static int
            PyVkImageMemoryBarrier_init(PyVkImageMemoryBarrier *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* srcAccessMask = NULL;
PyObject* dstAccessMask = NULL;
PyObject* oldLayout = NULL;
PyObject* newLayout = NULL;
PyObject* srcQueueFamilyIndex = NULL;
PyObject* dstQueueFamilyIndex = NULL;
PyObject* image = NULL;
PyObject* subresourceRange = NULL;
static char *kwlist[] = {"sType","pNext","srcAccessMask","dstAccessMask","oldLayout","newLayout","srcQueueFamilyIndex","dstQueueFamilyIndex","image","subresourceRange",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOOO", kwlist, &sType, &pNext, &srcAccessMask, &dstAccessMask, &oldLayout, &newLayout, &srcQueueFamilyIndex, &dstQueueFamilyIndex, &image, &subresourceRange)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (srcAccessMask != NULL && srcAccessMask != Py_None) {
                
                    (self->base)->srcAccessMask = PyLong_AsLong(srcAccessMask);
                
 } 

                if (dstAccessMask != NULL && dstAccessMask != Py_None) {
                
                    (self->base)->dstAccessMask = PyLong_AsLong(dstAccessMask);
                
 } 

                if (oldLayout != NULL && oldLayout != Py_None) {
                
                    (self->base)->oldLayout = PyLong_AsLong(oldLayout);
                
 } 

                if (newLayout != NULL && newLayout != Py_None) {
                
                    (self->base)->newLayout = PyLong_AsLong(newLayout);
                
 } 

                if (srcQueueFamilyIndex != NULL && srcQueueFamilyIndex != Py_None) {
                (self->base)->srcQueueFamilyIndex = (uint32_t) PyLong_AsLong(srcQueueFamilyIndex);
 } 

                if (dstQueueFamilyIndex != NULL && dstQueueFamilyIndex != Py_None) {
                (self->base)->dstQueueFamilyIndex = (uint32_t) PyLong_AsLong(dstQueueFamilyIndex);
 } 

                if (image != NULL && image != Py_None) {
                
                (self->base)->image = PyCapsule_GetPointer(image, "VkImage");
            
 } 

                if (subresourceRange != NULL && subresourceRange != Py_None) {
                
                    (self->base)->subresourceRange = *(((PyVkImageSubresourceRange*)subresourceRange)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkImageMemoryBarrierType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageMemoryBarrier", sizeof(PyVkImageMemoryBarrier), 0,
                (destructor)PyVkImageMemoryBarrier_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageMemoryBarrier object",0,0,0,0,0,0,0,0,
                PyVkImageMemoryBarrier_getsetters,0,0,0,0,0,(initproc)PyVkImageMemoryBarrier_init,0,PyVkImageMemoryBarrier_new,};
        
            static void PyVkImageCreateInfo_del(PyVkImageCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkImageCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkImageCreateInfo *self;
                self = (PyVkImageCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkImageCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkImageCreateInfo_getpNext(PyVkImageCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkImageCreateInfo_getmipLevels(PyVkImageCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->mipLevels);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkImageCreateInfo_getarrayLayers(PyVkImageCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->arrayLayers);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkImageCreateInfo_getqueueFamilyIndexCount(PyVkImageCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->queueFamilyIndexCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkImageCreateInfo_getpQueueFamilyIndices(PyVkImageCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (*((self->base)->pQueueFamilyIndices)));
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkImageCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkImageCreateInfo_getpNext, NULL, "", NULL},
                
                    { "mipLevels", (getter)PyVkImageCreateInfo_getmipLevels, NULL, "", NULL},
                
                    { "arrayLayers", (getter)PyVkImageCreateInfo_getarrayLayers, NULL, "", NULL},
                
                    { "queueFamilyIndexCount", (getter)PyVkImageCreateInfo_getqueueFamilyIndexCount, NULL, "", NULL},
                
                    { "pQueueFamilyIndices", (getter)PyVkImageCreateInfo_getpQueueFamilyIndices, NULL, "", NULL},
                {NULL}};

            static int
            PyVkImageCreateInfo_init(PyVkImageCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* imageType = NULL;
PyObject* format = NULL;
PyObject* extent = NULL;
PyObject* mipLevels = NULL;
PyObject* arrayLayers = NULL;
PyObject* samples = NULL;
PyObject* tiling = NULL;
PyObject* usage = NULL;
PyObject* sharingMode = NULL;
PyObject* queueFamilyIndexCount = NULL;
PyObject* pQueueFamilyIndices = NULL;
PyObject* initialLayout = NULL;
static char *kwlist[] = {"sType","pNext","flags","imageType","format","extent","mipLevels","arrayLayers","samples","tiling","usage","sharingMode","queueFamilyIndexCount","pQueueFamilyIndices","initialLayout",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOOOOOOOO", kwlist, &sType, &pNext, &flags, &imageType, &format, &extent, &mipLevels, &arrayLayers, &samples, &tiling, &usage, &sharingMode, &queueFamilyIndexCount, &pQueueFamilyIndices, &initialLayout)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (imageType != NULL && imageType != Py_None) {
                
                    (self->base)->imageType = PyLong_AsLong(imageType);
                
 } 

                if (format != NULL && format != Py_None) {
                
                    (self->base)->format = PyLong_AsLong(format);
                
 } 

                if (extent != NULL && extent != Py_None) {
                
                    (self->base)->extent = *(((PyVkExtent3D*)extent)->base);
                
 } 

                if (mipLevels != NULL && mipLevels != Py_None) {
                (self->base)->mipLevels = (uint32_t) PyLong_AsLong(mipLevels);
 } 

                if (arrayLayers != NULL && arrayLayers != Py_None) {
                (self->base)->arrayLayers = (uint32_t) PyLong_AsLong(arrayLayers);
 } 

                if (samples != NULL && samples != Py_None) {
                
                    (self->base)->samples = PyLong_AsLong(samples);
                
 } 

                if (tiling != NULL && tiling != Py_None) {
                
                    (self->base)->tiling = PyLong_AsLong(tiling);
                
 } 

                if (usage != NULL && usage != Py_None) {
                
                    (self->base)->usage = PyLong_AsLong(usage);
                
 } 

                if (sharingMode != NULL && sharingMode != Py_None) {
                
                    (self->base)->sharingMode = PyLong_AsLong(sharingMode);
                
 } 

                if (queueFamilyIndexCount != NULL && queueFamilyIndexCount != Py_None) {
                (self->base)->queueFamilyIndexCount = (uint32_t) PyLong_AsLong(queueFamilyIndexCount);
 } 

                if (pQueueFamilyIndices != NULL && pQueueFamilyIndices != Py_None) {
                
        uint32_t tmp72448834 = (uint32_t) PyLong_AsLong(pQueueFamilyIndices);
        uint32_t *tmp62901928 = malloc(sizeof(uint32_t));
        memcpy(tmp62901928, &tmp72448834, sizeof(uint32_t));
        (self->base)->pQueueFamilyIndices = tmp62901928;
        
 } 

                if (initialLayout != NULL && initialLayout != Py_None) {
                
                    (self->base)->initialLayout = PyLong_AsLong(initialLayout);
                
 } 

return 0; }
            static PyTypeObject PyVkImageCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageCreateInfo", sizeof(PyVkImageCreateInfo), 0,
                (destructor)PyVkImageCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkImageCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkImageCreateInfo_init,0,PyVkImageCreateInfo_new,};
        
            static void PyVkSubresourceLayout_del(PyVkSubresourceLayout* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSubresourceLayout_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSubresourceLayout *self;
                self = (PyVkSubresourceLayout *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSubresourceLayout));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSubresourceLayout");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkSubresourceLayout_getsetters[] = {
                {NULL}};

            static int
            PyVkSubresourceLayout_init(PyVkSubresourceLayout *self, PyObject *args, PyObject *kwds) {
            return 0; }
            static PyTypeObject PyVkSubresourceLayoutType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSubresourceLayout", sizeof(PyVkSubresourceLayout), 0,
                (destructor)PyVkSubresourceLayout_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSubresourceLayout object",0,0,0,0,0,0,0,0,
                PyVkSubresourceLayout_getsetters,0,0,0,0,0,(initproc)PyVkSubresourceLayout_init,0,PyVkSubresourceLayout_new,};
        
            static void PyVkImageViewCreateInfo_del(PyVkImageViewCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkImageViewCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkImageViewCreateInfo *self;
                self = (PyVkImageViewCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkImageViewCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageViewCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkImageViewCreateInfo_getpNext(PyVkImageViewCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkImageViewCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkImageViewCreateInfo_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkImageViewCreateInfo_init(PyVkImageViewCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* image = NULL;
PyObject* viewType = NULL;
PyObject* format = NULL;
PyObject* components = NULL;
PyObject* subresourceRange = NULL;
static char *kwlist[] = {"sType","pNext","flags","image","viewType","format","components","subresourceRange",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOO", kwlist, &sType, &pNext, &flags, &image, &viewType, &format, &components, &subresourceRange)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (image != NULL && image != Py_None) {
                
                (self->base)->image = PyCapsule_GetPointer(image, "VkImage");
            
 } 

                if (viewType != NULL && viewType != Py_None) {
                
                    (self->base)->viewType = PyLong_AsLong(viewType);
                
 } 

                if (format != NULL && format != Py_None) {
                
                    (self->base)->format = PyLong_AsLong(format);
                
 } 

                if (components != NULL && components != Py_None) {
                
                    (self->base)->components = *(((PyVkComponentMapping*)components)->base);
                
 } 

                if (subresourceRange != NULL && subresourceRange != Py_None) {
                
                    (self->base)->subresourceRange = *(((PyVkImageSubresourceRange*)subresourceRange)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkImageViewCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageViewCreateInfo", sizeof(PyVkImageViewCreateInfo), 0,
                (destructor)PyVkImageViewCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageViewCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkImageViewCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkImageViewCreateInfo_init,0,PyVkImageViewCreateInfo_new,};
        
            static void PyVkBufferCopy_del(PyVkBufferCopy* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkBufferCopy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkBufferCopy *self;
                self = (PyVkBufferCopy *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkBufferCopy));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkBufferCopy");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkBufferCopy_getsetters[] = {
                {NULL}};

            static int
            PyVkBufferCopy_init(PyVkBufferCopy *self, PyObject *args, PyObject *kwds) {
            PyObject* srcOffset = NULL;
PyObject* dstOffset = NULL;
PyObject* size = NULL;
static char *kwlist[] = {"srcOffset","dstOffset","size",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &srcOffset, &dstOffset, &size)) return -1;

                if (srcOffset != NULL && srcOffset != Py_None) {
                
                    (self->base)->srcOffset = PyLong_AsLong(srcOffset);
                
 } 

                if (dstOffset != NULL && dstOffset != Py_None) {
                
                    (self->base)->dstOffset = PyLong_AsLong(dstOffset);
                
 } 

                if (size != NULL && size != Py_None) {
                
                    (self->base)->size = PyLong_AsLong(size);
                
 } 

return 0; }
            static PyTypeObject PyVkBufferCopyType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkBufferCopy", sizeof(PyVkBufferCopy), 0,
                (destructor)PyVkBufferCopy_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkBufferCopy object",0,0,0,0,0,0,0,0,
                PyVkBufferCopy_getsetters,0,0,0,0,0,(initproc)PyVkBufferCopy_init,0,PyVkBufferCopy_new,};
        
            static void PyVkSparseMemoryBind_del(PyVkSparseMemoryBind* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSparseMemoryBind_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSparseMemoryBind *self;
                self = (PyVkSparseMemoryBind *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSparseMemoryBind));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSparseMemoryBind");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkSparseMemoryBind_getsetters[] = {
                {NULL}};

            static int
            PyVkSparseMemoryBind_init(PyVkSparseMemoryBind *self, PyObject *args, PyObject *kwds) {
            PyObject* resourceOffset = NULL;
PyObject* size = NULL;
PyObject* memory = NULL;
PyObject* memoryOffset = NULL;
PyObject* flags = NULL;
static char *kwlist[] = {"resourceOffset","size","memory","memoryOffset","flags",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &resourceOffset, &size, &memory, &memoryOffset, &flags)) return -1;

                if (resourceOffset != NULL && resourceOffset != Py_None) {
                
                    (self->base)->resourceOffset = PyLong_AsLong(resourceOffset);
                
 } 

                if (size != NULL && size != Py_None) {
                
                    (self->base)->size = PyLong_AsLong(size);
                
 } 

                if (memory != NULL && memory != Py_None) {
                
                (self->base)->memory = PyCapsule_GetPointer(memory, "VkDeviceMemory");
            
 } 

                if (memoryOffset != NULL && memoryOffset != Py_None) {
                
                    (self->base)->memoryOffset = PyLong_AsLong(memoryOffset);
                
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

return 0; }
            static PyTypeObject PyVkSparseMemoryBindType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSparseMemoryBind", sizeof(PyVkSparseMemoryBind), 0,
                (destructor)PyVkSparseMemoryBind_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSparseMemoryBind object",0,0,0,0,0,0,0,0,
                PyVkSparseMemoryBind_getsetters,0,0,0,0,0,(initproc)PyVkSparseMemoryBind_init,0,PyVkSparseMemoryBind_new,};
        
            static void PyVkSparseImageMemoryBind_del(PyVkSparseImageMemoryBind* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSparseImageMemoryBind_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSparseImageMemoryBind *self;
                self = (PyVkSparseImageMemoryBind *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSparseImageMemoryBind));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSparseImageMemoryBind");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkSparseImageMemoryBind_getsetters[] = {
                {NULL}};

            static int
            PyVkSparseImageMemoryBind_init(PyVkSparseImageMemoryBind *self, PyObject *args, PyObject *kwds) {
            PyObject* subresource = NULL;
PyObject* offset = NULL;
PyObject* extent = NULL;
PyObject* memory = NULL;
PyObject* memoryOffset = NULL;
PyObject* flags = NULL;
static char *kwlist[] = {"subresource","offset","extent","memory","memoryOffset","flags",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOO", kwlist, &subresource, &offset, &extent, &memory, &memoryOffset, &flags)) return -1;

                if (subresource != NULL && subresource != Py_None) {
                
                    (self->base)->subresource = *(((PyVkImageSubresource*)subresource)->base);
                
 } 

                if (offset != NULL && offset != Py_None) {
                
                    (self->base)->offset = *(((PyVkOffset3D*)offset)->base);
                
 } 

                if (extent != NULL && extent != Py_None) {
                
                    (self->base)->extent = *(((PyVkExtent3D*)extent)->base);
                
 } 

                if (memory != NULL && memory != Py_None) {
                
                (self->base)->memory = PyCapsule_GetPointer(memory, "VkDeviceMemory");
            
 } 

                if (memoryOffset != NULL && memoryOffset != Py_None) {
                
                    (self->base)->memoryOffset = PyLong_AsLong(memoryOffset);
                
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

return 0; }
            static PyTypeObject PyVkSparseImageMemoryBindType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSparseImageMemoryBind", sizeof(PyVkSparseImageMemoryBind), 0,
                (destructor)PyVkSparseImageMemoryBind_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSparseImageMemoryBind object",0,0,0,0,0,0,0,0,
                PyVkSparseImageMemoryBind_getsetters,0,0,0,0,0,(initproc)PyVkSparseImageMemoryBind_init,0,PyVkSparseImageMemoryBind_new,};
        
            static void PyVkSparseBufferMemoryBindInfo_del(PyVkSparseBufferMemoryBindInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSparseBufferMemoryBindInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSparseBufferMemoryBindInfo *self;
                self = (PyVkSparseBufferMemoryBindInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSparseBufferMemoryBindInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSparseBufferMemoryBindInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkSparseBufferMemoryBindInfo_getbindCount(PyVkSparseBufferMemoryBindInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->bindCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkSparseBufferMemoryBindInfo_getsetters[] = {
                
                    { "bindCount", (getter)PyVkSparseBufferMemoryBindInfo_getbindCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkSparseBufferMemoryBindInfo_init(PyVkSparseBufferMemoryBindInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* buffer = NULL;
PyObject* bindCount = NULL;
PyObject* pBinds = NULL;
static char *kwlist[] = {"buffer","bindCount","pBinds",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &buffer, &bindCount, &pBinds)) return -1;

                if (buffer != NULL && buffer != Py_None) {
                
                (self->base)->buffer = PyCapsule_GetPointer(buffer, "VkBuffer");
            
 } 

                if (bindCount != NULL && bindCount != Py_None) {
                (self->base)->bindCount = (uint32_t) PyLong_AsLong(bindCount);
 } 

                if (pBinds != NULL && pBinds != Py_None) {
                
                    (self->base)->pBinds = (((PyVkSparseMemoryBind*)pBinds)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkSparseBufferMemoryBindInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSparseBufferMemoryBindInfo", sizeof(PyVkSparseBufferMemoryBindInfo), 0,
                (destructor)PyVkSparseBufferMemoryBindInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSparseBufferMemoryBindInfo object",0,0,0,0,0,0,0,0,
                PyVkSparseBufferMemoryBindInfo_getsetters,0,0,0,0,0,(initproc)PyVkSparseBufferMemoryBindInfo_init,0,PyVkSparseBufferMemoryBindInfo_new,};
        
            static void PyVkSparseImageOpaqueMemoryBindInfo_del(PyVkSparseImageOpaqueMemoryBindInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSparseImageOpaqueMemoryBindInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSparseImageOpaqueMemoryBindInfo *self;
                self = (PyVkSparseImageOpaqueMemoryBindInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSparseImageOpaqueMemoryBindInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSparseImageOpaqueMemoryBindInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkSparseImageOpaqueMemoryBindInfo_getbindCount(PyVkSparseImageOpaqueMemoryBindInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->bindCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkSparseImageOpaqueMemoryBindInfo_getsetters[] = {
                
                    { "bindCount", (getter)PyVkSparseImageOpaqueMemoryBindInfo_getbindCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkSparseImageOpaqueMemoryBindInfo_init(PyVkSparseImageOpaqueMemoryBindInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* image = NULL;
PyObject* bindCount = NULL;
PyObject* pBinds = NULL;
static char *kwlist[] = {"image","bindCount","pBinds",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &image, &bindCount, &pBinds)) return -1;

                if (image != NULL && image != Py_None) {
                
                (self->base)->image = PyCapsule_GetPointer(image, "VkImage");
            
 } 

                if (bindCount != NULL && bindCount != Py_None) {
                (self->base)->bindCount = (uint32_t) PyLong_AsLong(bindCount);
 } 

                if (pBinds != NULL && pBinds != Py_None) {
                
                    (self->base)->pBinds = (((PyVkSparseMemoryBind*)pBinds)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkSparseImageOpaqueMemoryBindInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSparseImageOpaqueMemoryBindInfo", sizeof(PyVkSparseImageOpaqueMemoryBindInfo), 0,
                (destructor)PyVkSparseImageOpaqueMemoryBindInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSparseImageOpaqueMemoryBindInfo object",0,0,0,0,0,0,0,0,
                PyVkSparseImageOpaqueMemoryBindInfo_getsetters,0,0,0,0,0,(initproc)PyVkSparseImageOpaqueMemoryBindInfo_init,0,PyVkSparseImageOpaqueMemoryBindInfo_new,};
        
            static void PyVkSparseImageMemoryBindInfo_del(PyVkSparseImageMemoryBindInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSparseImageMemoryBindInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSparseImageMemoryBindInfo *self;
                self = (PyVkSparseImageMemoryBindInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSparseImageMemoryBindInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSparseImageMemoryBindInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkSparseImageMemoryBindInfo_getbindCount(PyVkSparseImageMemoryBindInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->bindCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkSparseImageMemoryBindInfo_getsetters[] = {
                
                    { "bindCount", (getter)PyVkSparseImageMemoryBindInfo_getbindCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkSparseImageMemoryBindInfo_init(PyVkSparseImageMemoryBindInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* image = NULL;
PyObject* bindCount = NULL;
PyObject* pBinds = NULL;
static char *kwlist[] = {"image","bindCount","pBinds",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &image, &bindCount, &pBinds)) return -1;

                if (image != NULL && image != Py_None) {
                
                (self->base)->image = PyCapsule_GetPointer(image, "VkImage");
            
 } 

                if (bindCount != NULL && bindCount != Py_None) {
                (self->base)->bindCount = (uint32_t) PyLong_AsLong(bindCount);
 } 

                if (pBinds != NULL && pBinds != Py_None) {
                
                    (self->base)->pBinds = (((PyVkSparseImageMemoryBind*)pBinds)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkSparseImageMemoryBindInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSparseImageMemoryBindInfo", sizeof(PyVkSparseImageMemoryBindInfo), 0,
                (destructor)PyVkSparseImageMemoryBindInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSparseImageMemoryBindInfo object",0,0,0,0,0,0,0,0,
                PyVkSparseImageMemoryBindInfo_getsetters,0,0,0,0,0,(initproc)PyVkSparseImageMemoryBindInfo_init,0,PyVkSparseImageMemoryBindInfo_new,};
        
            static void PyVkBindSparseInfo_del(PyVkBindSparseInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkBindSparseInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkBindSparseInfo *self;
                self = (PyVkBindSparseInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkBindSparseInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkBindSparseInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkBindSparseInfo_getpNext(PyVkBindSparseInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkBindSparseInfo_getwaitSemaphoreCount(PyVkBindSparseInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->waitSemaphoreCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkBindSparseInfo_getbufferBindCount(PyVkBindSparseInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->bufferBindCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkBindSparseInfo_getimageOpaqueBindCount(PyVkBindSparseInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->imageOpaqueBindCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkBindSparseInfo_getimageBindCount(PyVkBindSparseInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->imageBindCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkBindSparseInfo_getsignalSemaphoreCount(PyVkBindSparseInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->signalSemaphoreCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkBindSparseInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkBindSparseInfo_getpNext, NULL, "", NULL},
                
                    { "waitSemaphoreCount", (getter)PyVkBindSparseInfo_getwaitSemaphoreCount, NULL, "", NULL},
                
                    { "bufferBindCount", (getter)PyVkBindSparseInfo_getbufferBindCount, NULL, "", NULL},
                
                    { "imageOpaqueBindCount", (getter)PyVkBindSparseInfo_getimageOpaqueBindCount, NULL, "", NULL},
                
                    { "imageBindCount", (getter)PyVkBindSparseInfo_getimageBindCount, NULL, "", NULL},
                
                    { "signalSemaphoreCount", (getter)PyVkBindSparseInfo_getsignalSemaphoreCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkBindSparseInfo_init(PyVkBindSparseInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* waitSemaphoreCount = NULL;
PyObject* pWaitSemaphores = NULL;
PyObject* bufferBindCount = NULL;
PyObject* pBufferBinds = NULL;
PyObject* imageOpaqueBindCount = NULL;
PyObject* pImageOpaqueBinds = NULL;
PyObject* imageBindCount = NULL;
PyObject* pImageBinds = NULL;
PyObject* signalSemaphoreCount = NULL;
PyObject* pSignalSemaphores = NULL;
static char *kwlist[] = {"sType","pNext","waitSemaphoreCount","pWaitSemaphores","bufferBindCount","pBufferBinds","imageOpaqueBindCount","pImageOpaqueBinds","imageBindCount","pImageBinds","signalSemaphoreCount","pSignalSemaphores",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOOOOO", kwlist, &sType, &pNext, &waitSemaphoreCount, &pWaitSemaphores, &bufferBindCount, &pBufferBinds, &imageOpaqueBindCount, &pImageOpaqueBinds, &imageBindCount, &pImageBinds, &signalSemaphoreCount, &pSignalSemaphores)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (waitSemaphoreCount != NULL && waitSemaphoreCount != Py_None) {
                (self->base)->waitSemaphoreCount = (uint32_t) PyLong_AsLong(waitSemaphoreCount);
 } 

                if (pWaitSemaphores != NULL && pWaitSemaphores != Py_None) {
                
                (self->base)->pWaitSemaphores = PyCapsule_GetPointer(pWaitSemaphores, "VkSemaphore");
            
 } 

                if (bufferBindCount != NULL && bufferBindCount != Py_None) {
                (self->base)->bufferBindCount = (uint32_t) PyLong_AsLong(bufferBindCount);
 } 

                if (pBufferBinds != NULL && pBufferBinds != Py_None) {
                
                    (self->base)->pBufferBinds = (((PyVkSparseBufferMemoryBindInfo*)pBufferBinds)->base);
                
 } 

                if (imageOpaqueBindCount != NULL && imageOpaqueBindCount != Py_None) {
                (self->base)->imageOpaqueBindCount = (uint32_t) PyLong_AsLong(imageOpaqueBindCount);
 } 

                if (pImageOpaqueBinds != NULL && pImageOpaqueBinds != Py_None) {
                
                    (self->base)->pImageOpaqueBinds = (((PyVkSparseImageOpaqueMemoryBindInfo*)pImageOpaqueBinds)->base);
                
 } 

                if (imageBindCount != NULL && imageBindCount != Py_None) {
                (self->base)->imageBindCount = (uint32_t) PyLong_AsLong(imageBindCount);
 } 

                if (pImageBinds != NULL && pImageBinds != Py_None) {
                
                    (self->base)->pImageBinds = (((PyVkSparseImageMemoryBindInfo*)pImageBinds)->base);
                
 } 

                if (signalSemaphoreCount != NULL && signalSemaphoreCount != Py_None) {
                (self->base)->signalSemaphoreCount = (uint32_t) PyLong_AsLong(signalSemaphoreCount);
 } 

                if (pSignalSemaphores != NULL && pSignalSemaphores != Py_None) {
                
                (self->base)->pSignalSemaphores = PyCapsule_GetPointer(pSignalSemaphores, "VkSemaphore");
            
 } 

return 0; }
            static PyTypeObject PyVkBindSparseInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkBindSparseInfo", sizeof(PyVkBindSparseInfo), 0,
                (destructor)PyVkBindSparseInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkBindSparseInfo object",0,0,0,0,0,0,0,0,
                PyVkBindSparseInfo_getsetters,0,0,0,0,0,(initproc)PyVkBindSparseInfo_init,0,PyVkBindSparseInfo_new,};
        
            static void PyVkImageCopy_del(PyVkImageCopy* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkImageCopy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkImageCopy *self;
                self = (PyVkImageCopy *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkImageCopy));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageCopy");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkImageCopy_getsetters[] = {
                {NULL}};

            static int
            PyVkImageCopy_init(PyVkImageCopy *self, PyObject *args, PyObject *kwds) {
            PyObject* srcSubresource = NULL;
PyObject* srcOffset = NULL;
PyObject* dstSubresource = NULL;
PyObject* dstOffset = NULL;
PyObject* extent = NULL;
static char *kwlist[] = {"srcSubresource","srcOffset","dstSubresource","dstOffset","extent",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &srcSubresource, &srcOffset, &dstSubresource, &dstOffset, &extent)) return -1;

                if (srcSubresource != NULL && srcSubresource != Py_None) {
                
                    (self->base)->srcSubresource = *(((PyVkImageSubresourceLayers*)srcSubresource)->base);
                
 } 

                if (srcOffset != NULL && srcOffset != Py_None) {
                
                    (self->base)->srcOffset = *(((PyVkOffset3D*)srcOffset)->base);
                
 } 

                if (dstSubresource != NULL && dstSubresource != Py_None) {
                
                    (self->base)->dstSubresource = *(((PyVkImageSubresourceLayers*)dstSubresource)->base);
                
 } 

                if (dstOffset != NULL && dstOffset != Py_None) {
                
                    (self->base)->dstOffset = *(((PyVkOffset3D*)dstOffset)->base);
                
 } 

                if (extent != NULL && extent != Py_None) {
                
                    (self->base)->extent = *(((PyVkExtent3D*)extent)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkImageCopyType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageCopy", sizeof(PyVkImageCopy), 0,
                (destructor)PyVkImageCopy_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageCopy object",0,0,0,0,0,0,0,0,
                PyVkImageCopy_getsetters,0,0,0,0,0,(initproc)PyVkImageCopy_init,0,PyVkImageCopy_new,};
        
            static void PyVkImageBlit_del(PyVkImageBlit* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkImageBlit_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkImageBlit *self;
                self = (PyVkImageBlit *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkImageBlit));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageBlit");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkImageBlit_getsetters[] = {
                {NULL}};

            static int
            PyVkImageBlit_init(PyVkImageBlit *self, PyObject *args, PyObject *kwds) {
            PyObject* srcSubresource = NULL;
PyObject* srcOffsets = NULL;
PyObject* dstSubresource = NULL;
PyObject* dstOffsets = NULL;
static char *kwlist[] = {"srcSubresource","srcOffsets","dstSubresource","dstOffsets",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &srcSubresource, &srcOffsets, &dstSubresource, &dstOffsets)) return -1;

                if (srcSubresource != NULL && srcSubresource != Py_None) {
                
                    (self->base)->srcSubresource = *(((PyVkImageSubresourceLayers*)srcSubresource)->base);
                
 } 

                if (srcOffsets != NULL && srcOffsets != Py_None) {
                
                    int tmp56090910 = PyList_Size(srcOffsets);
                    int tmp96417283;
                    for (tmp96417283 = 0; tmp96417283 < tmp56090910; tmp96417283++) {
                        PyObject* tmp = PyList_GetItem(srcOffsets, tmp96417283);
                        ((self->base)->srcOffsets)[tmp96417283] = *(((PyVkOffset3D*)tmp)->base);
                    }
                    
 } 

                if (dstSubresource != NULL && dstSubresource != Py_None) {
                
                    (self->base)->dstSubresource = *(((PyVkImageSubresourceLayers*)dstSubresource)->base);
                
 } 

                if (dstOffsets != NULL && dstOffsets != Py_None) {
                
                    int tmp58567911 = PyList_Size(dstOffsets);
                    int tmp29227516;
                    for (tmp29227516 = 0; tmp29227516 < tmp58567911; tmp29227516++) {
                        PyObject* tmp = PyList_GetItem(dstOffsets, tmp29227516);
                        ((self->base)->dstOffsets)[tmp29227516] = *(((PyVkOffset3D*)tmp)->base);
                    }
                    
 } 

return 0; }
            static PyTypeObject PyVkImageBlitType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageBlit", sizeof(PyVkImageBlit), 0,
                (destructor)PyVkImageBlit_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageBlit object",0,0,0,0,0,0,0,0,
                PyVkImageBlit_getsetters,0,0,0,0,0,(initproc)PyVkImageBlit_init,0,PyVkImageBlit_new,};
        
            static void PyVkBufferImageCopy_del(PyVkBufferImageCopy* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkBufferImageCopy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkBufferImageCopy *self;
                self = (PyVkBufferImageCopy *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkBufferImageCopy));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkBufferImageCopy");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkBufferImageCopy_getbufferRowLength(PyVkBufferImageCopy *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->bufferRowLength);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkBufferImageCopy_getbufferImageHeight(PyVkBufferImageCopy *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->bufferImageHeight);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkBufferImageCopy_getsetters[] = {
                
                    { "bufferRowLength", (getter)PyVkBufferImageCopy_getbufferRowLength, NULL, "", NULL},
                
                    { "bufferImageHeight", (getter)PyVkBufferImageCopy_getbufferImageHeight, NULL, "", NULL},
                {NULL}};

            static int
            PyVkBufferImageCopy_init(PyVkBufferImageCopy *self, PyObject *args, PyObject *kwds) {
            PyObject* bufferOffset = NULL;
PyObject* bufferRowLength = NULL;
PyObject* bufferImageHeight = NULL;
PyObject* imageSubresource = NULL;
PyObject* imageOffset = NULL;
PyObject* imageExtent = NULL;
static char *kwlist[] = {"bufferOffset","bufferRowLength","bufferImageHeight","imageSubresource","imageOffset","imageExtent",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOO", kwlist, &bufferOffset, &bufferRowLength, &bufferImageHeight, &imageSubresource, &imageOffset, &imageExtent)) return -1;

                if (bufferOffset != NULL && bufferOffset != Py_None) {
                
                    (self->base)->bufferOffset = PyLong_AsLong(bufferOffset);
                
 } 

                if (bufferRowLength != NULL && bufferRowLength != Py_None) {
                (self->base)->bufferRowLength = (uint32_t) PyLong_AsLong(bufferRowLength);
 } 

                if (bufferImageHeight != NULL && bufferImageHeight != Py_None) {
                (self->base)->bufferImageHeight = (uint32_t) PyLong_AsLong(bufferImageHeight);
 } 

                if (imageSubresource != NULL && imageSubresource != Py_None) {
                
                    (self->base)->imageSubresource = *(((PyVkImageSubresourceLayers*)imageSubresource)->base);
                
 } 

                if (imageOffset != NULL && imageOffset != Py_None) {
                
                    (self->base)->imageOffset = *(((PyVkOffset3D*)imageOffset)->base);
                
 } 

                if (imageExtent != NULL && imageExtent != Py_None) {
                
                    (self->base)->imageExtent = *(((PyVkExtent3D*)imageExtent)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkBufferImageCopyType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkBufferImageCopy", sizeof(PyVkBufferImageCopy), 0,
                (destructor)PyVkBufferImageCopy_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkBufferImageCopy object",0,0,0,0,0,0,0,0,
                PyVkBufferImageCopy_getsetters,0,0,0,0,0,(initproc)PyVkBufferImageCopy_init,0,PyVkBufferImageCopy_new,};
        
            static void PyVkImageResolve_del(PyVkImageResolve* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkImageResolve_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkImageResolve *self;
                self = (PyVkImageResolve *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkImageResolve));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageResolve");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkImageResolve_getsetters[] = {
                {NULL}};

            static int
            PyVkImageResolve_init(PyVkImageResolve *self, PyObject *args, PyObject *kwds) {
            PyObject* srcSubresource = NULL;
PyObject* srcOffset = NULL;
PyObject* dstSubresource = NULL;
PyObject* dstOffset = NULL;
PyObject* extent = NULL;
static char *kwlist[] = {"srcSubresource","srcOffset","dstSubresource","dstOffset","extent",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &srcSubresource, &srcOffset, &dstSubresource, &dstOffset, &extent)) return -1;

                if (srcSubresource != NULL && srcSubresource != Py_None) {
                
                    (self->base)->srcSubresource = *(((PyVkImageSubresourceLayers*)srcSubresource)->base);
                
 } 

                if (srcOffset != NULL && srcOffset != Py_None) {
                
                    (self->base)->srcOffset = *(((PyVkOffset3D*)srcOffset)->base);
                
 } 

                if (dstSubresource != NULL && dstSubresource != Py_None) {
                
                    (self->base)->dstSubresource = *(((PyVkImageSubresourceLayers*)dstSubresource)->base);
                
 } 

                if (dstOffset != NULL && dstOffset != Py_None) {
                
                    (self->base)->dstOffset = *(((PyVkOffset3D*)dstOffset)->base);
                
 } 

                if (extent != NULL && extent != Py_None) {
                
                    (self->base)->extent = *(((PyVkExtent3D*)extent)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkImageResolveType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageResolve", sizeof(PyVkImageResolve), 0,
                (destructor)PyVkImageResolve_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageResolve object",0,0,0,0,0,0,0,0,
                PyVkImageResolve_getsetters,0,0,0,0,0,(initproc)PyVkImageResolve_init,0,PyVkImageResolve_new,};
        
            static void PyVkShaderModuleCreateInfo_del(PyVkShaderModuleCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkShaderModuleCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkShaderModuleCreateInfo *self;
                self = (PyVkShaderModuleCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkShaderModuleCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkShaderModuleCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkShaderModuleCreateInfo_getpNext(PyVkShaderModuleCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkShaderModuleCreateInfo_getcodeSize(PyVkShaderModuleCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->codeSize);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkShaderModuleCreateInfo_getpCode(PyVkShaderModuleCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (*((self->base)->pCode)));
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkShaderModuleCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkShaderModuleCreateInfo_getpNext, NULL, "", NULL},
                
                    { "codeSize", (getter)PyVkShaderModuleCreateInfo_getcodeSize, NULL, "", NULL},
                
                    { "pCode", (getter)PyVkShaderModuleCreateInfo_getpCode, NULL, "", NULL},
                {NULL}};

            static int
            PyVkShaderModuleCreateInfo_init(PyVkShaderModuleCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* codeSize = NULL;
PyObject* pCode = NULL;
static char *kwlist[] = {"sType","pNext","flags","codeSize","pCode",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &flags, &codeSize, &pCode)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (codeSize != NULL && codeSize != Py_None) {
                (self->base)->codeSize = (size_t) PyLong_AsLong(codeSize);
 } 

                if (pCode != NULL && pCode != Py_None) {
                
        uint32_t tmp82853590 = (uint32_t) PyLong_AsLong(pCode);
        uint32_t *tmp15841621 = malloc(sizeof(uint32_t));
        memcpy(tmp15841621, &tmp82853590, sizeof(uint32_t));
        (self->base)->pCode = tmp15841621;
        
 } 

return 0; }
            static PyTypeObject PyVkShaderModuleCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkShaderModuleCreateInfo", sizeof(PyVkShaderModuleCreateInfo), 0,
                (destructor)PyVkShaderModuleCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkShaderModuleCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkShaderModuleCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkShaderModuleCreateInfo_init,0,PyVkShaderModuleCreateInfo_new,};
        
            static void PyVkDescriptorSetLayoutBinding_del(PyVkDescriptorSetLayoutBinding* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDescriptorSetLayoutBinding_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDescriptorSetLayoutBinding *self;
                self = (PyVkDescriptorSetLayoutBinding *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDescriptorSetLayoutBinding));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDescriptorSetLayoutBinding");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDescriptorSetLayoutBinding_getbinding(PyVkDescriptorSetLayoutBinding *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->binding);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDescriptorSetLayoutBinding_getdescriptorCount(PyVkDescriptorSetLayoutBinding *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->descriptorCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDescriptorSetLayoutBinding_getsetters[] = {
                
                    { "binding", (getter)PyVkDescriptorSetLayoutBinding_getbinding, NULL, "", NULL},
                
                    { "descriptorCount", (getter)PyVkDescriptorSetLayoutBinding_getdescriptorCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDescriptorSetLayoutBinding_init(PyVkDescriptorSetLayoutBinding *self, PyObject *args, PyObject *kwds) {
            PyObject* binding = NULL;
PyObject* descriptorType = NULL;
PyObject* descriptorCount = NULL;
PyObject* stageFlags = NULL;
PyObject* pImmutableSamplers = NULL;
static char *kwlist[] = {"binding","descriptorType","descriptorCount","stageFlags","pImmutableSamplers",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &binding, &descriptorType, &descriptorCount, &stageFlags, &pImmutableSamplers)) return -1;

                if (binding != NULL && binding != Py_None) {
                (self->base)->binding = (uint32_t) PyLong_AsLong(binding);
 } 

                if (descriptorType != NULL && descriptorType != Py_None) {
                
                    (self->base)->descriptorType = PyLong_AsLong(descriptorType);
                
 } 

                if (descriptorCount != NULL && descriptorCount != Py_None) {
                (self->base)->descriptorCount = (uint32_t) PyLong_AsLong(descriptorCount);
 } 

                if (stageFlags != NULL && stageFlags != Py_None) {
                
                    (self->base)->stageFlags = PyLong_AsLong(stageFlags);
                
 } 

                if (pImmutableSamplers != NULL && pImmutableSamplers != Py_None) {
                
                (self->base)->pImmutableSamplers = PyCapsule_GetPointer(pImmutableSamplers, "VkSampler");
            
 } 

return 0; }
            static PyTypeObject PyVkDescriptorSetLayoutBindingType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDescriptorSetLayoutBinding", sizeof(PyVkDescriptorSetLayoutBinding), 0,
                (destructor)PyVkDescriptorSetLayoutBinding_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDescriptorSetLayoutBinding object",0,0,0,0,0,0,0,0,
                PyVkDescriptorSetLayoutBinding_getsetters,0,0,0,0,0,(initproc)PyVkDescriptorSetLayoutBinding_init,0,PyVkDescriptorSetLayoutBinding_new,};
        
            static void PyVkDescriptorSetLayoutCreateInfo_del(PyVkDescriptorSetLayoutCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDescriptorSetLayoutCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDescriptorSetLayoutCreateInfo *self;
                self = (PyVkDescriptorSetLayoutCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDescriptorSetLayoutCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDescriptorSetLayoutCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDescriptorSetLayoutCreateInfo_getpNext(PyVkDescriptorSetLayoutCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDescriptorSetLayoutCreateInfo_getbindingCount(PyVkDescriptorSetLayoutCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->bindingCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDescriptorSetLayoutCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkDescriptorSetLayoutCreateInfo_getpNext, NULL, "", NULL},
                
                    { "bindingCount", (getter)PyVkDescriptorSetLayoutCreateInfo_getbindingCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDescriptorSetLayoutCreateInfo_init(PyVkDescriptorSetLayoutCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* bindingCount = NULL;
PyObject* pBindings = NULL;
static char *kwlist[] = {"sType","pNext","flags","bindingCount","pBindings",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &flags, &bindingCount, &pBindings)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (bindingCount != NULL && bindingCount != Py_None) {
                (self->base)->bindingCount = (uint32_t) PyLong_AsLong(bindingCount);
 } 

                if (pBindings != NULL && pBindings != Py_None) {
                
                    (self->base)->pBindings = (((PyVkDescriptorSetLayoutBinding*)pBindings)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkDescriptorSetLayoutCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDescriptorSetLayoutCreateInfo", sizeof(PyVkDescriptorSetLayoutCreateInfo), 0,
                (destructor)PyVkDescriptorSetLayoutCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDescriptorSetLayoutCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkDescriptorSetLayoutCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkDescriptorSetLayoutCreateInfo_init,0,PyVkDescriptorSetLayoutCreateInfo_new,};
        
            static void PyVkDescriptorPoolSize_del(PyVkDescriptorPoolSize* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDescriptorPoolSize_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDescriptorPoolSize *self;
                self = (PyVkDescriptorPoolSize *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDescriptorPoolSize));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDescriptorPoolSize");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDescriptorPoolSize_getdescriptorCount(PyVkDescriptorPoolSize *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->descriptorCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDescriptorPoolSize_getsetters[] = {
                
                    { "descriptorCount", (getter)PyVkDescriptorPoolSize_getdescriptorCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDescriptorPoolSize_init(PyVkDescriptorPoolSize *self, PyObject *args, PyObject *kwds) {
            PyObject* type = NULL;
PyObject* descriptorCount = NULL;
static char *kwlist[] = {"type","descriptorCount",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OO", kwlist, &type, &descriptorCount)) return -1;

                if (type != NULL && type != Py_None) {
                
                    (self->base)->type = PyLong_AsLong(type);
                
 } 

                if (descriptorCount != NULL && descriptorCount != Py_None) {
                (self->base)->descriptorCount = (uint32_t) PyLong_AsLong(descriptorCount);
 } 

return 0; }
            static PyTypeObject PyVkDescriptorPoolSizeType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDescriptorPoolSize", sizeof(PyVkDescriptorPoolSize), 0,
                (destructor)PyVkDescriptorPoolSize_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDescriptorPoolSize object",0,0,0,0,0,0,0,0,
                PyVkDescriptorPoolSize_getsetters,0,0,0,0,0,(initproc)PyVkDescriptorPoolSize_init,0,PyVkDescriptorPoolSize_new,};
        
            static void PyVkDescriptorPoolCreateInfo_del(PyVkDescriptorPoolCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDescriptorPoolCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDescriptorPoolCreateInfo *self;
                self = (PyVkDescriptorPoolCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDescriptorPoolCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDescriptorPoolCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDescriptorPoolCreateInfo_getpNext(PyVkDescriptorPoolCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDescriptorPoolCreateInfo_getmaxSets(PyVkDescriptorPoolCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxSets);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDescriptorPoolCreateInfo_getpoolSizeCount(PyVkDescriptorPoolCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->poolSizeCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDescriptorPoolCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkDescriptorPoolCreateInfo_getpNext, NULL, "", NULL},
                
                    { "maxSets", (getter)PyVkDescriptorPoolCreateInfo_getmaxSets, NULL, "", NULL},
                
                    { "poolSizeCount", (getter)PyVkDescriptorPoolCreateInfo_getpoolSizeCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDescriptorPoolCreateInfo_init(PyVkDescriptorPoolCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* maxSets = NULL;
PyObject* poolSizeCount = NULL;
PyObject* pPoolSizes = NULL;
static char *kwlist[] = {"sType","pNext","flags","maxSets","poolSizeCount","pPoolSizes",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOO", kwlist, &sType, &pNext, &flags, &maxSets, &poolSizeCount, &pPoolSizes)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (maxSets != NULL && maxSets != Py_None) {
                (self->base)->maxSets = (uint32_t) PyLong_AsLong(maxSets);
 } 

                if (poolSizeCount != NULL && poolSizeCount != Py_None) {
                (self->base)->poolSizeCount = (uint32_t) PyLong_AsLong(poolSizeCount);
 } 

                if (pPoolSizes != NULL && pPoolSizes != Py_None) {
                
                    (self->base)->pPoolSizes = (((PyVkDescriptorPoolSize*)pPoolSizes)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkDescriptorPoolCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDescriptorPoolCreateInfo", sizeof(PyVkDescriptorPoolCreateInfo), 0,
                (destructor)PyVkDescriptorPoolCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDescriptorPoolCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkDescriptorPoolCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkDescriptorPoolCreateInfo_init,0,PyVkDescriptorPoolCreateInfo_new,};
        
            static void PyVkDescriptorSetAllocateInfo_del(PyVkDescriptorSetAllocateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDescriptorSetAllocateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDescriptorSetAllocateInfo *self;
                self = (PyVkDescriptorSetAllocateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDescriptorSetAllocateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDescriptorSetAllocateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDescriptorSetAllocateInfo_getpNext(PyVkDescriptorSetAllocateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDescriptorSetAllocateInfo_getdescriptorSetCount(PyVkDescriptorSetAllocateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->descriptorSetCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDescriptorSetAllocateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkDescriptorSetAllocateInfo_getpNext, NULL, "", NULL},
                
                    { "descriptorSetCount", (getter)PyVkDescriptorSetAllocateInfo_getdescriptorSetCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDescriptorSetAllocateInfo_init(PyVkDescriptorSetAllocateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* descriptorPool = NULL;
PyObject* descriptorSetCount = NULL;
PyObject* pSetLayouts = NULL;
static char *kwlist[] = {"sType","pNext","descriptorPool","descriptorSetCount","pSetLayouts",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &descriptorPool, &descriptorSetCount, &pSetLayouts)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (descriptorPool != NULL && descriptorPool != Py_None) {
                
                (self->base)->descriptorPool = PyCapsule_GetPointer(descriptorPool, "VkDescriptorPool");
            
 } 

                if (descriptorSetCount != NULL && descriptorSetCount != Py_None) {
                (self->base)->descriptorSetCount = (uint32_t) PyLong_AsLong(descriptorSetCount);
 } 

                if (pSetLayouts != NULL && pSetLayouts != Py_None) {
                
                (self->base)->pSetLayouts = PyCapsule_GetPointer(pSetLayouts, "VkDescriptorSetLayout");
            
 } 

return 0; }
            static PyTypeObject PyVkDescriptorSetAllocateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDescriptorSetAllocateInfo", sizeof(PyVkDescriptorSetAllocateInfo), 0,
                (destructor)PyVkDescriptorSetAllocateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDescriptorSetAllocateInfo object",0,0,0,0,0,0,0,0,
                PyVkDescriptorSetAllocateInfo_getsetters,0,0,0,0,0,(initproc)PyVkDescriptorSetAllocateInfo_init,0,PyVkDescriptorSetAllocateInfo_new,};
        
            static void PyVkSpecializationMapEntry_del(PyVkSpecializationMapEntry* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSpecializationMapEntry_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSpecializationMapEntry *self;
                self = (PyVkSpecializationMapEntry *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSpecializationMapEntry));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSpecializationMapEntry");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkSpecializationMapEntry_getconstantID(PyVkSpecializationMapEntry *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->constantID);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSpecializationMapEntry_getoffset(PyVkSpecializationMapEntry *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->offset);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSpecializationMapEntry_getsize(PyVkSpecializationMapEntry *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->size);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkSpecializationMapEntry_getsetters[] = {
                
                    { "constantID", (getter)PyVkSpecializationMapEntry_getconstantID, NULL, "", NULL},
                
                    { "offset", (getter)PyVkSpecializationMapEntry_getoffset, NULL, "", NULL},
                
                    { "size", (getter)PyVkSpecializationMapEntry_getsize, NULL, "", NULL},
                {NULL}};

            static int
            PyVkSpecializationMapEntry_init(PyVkSpecializationMapEntry *self, PyObject *args, PyObject *kwds) {
            PyObject* constantID = NULL;
PyObject* offset = NULL;
PyObject* size = NULL;
static char *kwlist[] = {"constantID","offset","size",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &constantID, &offset, &size)) return -1;

                if (constantID != NULL && constantID != Py_None) {
                (self->base)->constantID = (uint32_t) PyLong_AsLong(constantID);
 } 

                if (offset != NULL && offset != Py_None) {
                (self->base)->offset = (uint32_t) PyLong_AsLong(offset);
 } 

                if (size != NULL && size != Py_None) {
                (self->base)->size = (size_t) PyLong_AsLong(size);
 } 

return 0; }
            static PyTypeObject PyVkSpecializationMapEntryType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSpecializationMapEntry", sizeof(PyVkSpecializationMapEntry), 0,
                (destructor)PyVkSpecializationMapEntry_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSpecializationMapEntry object",0,0,0,0,0,0,0,0,
                PyVkSpecializationMapEntry_getsetters,0,0,0,0,0,(initproc)PyVkSpecializationMapEntry_init,0,PyVkSpecializationMapEntry_new,};
        
            static void PyVkSpecializationInfo_del(PyVkSpecializationInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSpecializationInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSpecializationInfo *self;
                self = (PyVkSpecializationInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSpecializationInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSpecializationInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkSpecializationInfo_getmapEntryCount(PyVkSpecializationInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->mapEntryCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSpecializationInfo_getdataSize(PyVkSpecializationInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->dataSize);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSpecializationInfo_getpData(PyVkSpecializationInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkSpecializationInfo_getsetters[] = {
                
                    { "mapEntryCount", (getter)PyVkSpecializationInfo_getmapEntryCount, NULL, "", NULL},
                
                    { "dataSize", (getter)PyVkSpecializationInfo_getdataSize, NULL, "", NULL},
                
                    { "pData", (getter)PyVkSpecializationInfo_getpData, NULL, "", NULL},
                {NULL}};

            static int
            PyVkSpecializationInfo_init(PyVkSpecializationInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* mapEntryCount = NULL;
PyObject* pMapEntries = NULL;
PyObject* dataSize = NULL;
PyObject* pData = NULL;
static char *kwlist[] = {"mapEntryCount","pMapEntries","dataSize","pData",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &mapEntryCount, &pMapEntries, &dataSize, &pData)) return -1;

                if (mapEntryCount != NULL && mapEntryCount != Py_None) {
                (self->base)->mapEntryCount = (uint32_t) PyLong_AsLong(mapEntryCount);
 } 

                if (pMapEntries != NULL && pMapEntries != Py_None) {
                
                    (self->base)->pMapEntries = (((PyVkSpecializationMapEntry*)pMapEntries)->base);
                
 } 

                if (dataSize != NULL && dataSize != Py_None) {
                (self->base)->dataSize = (size_t) PyLong_AsLong(dataSize);
 } 

                if (pData != NULL && pData != Py_None) {
                (self->base)->pData = NULL;
 } 

return 0; }
            static PyTypeObject PyVkSpecializationInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSpecializationInfo", sizeof(PyVkSpecializationInfo), 0,
                (destructor)PyVkSpecializationInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSpecializationInfo object",0,0,0,0,0,0,0,0,
                PyVkSpecializationInfo_getsetters,0,0,0,0,0,(initproc)PyVkSpecializationInfo_init,0,PyVkSpecializationInfo_new,};
        
            static void PyVkPipelineShaderStageCreateInfo_del(PyVkPipelineShaderStageCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPipelineShaderStageCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPipelineShaderStageCreateInfo *self;
                self = (PyVkPipelineShaderStageCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPipelineShaderStageCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineShaderStageCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPipelineShaderStageCreateInfo_getpNext(PyVkPipelineShaderStageCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineShaderStageCreateInfo_getpName(PyVkPipelineShaderStageCreateInfo *self, void *closure){
            PyObject* value = PyUnicode_FromString((const char *) (self->base)->pName);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPipelineShaderStageCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkPipelineShaderStageCreateInfo_getpNext, NULL, "", NULL},
                
                    { "pName", (getter)PyVkPipelineShaderStageCreateInfo_getpName, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPipelineShaderStageCreateInfo_init(PyVkPipelineShaderStageCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* stage = NULL;
PyObject* module = NULL;
PyObject* pName = NULL;
PyObject* pSpecializationInfo = NULL;
static char *kwlist[] = {"sType","pNext","flags","stage","module","pName","pSpecializationInfo",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOO", kwlist, &sType, &pNext, &flags, &stage, &module, &pName, &pSpecializationInfo)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (stage != NULL && stage != Py_None) {
                
                    (self->base)->stage = PyLong_AsLong(stage);
                
 } 

                if (module != NULL && module != Py_None) {
                
                (self->base)->module = PyCapsule_GetPointer(module, "VkShaderModule");
            
 } 

                if (pName != NULL && pName != Py_None) {
                
        PyObject * tmp11347875 = PyUnicode_AsASCIIString(pName);
        char* tmp21234075 = PyBytes_AsString(tmp11347875);
        strcpy((self->base)->pName, tmp21234075);
        Py_DECREF(tmp11347875);
        
 } 

                if (pSpecializationInfo != NULL && pSpecializationInfo != Py_None) {
                
                    (self->base)->pSpecializationInfo = (((PyVkSpecializationInfo*)pSpecializationInfo)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkPipelineShaderStageCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineShaderStageCreateInfo", sizeof(PyVkPipelineShaderStageCreateInfo), 0,
                (destructor)PyVkPipelineShaderStageCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineShaderStageCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineShaderStageCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineShaderStageCreateInfo_init,0,PyVkPipelineShaderStageCreateInfo_new,};
        
            static void PyVkComputePipelineCreateInfo_del(PyVkComputePipelineCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkComputePipelineCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkComputePipelineCreateInfo *self;
                self = (PyVkComputePipelineCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkComputePipelineCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkComputePipelineCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkComputePipelineCreateInfo_getpNext(PyVkComputePipelineCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkComputePipelineCreateInfo_getbasePipelineIndex(PyVkComputePipelineCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->basePipelineIndex);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkComputePipelineCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkComputePipelineCreateInfo_getpNext, NULL, "", NULL},
                
                    { "basePipelineIndex", (getter)PyVkComputePipelineCreateInfo_getbasePipelineIndex, NULL, "", NULL},
                {NULL}};

            static int
            PyVkComputePipelineCreateInfo_init(PyVkComputePipelineCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* stage = NULL;
PyObject* layout = NULL;
PyObject* basePipelineHandle = NULL;
PyObject* basePipelineIndex = NULL;
static char *kwlist[] = {"sType","pNext","flags","stage","layout","basePipelineHandle","basePipelineIndex",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOO", kwlist, &sType, &pNext, &flags, &stage, &layout, &basePipelineHandle, &basePipelineIndex)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (stage != NULL && stage != Py_None) {
                
                    (self->base)->stage = *(((PyVkPipelineShaderStageCreateInfo*)stage)->base);
                
 } 

                if (layout != NULL && layout != Py_None) {
                
                (self->base)->layout = PyCapsule_GetPointer(layout, "VkPipelineLayout");
            
 } 

                if (basePipelineHandle != NULL && basePipelineHandle != Py_None) {
                
                (self->base)->basePipelineHandle = PyCapsule_GetPointer(basePipelineHandle, "VkPipeline");
            
 } 

                if (basePipelineIndex != NULL && basePipelineIndex != Py_None) {
                (self->base)->basePipelineIndex = (int32_t) PyLong_AsLong(basePipelineIndex);
 } 

return 0; }
            static PyTypeObject PyVkComputePipelineCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkComputePipelineCreateInfo", sizeof(PyVkComputePipelineCreateInfo), 0,
                (destructor)PyVkComputePipelineCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkComputePipelineCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkComputePipelineCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkComputePipelineCreateInfo_init,0,PyVkComputePipelineCreateInfo_new,};
        
            static void PyVkVertexInputBindingDescription_del(PyVkVertexInputBindingDescription* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkVertexInputBindingDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkVertexInputBindingDescription *self;
                self = (PyVkVertexInputBindingDescription *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkVertexInputBindingDescription));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkVertexInputBindingDescription");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkVertexInputBindingDescription_getbinding(PyVkVertexInputBindingDescription *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->binding);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkVertexInputBindingDescription_getstride(PyVkVertexInputBindingDescription *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->stride);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkVertexInputBindingDescription_getsetters[] = {
                
                    { "binding", (getter)PyVkVertexInputBindingDescription_getbinding, NULL, "", NULL},
                
                    { "stride", (getter)PyVkVertexInputBindingDescription_getstride, NULL, "", NULL},
                {NULL}};

            static int
            PyVkVertexInputBindingDescription_init(PyVkVertexInputBindingDescription *self, PyObject *args, PyObject *kwds) {
            PyObject* binding = NULL;
PyObject* stride = NULL;
PyObject* inputRate = NULL;
static char *kwlist[] = {"binding","stride","inputRate",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &binding, &stride, &inputRate)) return -1;

                if (binding != NULL && binding != Py_None) {
                (self->base)->binding = (uint32_t) PyLong_AsLong(binding);
 } 

                if (stride != NULL && stride != Py_None) {
                (self->base)->stride = (uint32_t) PyLong_AsLong(stride);
 } 

                if (inputRate != NULL && inputRate != Py_None) {
                
                    (self->base)->inputRate = PyLong_AsLong(inputRate);
                
 } 

return 0; }
            static PyTypeObject PyVkVertexInputBindingDescriptionType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkVertexInputBindingDescription", sizeof(PyVkVertexInputBindingDescription), 0,
                (destructor)PyVkVertexInputBindingDescription_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkVertexInputBindingDescription object",0,0,0,0,0,0,0,0,
                PyVkVertexInputBindingDescription_getsetters,0,0,0,0,0,(initproc)PyVkVertexInputBindingDescription_init,0,PyVkVertexInputBindingDescription_new,};
        
            static void PyVkVertexInputAttributeDescription_del(PyVkVertexInputAttributeDescription* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkVertexInputAttributeDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkVertexInputAttributeDescription *self;
                self = (PyVkVertexInputAttributeDescription *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkVertexInputAttributeDescription));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkVertexInputAttributeDescription");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkVertexInputAttributeDescription_getlocation(PyVkVertexInputAttributeDescription *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->location);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkVertexInputAttributeDescription_getbinding(PyVkVertexInputAttributeDescription *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->binding);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkVertexInputAttributeDescription_getoffset(PyVkVertexInputAttributeDescription *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->offset);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkVertexInputAttributeDescription_getsetters[] = {
                
                    { "location", (getter)PyVkVertexInputAttributeDescription_getlocation, NULL, "", NULL},
                
                    { "binding", (getter)PyVkVertexInputAttributeDescription_getbinding, NULL, "", NULL},
                
                    { "offset", (getter)PyVkVertexInputAttributeDescription_getoffset, NULL, "", NULL},
                {NULL}};

            static int
            PyVkVertexInputAttributeDescription_init(PyVkVertexInputAttributeDescription *self, PyObject *args, PyObject *kwds) {
            PyObject* location = NULL;
PyObject* binding = NULL;
PyObject* format = NULL;
PyObject* offset = NULL;
static char *kwlist[] = {"location","binding","format","offset",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &location, &binding, &format, &offset)) return -1;

                if (location != NULL && location != Py_None) {
                (self->base)->location = (uint32_t) PyLong_AsLong(location);
 } 

                if (binding != NULL && binding != Py_None) {
                (self->base)->binding = (uint32_t) PyLong_AsLong(binding);
 } 

                if (format != NULL && format != Py_None) {
                
                    (self->base)->format = PyLong_AsLong(format);
                
 } 

                if (offset != NULL && offset != Py_None) {
                (self->base)->offset = (uint32_t) PyLong_AsLong(offset);
 } 

return 0; }
            static PyTypeObject PyVkVertexInputAttributeDescriptionType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkVertexInputAttributeDescription", sizeof(PyVkVertexInputAttributeDescription), 0,
                (destructor)PyVkVertexInputAttributeDescription_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkVertexInputAttributeDescription object",0,0,0,0,0,0,0,0,
                PyVkVertexInputAttributeDescription_getsetters,0,0,0,0,0,(initproc)PyVkVertexInputAttributeDescription_init,0,PyVkVertexInputAttributeDescription_new,};
        
            static void PyVkPipelineVertexInputStateCreateInfo_del(PyVkPipelineVertexInputStateCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPipelineVertexInputStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPipelineVertexInputStateCreateInfo *self;
                self = (PyVkPipelineVertexInputStateCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPipelineVertexInputStateCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineVertexInputStateCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPipelineVertexInputStateCreateInfo_getpNext(PyVkPipelineVertexInputStateCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineVertexInputStateCreateInfo_getvertexBindingDescriptionCount(PyVkPipelineVertexInputStateCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->vertexBindingDescriptionCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineVertexInputStateCreateInfo_getvertexAttributeDescriptionCount(PyVkPipelineVertexInputStateCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->vertexAttributeDescriptionCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPipelineVertexInputStateCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkPipelineVertexInputStateCreateInfo_getpNext, NULL, "", NULL},
                
                    { "vertexBindingDescriptionCount", (getter)PyVkPipelineVertexInputStateCreateInfo_getvertexBindingDescriptionCount, NULL, "", NULL},
                
                    { "vertexAttributeDescriptionCount", (getter)PyVkPipelineVertexInputStateCreateInfo_getvertexAttributeDescriptionCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPipelineVertexInputStateCreateInfo_init(PyVkPipelineVertexInputStateCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* vertexBindingDescriptionCount = NULL;
PyObject* pVertexBindingDescriptions = NULL;
PyObject* vertexAttributeDescriptionCount = NULL;
PyObject* pVertexAttributeDescriptions = NULL;
static char *kwlist[] = {"sType","pNext","flags","vertexBindingDescriptionCount","pVertexBindingDescriptions","vertexAttributeDescriptionCount","pVertexAttributeDescriptions",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOO", kwlist, &sType, &pNext, &flags, &vertexBindingDescriptionCount, &pVertexBindingDescriptions, &vertexAttributeDescriptionCount, &pVertexAttributeDescriptions)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (vertexBindingDescriptionCount != NULL && vertexBindingDescriptionCount != Py_None) {
                (self->base)->vertexBindingDescriptionCount = (uint32_t) PyLong_AsLong(vertexBindingDescriptionCount);
 } 

                if (pVertexBindingDescriptions != NULL && pVertexBindingDescriptions != Py_None) {
                
                    (self->base)->pVertexBindingDescriptions = (((PyVkVertexInputBindingDescription*)pVertexBindingDescriptions)->base);
                
 } 

                if (vertexAttributeDescriptionCount != NULL && vertexAttributeDescriptionCount != Py_None) {
                (self->base)->vertexAttributeDescriptionCount = (uint32_t) PyLong_AsLong(vertexAttributeDescriptionCount);
 } 

                if (pVertexAttributeDescriptions != NULL && pVertexAttributeDescriptions != Py_None) {
                
                    (self->base)->pVertexAttributeDescriptions = (((PyVkVertexInputAttributeDescription*)pVertexAttributeDescriptions)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkPipelineVertexInputStateCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineVertexInputStateCreateInfo", sizeof(PyVkPipelineVertexInputStateCreateInfo), 0,
                (destructor)PyVkPipelineVertexInputStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineVertexInputStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineVertexInputStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineVertexInputStateCreateInfo_init,0,PyVkPipelineVertexInputStateCreateInfo_new,};
        
            static void PyVkPipelineInputAssemblyStateCreateInfo_del(PyVkPipelineInputAssemblyStateCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPipelineInputAssemblyStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPipelineInputAssemblyStateCreateInfo *self;
                self = (PyVkPipelineInputAssemblyStateCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPipelineInputAssemblyStateCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineInputAssemblyStateCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPipelineInputAssemblyStateCreateInfo_getpNext(PyVkPipelineInputAssemblyStateCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPipelineInputAssemblyStateCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkPipelineInputAssemblyStateCreateInfo_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPipelineInputAssemblyStateCreateInfo_init(PyVkPipelineInputAssemblyStateCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* topology = NULL;
PyObject* primitiveRestartEnable = NULL;
static char *kwlist[] = {"sType","pNext","flags","topology","primitiveRestartEnable",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &flags, &topology, &primitiveRestartEnable)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (topology != NULL && topology != Py_None) {
                
                    (self->base)->topology = PyLong_AsLong(topology);
                
 } 

                if (primitiveRestartEnable != NULL && primitiveRestartEnable != Py_None) {
                
                    (self->base)->primitiveRestartEnable = PyLong_AsLong(primitiveRestartEnable);
                
 } 

return 0; }
            static PyTypeObject PyVkPipelineInputAssemblyStateCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineInputAssemblyStateCreateInfo", sizeof(PyVkPipelineInputAssemblyStateCreateInfo), 0,
                (destructor)PyVkPipelineInputAssemblyStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineInputAssemblyStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineInputAssemblyStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineInputAssemblyStateCreateInfo_init,0,PyVkPipelineInputAssemblyStateCreateInfo_new,};
        
            static void PyVkPipelineTessellationStateCreateInfo_del(PyVkPipelineTessellationStateCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPipelineTessellationStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPipelineTessellationStateCreateInfo *self;
                self = (PyVkPipelineTessellationStateCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPipelineTessellationStateCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineTessellationStateCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPipelineTessellationStateCreateInfo_getpNext(PyVkPipelineTessellationStateCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineTessellationStateCreateInfo_getpatchControlPoints(PyVkPipelineTessellationStateCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->patchControlPoints);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPipelineTessellationStateCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkPipelineTessellationStateCreateInfo_getpNext, NULL, "", NULL},
                
                    { "patchControlPoints", (getter)PyVkPipelineTessellationStateCreateInfo_getpatchControlPoints, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPipelineTessellationStateCreateInfo_init(PyVkPipelineTessellationStateCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* patchControlPoints = NULL;
static char *kwlist[] = {"sType","pNext","flags","patchControlPoints",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &sType, &pNext, &flags, &patchControlPoints)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (patchControlPoints != NULL && patchControlPoints != Py_None) {
                (self->base)->patchControlPoints = (uint32_t) PyLong_AsLong(patchControlPoints);
 } 

return 0; }
            static PyTypeObject PyVkPipelineTessellationStateCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineTessellationStateCreateInfo", sizeof(PyVkPipelineTessellationStateCreateInfo), 0,
                (destructor)PyVkPipelineTessellationStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineTessellationStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineTessellationStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineTessellationStateCreateInfo_init,0,PyVkPipelineTessellationStateCreateInfo_new,};
        
            static void PyVkPipelineViewportStateCreateInfo_del(PyVkPipelineViewportStateCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPipelineViewportStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPipelineViewportStateCreateInfo *self;
                self = (PyVkPipelineViewportStateCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPipelineViewportStateCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineViewportStateCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPipelineViewportStateCreateInfo_getpNext(PyVkPipelineViewportStateCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineViewportStateCreateInfo_getviewportCount(PyVkPipelineViewportStateCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->viewportCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineViewportStateCreateInfo_getscissorCount(PyVkPipelineViewportStateCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->scissorCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPipelineViewportStateCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkPipelineViewportStateCreateInfo_getpNext, NULL, "", NULL},
                
                    { "viewportCount", (getter)PyVkPipelineViewportStateCreateInfo_getviewportCount, NULL, "", NULL},
                
                    { "scissorCount", (getter)PyVkPipelineViewportStateCreateInfo_getscissorCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPipelineViewportStateCreateInfo_init(PyVkPipelineViewportStateCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* viewportCount = NULL;
PyObject* pViewports = NULL;
PyObject* scissorCount = NULL;
PyObject* pScissors = NULL;
static char *kwlist[] = {"sType","pNext","flags","viewportCount","pViewports","scissorCount","pScissors",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOO", kwlist, &sType, &pNext, &flags, &viewportCount, &pViewports, &scissorCount, &pScissors)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (viewportCount != NULL && viewportCount != Py_None) {
                (self->base)->viewportCount = (uint32_t) PyLong_AsLong(viewportCount);
 } 

                if (pViewports != NULL && pViewports != Py_None) {
                
                    (self->base)->pViewports = (((PyVkViewport*)pViewports)->base);
                
 } 

                if (scissorCount != NULL && scissorCount != Py_None) {
                (self->base)->scissorCount = (uint32_t) PyLong_AsLong(scissorCount);
 } 

                if (pScissors != NULL && pScissors != Py_None) {
                
                    (self->base)->pScissors = (((PyVkRect2D*)pScissors)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkPipelineViewportStateCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineViewportStateCreateInfo", sizeof(PyVkPipelineViewportStateCreateInfo), 0,
                (destructor)PyVkPipelineViewportStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineViewportStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineViewportStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineViewportStateCreateInfo_init,0,PyVkPipelineViewportStateCreateInfo_new,};
        
            static void PyVkPipelineRasterizationStateCreateInfo_del(PyVkPipelineRasterizationStateCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPipelineRasterizationStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPipelineRasterizationStateCreateInfo *self;
                self = (PyVkPipelineRasterizationStateCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPipelineRasterizationStateCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineRasterizationStateCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPipelineRasterizationStateCreateInfo_getpNext(PyVkPipelineRasterizationStateCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineRasterizationStateCreateInfo_getdepthBiasConstantFactor(PyVkPipelineRasterizationStateCreateInfo *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->depthBiasConstantFactor);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineRasterizationStateCreateInfo_getdepthBiasClamp(PyVkPipelineRasterizationStateCreateInfo *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->depthBiasClamp);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineRasterizationStateCreateInfo_getdepthBiasSlopeFactor(PyVkPipelineRasterizationStateCreateInfo *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->depthBiasSlopeFactor);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineRasterizationStateCreateInfo_getlineWidth(PyVkPipelineRasterizationStateCreateInfo *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->lineWidth);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPipelineRasterizationStateCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkPipelineRasterizationStateCreateInfo_getpNext, NULL, "", NULL},
                
                    { "depthBiasConstantFactor", (getter)PyVkPipelineRasterizationStateCreateInfo_getdepthBiasConstantFactor, NULL, "", NULL},
                
                    { "depthBiasClamp", (getter)PyVkPipelineRasterizationStateCreateInfo_getdepthBiasClamp, NULL, "", NULL},
                
                    { "depthBiasSlopeFactor", (getter)PyVkPipelineRasterizationStateCreateInfo_getdepthBiasSlopeFactor, NULL, "", NULL},
                
                    { "lineWidth", (getter)PyVkPipelineRasterizationStateCreateInfo_getlineWidth, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPipelineRasterizationStateCreateInfo_init(PyVkPipelineRasterizationStateCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* depthClampEnable = NULL;
PyObject* rasterizerDiscardEnable = NULL;
PyObject* polygonMode = NULL;
PyObject* cullMode = NULL;
PyObject* frontFace = NULL;
PyObject* depthBiasEnable = NULL;
PyObject* depthBiasConstantFactor = NULL;
PyObject* depthBiasClamp = NULL;
PyObject* depthBiasSlopeFactor = NULL;
PyObject* lineWidth = NULL;
static char *kwlist[] = {"sType","pNext","flags","depthClampEnable","rasterizerDiscardEnable","polygonMode","cullMode","frontFace","depthBiasEnable","depthBiasConstantFactor","depthBiasClamp","depthBiasSlopeFactor","lineWidth",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOOOOOO", kwlist, &sType, &pNext, &flags, &depthClampEnable, &rasterizerDiscardEnable, &polygonMode, &cullMode, &frontFace, &depthBiasEnable, &depthBiasConstantFactor, &depthBiasClamp, &depthBiasSlopeFactor, &lineWidth)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (depthClampEnable != NULL && depthClampEnable != Py_None) {
                
                    (self->base)->depthClampEnable = PyLong_AsLong(depthClampEnable);
                
 } 

                if (rasterizerDiscardEnable != NULL && rasterizerDiscardEnable != Py_None) {
                
                    (self->base)->rasterizerDiscardEnable = PyLong_AsLong(rasterizerDiscardEnable);
                
 } 

                if (polygonMode != NULL && polygonMode != Py_None) {
                
                    (self->base)->polygonMode = PyLong_AsLong(polygonMode);
                
 } 

                if (cullMode != NULL && cullMode != Py_None) {
                
                    (self->base)->cullMode = PyLong_AsLong(cullMode);
                
 } 

                if (frontFace != NULL && frontFace != Py_None) {
                
                    (self->base)->frontFace = PyLong_AsLong(frontFace);
                
 } 

                if (depthBiasEnable != NULL && depthBiasEnable != Py_None) {
                
                    (self->base)->depthBiasEnable = PyLong_AsLong(depthBiasEnable);
                
 } 

                if (depthBiasConstantFactor != NULL && depthBiasConstantFactor != Py_None) {
                (self->base)->depthBiasConstantFactor = (float) PyFloat_AsDouble(depthBiasConstantFactor);
 } 

                if (depthBiasClamp != NULL && depthBiasClamp != Py_None) {
                (self->base)->depthBiasClamp = (float) PyFloat_AsDouble(depthBiasClamp);
 } 

                if (depthBiasSlopeFactor != NULL && depthBiasSlopeFactor != Py_None) {
                (self->base)->depthBiasSlopeFactor = (float) PyFloat_AsDouble(depthBiasSlopeFactor);
 } 

                if (lineWidth != NULL && lineWidth != Py_None) {
                (self->base)->lineWidth = (float) PyFloat_AsDouble(lineWidth);
 } 

return 0; }
            static PyTypeObject PyVkPipelineRasterizationStateCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineRasterizationStateCreateInfo", sizeof(PyVkPipelineRasterizationStateCreateInfo), 0,
                (destructor)PyVkPipelineRasterizationStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineRasterizationStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineRasterizationStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineRasterizationStateCreateInfo_init,0,PyVkPipelineRasterizationStateCreateInfo_new,};
        
            static void PyVkPipelineMultisampleStateCreateInfo_del(PyVkPipelineMultisampleStateCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPipelineMultisampleStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPipelineMultisampleStateCreateInfo *self;
                self = (PyVkPipelineMultisampleStateCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPipelineMultisampleStateCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineMultisampleStateCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPipelineMultisampleStateCreateInfo_getpNext(PyVkPipelineMultisampleStateCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineMultisampleStateCreateInfo_getminSampleShading(PyVkPipelineMultisampleStateCreateInfo *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->minSampleShading);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPipelineMultisampleStateCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkPipelineMultisampleStateCreateInfo_getpNext, NULL, "", NULL},
                
                    { "minSampleShading", (getter)PyVkPipelineMultisampleStateCreateInfo_getminSampleShading, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPipelineMultisampleStateCreateInfo_init(PyVkPipelineMultisampleStateCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* rasterizationSamples = NULL;
PyObject* sampleShadingEnable = NULL;
PyObject* minSampleShading = NULL;
PyObject* pSampleMask = NULL;
PyObject* alphaToCoverageEnable = NULL;
PyObject* alphaToOneEnable = NULL;
static char *kwlist[] = {"sType","pNext","flags","rasterizationSamples","sampleShadingEnable","minSampleShading","pSampleMask","alphaToCoverageEnable","alphaToOneEnable",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOO", kwlist, &sType, &pNext, &flags, &rasterizationSamples, &sampleShadingEnable, &minSampleShading, &pSampleMask, &alphaToCoverageEnable, &alphaToOneEnable)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (rasterizationSamples != NULL && rasterizationSamples != Py_None) {
                
                    (self->base)->rasterizationSamples = PyLong_AsLong(rasterizationSamples);
                
 } 

                if (sampleShadingEnable != NULL && sampleShadingEnable != Py_None) {
                
                    (self->base)->sampleShadingEnable = PyLong_AsLong(sampleShadingEnable);
                
 } 

                if (minSampleShading != NULL && minSampleShading != Py_None) {
                (self->base)->minSampleShading = (float) PyFloat_AsDouble(minSampleShading);
 } 

                if (pSampleMask != NULL && pSampleMask != Py_None) {
                
                    VkSampleMask tmp = PyLong_AsLong(pSampleMask);
                    (self->base)->pSampleMask = &tmp;
                
 } 

                if (alphaToCoverageEnable != NULL && alphaToCoverageEnable != Py_None) {
                
                    (self->base)->alphaToCoverageEnable = PyLong_AsLong(alphaToCoverageEnable);
                
 } 

                if (alphaToOneEnable != NULL && alphaToOneEnable != Py_None) {
                
                    (self->base)->alphaToOneEnable = PyLong_AsLong(alphaToOneEnable);
                
 } 

return 0; }
            static PyTypeObject PyVkPipelineMultisampleStateCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineMultisampleStateCreateInfo", sizeof(PyVkPipelineMultisampleStateCreateInfo), 0,
                (destructor)PyVkPipelineMultisampleStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineMultisampleStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineMultisampleStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineMultisampleStateCreateInfo_init,0,PyVkPipelineMultisampleStateCreateInfo_new,};
        
            static void PyVkPipelineColorBlendAttachmentState_del(PyVkPipelineColorBlendAttachmentState* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPipelineColorBlendAttachmentState_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPipelineColorBlendAttachmentState *self;
                self = (PyVkPipelineColorBlendAttachmentState *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPipelineColorBlendAttachmentState));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineColorBlendAttachmentState");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkPipelineColorBlendAttachmentState_getsetters[] = {
                {NULL}};

            static int
            PyVkPipelineColorBlendAttachmentState_init(PyVkPipelineColorBlendAttachmentState *self, PyObject *args, PyObject *kwds) {
            PyObject* blendEnable = NULL;
PyObject* srcColorBlendFactor = NULL;
PyObject* dstColorBlendFactor = NULL;
PyObject* colorBlendOp = NULL;
PyObject* srcAlphaBlendFactor = NULL;
PyObject* dstAlphaBlendFactor = NULL;
PyObject* alphaBlendOp = NULL;
PyObject* colorWriteMask = NULL;
static char *kwlist[] = {"blendEnable","srcColorBlendFactor","dstColorBlendFactor","colorBlendOp","srcAlphaBlendFactor","dstAlphaBlendFactor","alphaBlendOp","colorWriteMask",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOO", kwlist, &blendEnable, &srcColorBlendFactor, &dstColorBlendFactor, &colorBlendOp, &srcAlphaBlendFactor, &dstAlphaBlendFactor, &alphaBlendOp, &colorWriteMask)) return -1;

                if (blendEnable != NULL && blendEnable != Py_None) {
                
                    (self->base)->blendEnable = PyLong_AsLong(blendEnable);
                
 } 

                if (srcColorBlendFactor != NULL && srcColorBlendFactor != Py_None) {
                
                    (self->base)->srcColorBlendFactor = PyLong_AsLong(srcColorBlendFactor);
                
 } 

                if (dstColorBlendFactor != NULL && dstColorBlendFactor != Py_None) {
                
                    (self->base)->dstColorBlendFactor = PyLong_AsLong(dstColorBlendFactor);
                
 } 

                if (colorBlendOp != NULL && colorBlendOp != Py_None) {
                
                    (self->base)->colorBlendOp = PyLong_AsLong(colorBlendOp);
                
 } 

                if (srcAlphaBlendFactor != NULL && srcAlphaBlendFactor != Py_None) {
                
                    (self->base)->srcAlphaBlendFactor = PyLong_AsLong(srcAlphaBlendFactor);
                
 } 

                if (dstAlphaBlendFactor != NULL && dstAlphaBlendFactor != Py_None) {
                
                    (self->base)->dstAlphaBlendFactor = PyLong_AsLong(dstAlphaBlendFactor);
                
 } 

                if (alphaBlendOp != NULL && alphaBlendOp != Py_None) {
                
                    (self->base)->alphaBlendOp = PyLong_AsLong(alphaBlendOp);
                
 } 

                if (colorWriteMask != NULL && colorWriteMask != Py_None) {
                
                    (self->base)->colorWriteMask = PyLong_AsLong(colorWriteMask);
                
 } 

return 0; }
            static PyTypeObject PyVkPipelineColorBlendAttachmentStateType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineColorBlendAttachmentState", sizeof(PyVkPipelineColorBlendAttachmentState), 0,
                (destructor)PyVkPipelineColorBlendAttachmentState_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineColorBlendAttachmentState object",0,0,0,0,0,0,0,0,
                PyVkPipelineColorBlendAttachmentState_getsetters,0,0,0,0,0,(initproc)PyVkPipelineColorBlendAttachmentState_init,0,PyVkPipelineColorBlendAttachmentState_new,};
        
            static void PyVkPipelineColorBlendStateCreateInfo_del(PyVkPipelineColorBlendStateCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPipelineColorBlendStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPipelineColorBlendStateCreateInfo *self;
                self = (PyVkPipelineColorBlendStateCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPipelineColorBlendStateCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineColorBlendStateCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPipelineColorBlendStateCreateInfo_getpNext(PyVkPipelineColorBlendStateCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineColorBlendStateCreateInfo_getattachmentCount(PyVkPipelineColorBlendStateCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->attachmentCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineColorBlendStateCreateInfo_getblendConstants(PyVkPipelineColorBlendStateCreateInfo *self, void *closure){
            
        PyObject* value = PyList_New(0);
        int nb = sizeof((self->base)->blendConstants) / sizeof((self->base)->blendConstants[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->blendConstants[i]);
            PyList_Append(value, py_tmp);
        }
        
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPipelineColorBlendStateCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkPipelineColorBlendStateCreateInfo_getpNext, NULL, "", NULL},
                
                    { "attachmentCount", (getter)PyVkPipelineColorBlendStateCreateInfo_getattachmentCount, NULL, "", NULL},
                
                    { "blendConstants", (getter)PyVkPipelineColorBlendStateCreateInfo_getblendConstants, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPipelineColorBlendStateCreateInfo_init(PyVkPipelineColorBlendStateCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* logicOpEnable = NULL;
PyObject* logicOp = NULL;
PyObject* attachmentCount = NULL;
PyObject* pAttachments = NULL;
PyObject* blendConstants = NULL;
static char *kwlist[] = {"sType","pNext","flags","logicOpEnable","logicOp","attachmentCount","pAttachments","blendConstants",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOO", kwlist, &sType, &pNext, &flags, &logicOpEnable, &logicOp, &attachmentCount, &pAttachments, &blendConstants)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (logicOpEnable != NULL && logicOpEnable != Py_None) {
                
                    (self->base)->logicOpEnable = PyLong_AsLong(logicOpEnable);
                
 } 

                if (logicOp != NULL && logicOp != Py_None) {
                
                    (self->base)->logicOp = PyLong_AsLong(logicOp);
                
 } 

                if (attachmentCount != NULL && attachmentCount != Py_None) {
                (self->base)->attachmentCount = (uint32_t) PyLong_AsLong(attachmentCount);
 } 

                if (pAttachments != NULL && pAttachments != Py_None) {
                
                    (self->base)->pAttachments = (((PyVkPipelineColorBlendAttachmentState*)pAttachments)->base);
                
 } 

                if (blendConstants != NULL && blendConstants != Py_None) {
                
        int tmp67341306 = PyList_Size(blendConstants);
        int tmp39857273;
        for (tmp39857273 = 0; tmp39857273 < tmp67341306; tmp39857273++) {
            float tmp = (float) PyFloat_AsDouble(
            PyList_GetItem(blendConstants, tmp39857273));
            ((self->base)->blendConstants)[tmp39857273] = tmp;
        }
        
 } 

return 0; }
            static PyTypeObject PyVkPipelineColorBlendStateCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineColorBlendStateCreateInfo", sizeof(PyVkPipelineColorBlendStateCreateInfo), 0,
                (destructor)PyVkPipelineColorBlendStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineColorBlendStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineColorBlendStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineColorBlendStateCreateInfo_init,0,PyVkPipelineColorBlendStateCreateInfo_new,};
        
            static void PyVkPipelineDynamicStateCreateInfo_del(PyVkPipelineDynamicStateCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPipelineDynamicStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPipelineDynamicStateCreateInfo *self;
                self = (PyVkPipelineDynamicStateCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPipelineDynamicStateCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineDynamicStateCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPipelineDynamicStateCreateInfo_getpNext(PyVkPipelineDynamicStateCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineDynamicStateCreateInfo_getdynamicStateCount(PyVkPipelineDynamicStateCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->dynamicStateCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPipelineDynamicStateCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkPipelineDynamicStateCreateInfo_getpNext, NULL, "", NULL},
                
                    { "dynamicStateCount", (getter)PyVkPipelineDynamicStateCreateInfo_getdynamicStateCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPipelineDynamicStateCreateInfo_init(PyVkPipelineDynamicStateCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* dynamicStateCount = NULL;
PyObject* pDynamicStates = NULL;
static char *kwlist[] = {"sType","pNext","flags","dynamicStateCount","pDynamicStates",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &flags, &dynamicStateCount, &pDynamicStates)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (dynamicStateCount != NULL && dynamicStateCount != Py_None) {
                (self->base)->dynamicStateCount = (uint32_t) PyLong_AsLong(dynamicStateCount);
 } 

                if (pDynamicStates != NULL && pDynamicStates != Py_None) {
                
                    VkDynamicState tmp = PyLong_AsLong(pDynamicStates);
                    (self->base)->pDynamicStates = &tmp;
                
 } 

return 0; }
            static PyTypeObject PyVkPipelineDynamicStateCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineDynamicStateCreateInfo", sizeof(PyVkPipelineDynamicStateCreateInfo), 0,
                (destructor)PyVkPipelineDynamicStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineDynamicStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineDynamicStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineDynamicStateCreateInfo_init,0,PyVkPipelineDynamicStateCreateInfo_new,};
        
            static void PyVkStencilOpState_del(PyVkStencilOpState* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkStencilOpState_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkStencilOpState *self;
                self = (PyVkStencilOpState *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkStencilOpState));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkStencilOpState");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkStencilOpState_getcompareMask(PyVkStencilOpState *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->compareMask);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkStencilOpState_getwriteMask(PyVkStencilOpState *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->writeMask);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkStencilOpState_getreference(PyVkStencilOpState *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->reference);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkStencilOpState_getsetters[] = {
                
                    { "compareMask", (getter)PyVkStencilOpState_getcompareMask, NULL, "", NULL},
                
                    { "writeMask", (getter)PyVkStencilOpState_getwriteMask, NULL, "", NULL},
                
                    { "reference", (getter)PyVkStencilOpState_getreference, NULL, "", NULL},
                {NULL}};

            static int
            PyVkStencilOpState_init(PyVkStencilOpState *self, PyObject *args, PyObject *kwds) {
            PyObject* failOp = NULL;
PyObject* passOp = NULL;
PyObject* depthFailOp = NULL;
PyObject* compareOp = NULL;
PyObject* compareMask = NULL;
PyObject* writeMask = NULL;
PyObject* reference = NULL;
static char *kwlist[] = {"failOp","passOp","depthFailOp","compareOp","compareMask","writeMask","reference",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOO", kwlist, &failOp, &passOp, &depthFailOp, &compareOp, &compareMask, &writeMask, &reference)) return -1;

                if (failOp != NULL && failOp != Py_None) {
                
                    (self->base)->failOp = PyLong_AsLong(failOp);
                
 } 

                if (passOp != NULL && passOp != Py_None) {
                
                    (self->base)->passOp = PyLong_AsLong(passOp);
                
 } 

                if (depthFailOp != NULL && depthFailOp != Py_None) {
                
                    (self->base)->depthFailOp = PyLong_AsLong(depthFailOp);
                
 } 

                if (compareOp != NULL && compareOp != Py_None) {
                
                    (self->base)->compareOp = PyLong_AsLong(compareOp);
                
 } 

                if (compareMask != NULL && compareMask != Py_None) {
                (self->base)->compareMask = (uint32_t) PyLong_AsLong(compareMask);
 } 

                if (writeMask != NULL && writeMask != Py_None) {
                (self->base)->writeMask = (uint32_t) PyLong_AsLong(writeMask);
 } 

                if (reference != NULL && reference != Py_None) {
                (self->base)->reference = (uint32_t) PyLong_AsLong(reference);
 } 

return 0; }
            static PyTypeObject PyVkStencilOpStateType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkStencilOpState", sizeof(PyVkStencilOpState), 0,
                (destructor)PyVkStencilOpState_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkStencilOpState object",0,0,0,0,0,0,0,0,
                PyVkStencilOpState_getsetters,0,0,0,0,0,(initproc)PyVkStencilOpState_init,0,PyVkStencilOpState_new,};
        
            static void PyVkPipelineDepthStencilStateCreateInfo_del(PyVkPipelineDepthStencilStateCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPipelineDepthStencilStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPipelineDepthStencilStateCreateInfo *self;
                self = (PyVkPipelineDepthStencilStateCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPipelineDepthStencilStateCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineDepthStencilStateCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPipelineDepthStencilStateCreateInfo_getpNext(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineDepthStencilStateCreateInfo_getminDepthBounds(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->minDepthBounds);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineDepthStencilStateCreateInfo_getmaxDepthBounds(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->maxDepthBounds);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPipelineDepthStencilStateCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkPipelineDepthStencilStateCreateInfo_getpNext, NULL, "", NULL},
                
                    { "minDepthBounds", (getter)PyVkPipelineDepthStencilStateCreateInfo_getminDepthBounds, NULL, "", NULL},
                
                    { "maxDepthBounds", (getter)PyVkPipelineDepthStencilStateCreateInfo_getmaxDepthBounds, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPipelineDepthStencilStateCreateInfo_init(PyVkPipelineDepthStencilStateCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* depthTestEnable = NULL;
PyObject* depthWriteEnable = NULL;
PyObject* depthCompareOp = NULL;
PyObject* depthBoundsTestEnable = NULL;
PyObject* stencilTestEnable = NULL;
PyObject* front = NULL;
PyObject* back = NULL;
PyObject* minDepthBounds = NULL;
PyObject* maxDepthBounds = NULL;
static char *kwlist[] = {"sType","pNext","flags","depthTestEnable","depthWriteEnable","depthCompareOp","depthBoundsTestEnable","stencilTestEnable","front","back","minDepthBounds","maxDepthBounds",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOOOOO", kwlist, &sType, &pNext, &flags, &depthTestEnable, &depthWriteEnable, &depthCompareOp, &depthBoundsTestEnable, &stencilTestEnable, &front, &back, &minDepthBounds, &maxDepthBounds)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (depthTestEnable != NULL && depthTestEnable != Py_None) {
                
                    (self->base)->depthTestEnable = PyLong_AsLong(depthTestEnable);
                
 } 

                if (depthWriteEnable != NULL && depthWriteEnable != Py_None) {
                
                    (self->base)->depthWriteEnable = PyLong_AsLong(depthWriteEnable);
                
 } 

                if (depthCompareOp != NULL && depthCompareOp != Py_None) {
                
                    (self->base)->depthCompareOp = PyLong_AsLong(depthCompareOp);
                
 } 

                if (depthBoundsTestEnable != NULL && depthBoundsTestEnable != Py_None) {
                
                    (self->base)->depthBoundsTestEnable = PyLong_AsLong(depthBoundsTestEnable);
                
 } 

                if (stencilTestEnable != NULL && stencilTestEnable != Py_None) {
                
                    (self->base)->stencilTestEnable = PyLong_AsLong(stencilTestEnable);
                
 } 

                if (front != NULL && front != Py_None) {
                
                    (self->base)->front = *(((PyVkStencilOpState*)front)->base);
                
 } 

                if (back != NULL && back != Py_None) {
                
                    (self->base)->back = *(((PyVkStencilOpState*)back)->base);
                
 } 

                if (minDepthBounds != NULL && minDepthBounds != Py_None) {
                (self->base)->minDepthBounds = (float) PyFloat_AsDouble(minDepthBounds);
 } 

                if (maxDepthBounds != NULL && maxDepthBounds != Py_None) {
                (self->base)->maxDepthBounds = (float) PyFloat_AsDouble(maxDepthBounds);
 } 

return 0; }
            static PyTypeObject PyVkPipelineDepthStencilStateCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineDepthStencilStateCreateInfo", sizeof(PyVkPipelineDepthStencilStateCreateInfo), 0,
                (destructor)PyVkPipelineDepthStencilStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineDepthStencilStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineDepthStencilStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineDepthStencilStateCreateInfo_init,0,PyVkPipelineDepthStencilStateCreateInfo_new,};
        
            static void PyVkGraphicsPipelineCreateInfo_del(PyVkGraphicsPipelineCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkGraphicsPipelineCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkGraphicsPipelineCreateInfo *self;
                self = (PyVkGraphicsPipelineCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkGraphicsPipelineCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkGraphicsPipelineCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkGraphicsPipelineCreateInfo_getpNext(PyVkGraphicsPipelineCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkGraphicsPipelineCreateInfo_getstageCount(PyVkGraphicsPipelineCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->stageCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkGraphicsPipelineCreateInfo_getsubpass(PyVkGraphicsPipelineCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->subpass);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkGraphicsPipelineCreateInfo_getbasePipelineIndex(PyVkGraphicsPipelineCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->basePipelineIndex);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkGraphicsPipelineCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkGraphicsPipelineCreateInfo_getpNext, NULL, "", NULL},
                
                    { "stageCount", (getter)PyVkGraphicsPipelineCreateInfo_getstageCount, NULL, "", NULL},
                
                    { "subpass", (getter)PyVkGraphicsPipelineCreateInfo_getsubpass, NULL, "", NULL},
                
                    { "basePipelineIndex", (getter)PyVkGraphicsPipelineCreateInfo_getbasePipelineIndex, NULL, "", NULL},
                {NULL}};

            static int
            PyVkGraphicsPipelineCreateInfo_init(PyVkGraphicsPipelineCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* stageCount = NULL;
PyObject* pStages = NULL;
PyObject* pVertexInputState = NULL;
PyObject* pInputAssemblyState = NULL;
PyObject* pTessellationState = NULL;
PyObject* pViewportState = NULL;
PyObject* pRasterizationState = NULL;
PyObject* pMultisampleState = NULL;
PyObject* pDepthStencilState = NULL;
PyObject* pColorBlendState = NULL;
PyObject* pDynamicState = NULL;
PyObject* layout = NULL;
PyObject* renderPass = NULL;
PyObject* subpass = NULL;
PyObject* basePipelineHandle = NULL;
PyObject* basePipelineIndex = NULL;
static char *kwlist[] = {"sType","pNext","flags","stageCount","pStages","pVertexInputState","pInputAssemblyState","pTessellationState","pViewportState","pRasterizationState","pMultisampleState","pDepthStencilState","pColorBlendState","pDynamicState","layout","renderPass","subpass","basePipelineHandle","basePipelineIndex",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOOOOOOOOOOOO", kwlist, &sType, &pNext, &flags, &stageCount, &pStages, &pVertexInputState, &pInputAssemblyState, &pTessellationState, &pViewportState, &pRasterizationState, &pMultisampleState, &pDepthStencilState, &pColorBlendState, &pDynamicState, &layout, &renderPass, &subpass, &basePipelineHandle, &basePipelineIndex)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (stageCount != NULL && stageCount != Py_None) {
                (self->base)->stageCount = (uint32_t) PyLong_AsLong(stageCount);
 } 

                if (pStages != NULL && pStages != Py_None) {
                
                    (self->base)->pStages = (((PyVkPipelineShaderStageCreateInfo*)pStages)->base);
                
 } 

                if (pVertexInputState != NULL && pVertexInputState != Py_None) {
                
                    (self->base)->pVertexInputState = (((PyVkPipelineVertexInputStateCreateInfo*)pVertexInputState)->base);
                
 } 

                if (pInputAssemblyState != NULL && pInputAssemblyState != Py_None) {
                
                    (self->base)->pInputAssemblyState = (((PyVkPipelineInputAssemblyStateCreateInfo*)pInputAssemblyState)->base);
                
 } 

                if (pTessellationState != NULL && pTessellationState != Py_None) {
                
                    (self->base)->pTessellationState = (((PyVkPipelineTessellationStateCreateInfo*)pTessellationState)->base);
                
 } 

                if (pViewportState != NULL && pViewportState != Py_None) {
                
                    (self->base)->pViewportState = (((PyVkPipelineViewportStateCreateInfo*)pViewportState)->base);
                
 } 

                if (pRasterizationState != NULL && pRasterizationState != Py_None) {
                
                    (self->base)->pRasterizationState = (((PyVkPipelineRasterizationStateCreateInfo*)pRasterizationState)->base);
                
 } 

                if (pMultisampleState != NULL && pMultisampleState != Py_None) {
                
                    (self->base)->pMultisampleState = (((PyVkPipelineMultisampleStateCreateInfo*)pMultisampleState)->base);
                
 } 

                if (pDepthStencilState != NULL && pDepthStencilState != Py_None) {
                
                    (self->base)->pDepthStencilState = (((PyVkPipelineDepthStencilStateCreateInfo*)pDepthStencilState)->base);
                
 } 

                if (pColorBlendState != NULL && pColorBlendState != Py_None) {
                
                    (self->base)->pColorBlendState = (((PyVkPipelineColorBlendStateCreateInfo*)pColorBlendState)->base);
                
 } 

                if (pDynamicState != NULL && pDynamicState != Py_None) {
                
                    (self->base)->pDynamicState = (((PyVkPipelineDynamicStateCreateInfo*)pDynamicState)->base);
                
 } 

                if (layout != NULL && layout != Py_None) {
                
                (self->base)->layout = PyCapsule_GetPointer(layout, "VkPipelineLayout");
            
 } 

                if (renderPass != NULL && renderPass != Py_None) {
                
                (self->base)->renderPass = PyCapsule_GetPointer(renderPass, "VkRenderPass");
            
 } 

                if (subpass != NULL && subpass != Py_None) {
                (self->base)->subpass = (uint32_t) PyLong_AsLong(subpass);
 } 

                if (basePipelineHandle != NULL && basePipelineHandle != Py_None) {
                
                (self->base)->basePipelineHandle = PyCapsule_GetPointer(basePipelineHandle, "VkPipeline");
            
 } 

                if (basePipelineIndex != NULL && basePipelineIndex != Py_None) {
                (self->base)->basePipelineIndex = (int32_t) PyLong_AsLong(basePipelineIndex);
 } 

return 0; }
            static PyTypeObject PyVkGraphicsPipelineCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkGraphicsPipelineCreateInfo", sizeof(PyVkGraphicsPipelineCreateInfo), 0,
                (destructor)PyVkGraphicsPipelineCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkGraphicsPipelineCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkGraphicsPipelineCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkGraphicsPipelineCreateInfo_init,0,PyVkGraphicsPipelineCreateInfo_new,};
        
            static void PyVkPipelineCacheCreateInfo_del(PyVkPipelineCacheCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPipelineCacheCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPipelineCacheCreateInfo *self;
                self = (PyVkPipelineCacheCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPipelineCacheCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineCacheCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPipelineCacheCreateInfo_getpNext(PyVkPipelineCacheCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineCacheCreateInfo_getinitialDataSize(PyVkPipelineCacheCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->initialDataSize);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineCacheCreateInfo_getpInitialData(PyVkPipelineCacheCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPipelineCacheCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkPipelineCacheCreateInfo_getpNext, NULL, "", NULL},
                
                    { "initialDataSize", (getter)PyVkPipelineCacheCreateInfo_getinitialDataSize, NULL, "", NULL},
                
                    { "pInitialData", (getter)PyVkPipelineCacheCreateInfo_getpInitialData, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPipelineCacheCreateInfo_init(PyVkPipelineCacheCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* initialDataSize = NULL;
PyObject* pInitialData = NULL;
static char *kwlist[] = {"sType","pNext","flags","initialDataSize","pInitialData",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &flags, &initialDataSize, &pInitialData)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (initialDataSize != NULL && initialDataSize != Py_None) {
                (self->base)->initialDataSize = (size_t) PyLong_AsLong(initialDataSize);
 } 

                if (pInitialData != NULL && pInitialData != Py_None) {
                (self->base)->pInitialData = NULL;
 } 

return 0; }
            static PyTypeObject PyVkPipelineCacheCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineCacheCreateInfo", sizeof(PyVkPipelineCacheCreateInfo), 0,
                (destructor)PyVkPipelineCacheCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineCacheCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineCacheCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineCacheCreateInfo_init,0,PyVkPipelineCacheCreateInfo_new,};
        
            static void PyVkPushConstantRange_del(PyVkPushConstantRange* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPushConstantRange_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPushConstantRange *self;
                self = (PyVkPushConstantRange *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPushConstantRange));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPushConstantRange");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPushConstantRange_getoffset(PyVkPushConstantRange *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->offset);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPushConstantRange_getsize(PyVkPushConstantRange *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->size);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPushConstantRange_getsetters[] = {
                
                    { "offset", (getter)PyVkPushConstantRange_getoffset, NULL, "", NULL},
                
                    { "size", (getter)PyVkPushConstantRange_getsize, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPushConstantRange_init(PyVkPushConstantRange *self, PyObject *args, PyObject *kwds) {
            PyObject* stageFlags = NULL;
PyObject* offset = NULL;
PyObject* size = NULL;
static char *kwlist[] = {"stageFlags","offset","size",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &stageFlags, &offset, &size)) return -1;

                if (stageFlags != NULL && stageFlags != Py_None) {
                
                    (self->base)->stageFlags = PyLong_AsLong(stageFlags);
                
 } 

                if (offset != NULL && offset != Py_None) {
                (self->base)->offset = (uint32_t) PyLong_AsLong(offset);
 } 

                if (size != NULL && size != Py_None) {
                (self->base)->size = (uint32_t) PyLong_AsLong(size);
 } 

return 0; }
            static PyTypeObject PyVkPushConstantRangeType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPushConstantRange", sizeof(PyVkPushConstantRange), 0,
                (destructor)PyVkPushConstantRange_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPushConstantRange object",0,0,0,0,0,0,0,0,
                PyVkPushConstantRange_getsetters,0,0,0,0,0,(initproc)PyVkPushConstantRange_init,0,PyVkPushConstantRange_new,};
        
            static void PyVkPipelineLayoutCreateInfo_del(PyVkPipelineLayoutCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPipelineLayoutCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPipelineLayoutCreateInfo *self;
                self = (PyVkPipelineLayoutCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPipelineLayoutCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineLayoutCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPipelineLayoutCreateInfo_getpNext(PyVkPipelineLayoutCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineLayoutCreateInfo_getsetLayoutCount(PyVkPipelineLayoutCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->setLayoutCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPipelineLayoutCreateInfo_getpushConstantRangeCount(PyVkPipelineLayoutCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->pushConstantRangeCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPipelineLayoutCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkPipelineLayoutCreateInfo_getpNext, NULL, "", NULL},
                
                    { "setLayoutCount", (getter)PyVkPipelineLayoutCreateInfo_getsetLayoutCount, NULL, "", NULL},
                
                    { "pushConstantRangeCount", (getter)PyVkPipelineLayoutCreateInfo_getpushConstantRangeCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPipelineLayoutCreateInfo_init(PyVkPipelineLayoutCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* setLayoutCount = NULL;
PyObject* pSetLayouts = NULL;
PyObject* pushConstantRangeCount = NULL;
PyObject* pPushConstantRanges = NULL;
static char *kwlist[] = {"sType","pNext","flags","setLayoutCount","pSetLayouts","pushConstantRangeCount","pPushConstantRanges",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOO", kwlist, &sType, &pNext, &flags, &setLayoutCount, &pSetLayouts, &pushConstantRangeCount, &pPushConstantRanges)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (setLayoutCount != NULL && setLayoutCount != Py_None) {
                (self->base)->setLayoutCount = (uint32_t) PyLong_AsLong(setLayoutCount);
 } 

                if (pSetLayouts != NULL && pSetLayouts != Py_None) {
                
                (self->base)->pSetLayouts = PyCapsule_GetPointer(pSetLayouts, "VkDescriptorSetLayout");
            
 } 

                if (pushConstantRangeCount != NULL && pushConstantRangeCount != Py_None) {
                (self->base)->pushConstantRangeCount = (uint32_t) PyLong_AsLong(pushConstantRangeCount);
 } 

                if (pPushConstantRanges != NULL && pPushConstantRanges != Py_None) {
                
                    (self->base)->pPushConstantRanges = (((PyVkPushConstantRange*)pPushConstantRanges)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkPipelineLayoutCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineLayoutCreateInfo", sizeof(PyVkPipelineLayoutCreateInfo), 0,
                (destructor)PyVkPipelineLayoutCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineLayoutCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineLayoutCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineLayoutCreateInfo_init,0,PyVkPipelineLayoutCreateInfo_new,};
        
            static void PyVkSamplerCreateInfo_del(PyVkSamplerCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSamplerCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSamplerCreateInfo *self;
                self = (PyVkSamplerCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSamplerCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSamplerCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkSamplerCreateInfo_getpNext(PyVkSamplerCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSamplerCreateInfo_getmipLodBias(PyVkSamplerCreateInfo *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->mipLodBias);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSamplerCreateInfo_getmaxAnisotropy(PyVkSamplerCreateInfo *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->maxAnisotropy);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSamplerCreateInfo_getminLod(PyVkSamplerCreateInfo *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->minLod);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSamplerCreateInfo_getmaxLod(PyVkSamplerCreateInfo *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->maxLod);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkSamplerCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkSamplerCreateInfo_getpNext, NULL, "", NULL},
                
                    { "mipLodBias", (getter)PyVkSamplerCreateInfo_getmipLodBias, NULL, "", NULL},
                
                    { "maxAnisotropy", (getter)PyVkSamplerCreateInfo_getmaxAnisotropy, NULL, "", NULL},
                
                    { "minLod", (getter)PyVkSamplerCreateInfo_getminLod, NULL, "", NULL},
                
                    { "maxLod", (getter)PyVkSamplerCreateInfo_getmaxLod, NULL, "", NULL},
                {NULL}};

            static int
            PyVkSamplerCreateInfo_init(PyVkSamplerCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* magFilter = NULL;
PyObject* minFilter = NULL;
PyObject* mipmapMode = NULL;
PyObject* addressModeU = NULL;
PyObject* addressModeV = NULL;
PyObject* addressModeW = NULL;
PyObject* mipLodBias = NULL;
PyObject* anisotropyEnable = NULL;
PyObject* maxAnisotropy = NULL;
PyObject* compareEnable = NULL;
PyObject* compareOp = NULL;
PyObject* minLod = NULL;
PyObject* maxLod = NULL;
PyObject* borderColor = NULL;
PyObject* unnormalizedCoordinates = NULL;
static char *kwlist[] = {"sType","pNext","flags","magFilter","minFilter","mipmapMode","addressModeU","addressModeV","addressModeW","mipLodBias","anisotropyEnable","maxAnisotropy","compareEnable","compareOp","minLod","maxLod","borderColor","unnormalizedCoordinates",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOOOOOOOOOOO", kwlist, &sType, &pNext, &flags, &magFilter, &minFilter, &mipmapMode, &addressModeU, &addressModeV, &addressModeW, &mipLodBias, &anisotropyEnable, &maxAnisotropy, &compareEnable, &compareOp, &minLod, &maxLod, &borderColor, &unnormalizedCoordinates)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (magFilter != NULL && magFilter != Py_None) {
                
                    (self->base)->magFilter = PyLong_AsLong(magFilter);
                
 } 

                if (minFilter != NULL && minFilter != Py_None) {
                
                    (self->base)->minFilter = PyLong_AsLong(minFilter);
                
 } 

                if (mipmapMode != NULL && mipmapMode != Py_None) {
                
                    (self->base)->mipmapMode = PyLong_AsLong(mipmapMode);
                
 } 

                if (addressModeU != NULL && addressModeU != Py_None) {
                
                    (self->base)->addressModeU = PyLong_AsLong(addressModeU);
                
 } 

                if (addressModeV != NULL && addressModeV != Py_None) {
                
                    (self->base)->addressModeV = PyLong_AsLong(addressModeV);
                
 } 

                if (addressModeW != NULL && addressModeW != Py_None) {
                
                    (self->base)->addressModeW = PyLong_AsLong(addressModeW);
                
 } 

                if (mipLodBias != NULL && mipLodBias != Py_None) {
                (self->base)->mipLodBias = (float) PyFloat_AsDouble(mipLodBias);
 } 

                if (anisotropyEnable != NULL && anisotropyEnable != Py_None) {
                
                    (self->base)->anisotropyEnable = PyLong_AsLong(anisotropyEnable);
                
 } 

                if (maxAnisotropy != NULL && maxAnisotropy != Py_None) {
                (self->base)->maxAnisotropy = (float) PyFloat_AsDouble(maxAnisotropy);
 } 

                if (compareEnable != NULL && compareEnable != Py_None) {
                
                    (self->base)->compareEnable = PyLong_AsLong(compareEnable);
                
 } 

                if (compareOp != NULL && compareOp != Py_None) {
                
                    (self->base)->compareOp = PyLong_AsLong(compareOp);
                
 } 

                if (minLod != NULL && minLod != Py_None) {
                (self->base)->minLod = (float) PyFloat_AsDouble(minLod);
 } 

                if (maxLod != NULL && maxLod != Py_None) {
                (self->base)->maxLod = (float) PyFloat_AsDouble(maxLod);
 } 

                if (borderColor != NULL && borderColor != Py_None) {
                
                    (self->base)->borderColor = PyLong_AsLong(borderColor);
                
 } 

                if (unnormalizedCoordinates != NULL && unnormalizedCoordinates != Py_None) {
                
                    (self->base)->unnormalizedCoordinates = PyLong_AsLong(unnormalizedCoordinates);
                
 } 

return 0; }
            static PyTypeObject PyVkSamplerCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSamplerCreateInfo", sizeof(PyVkSamplerCreateInfo), 0,
                (destructor)PyVkSamplerCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSamplerCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkSamplerCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkSamplerCreateInfo_init,0,PyVkSamplerCreateInfo_new,};
        
            static void PyVkCommandPoolCreateInfo_del(PyVkCommandPoolCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkCommandPoolCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkCommandPoolCreateInfo *self;
                self = (PyVkCommandPoolCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkCommandPoolCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkCommandPoolCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkCommandPoolCreateInfo_getpNext(PyVkCommandPoolCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkCommandPoolCreateInfo_getqueueFamilyIndex(PyVkCommandPoolCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->queueFamilyIndex);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkCommandPoolCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkCommandPoolCreateInfo_getpNext, NULL, "", NULL},
                
                    { "queueFamilyIndex", (getter)PyVkCommandPoolCreateInfo_getqueueFamilyIndex, NULL, "", NULL},
                {NULL}};

            static int
            PyVkCommandPoolCreateInfo_init(PyVkCommandPoolCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* queueFamilyIndex = NULL;
static char *kwlist[] = {"sType","pNext","flags","queueFamilyIndex",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &sType, &pNext, &flags, &queueFamilyIndex)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (queueFamilyIndex != NULL && queueFamilyIndex != Py_None) {
                (self->base)->queueFamilyIndex = (uint32_t) PyLong_AsLong(queueFamilyIndex);
 } 

return 0; }
            static PyTypeObject PyVkCommandPoolCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkCommandPoolCreateInfo", sizeof(PyVkCommandPoolCreateInfo), 0,
                (destructor)PyVkCommandPoolCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkCommandPoolCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkCommandPoolCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkCommandPoolCreateInfo_init,0,PyVkCommandPoolCreateInfo_new,};
        
            static void PyVkCommandBufferAllocateInfo_del(PyVkCommandBufferAllocateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkCommandBufferAllocateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkCommandBufferAllocateInfo *self;
                self = (PyVkCommandBufferAllocateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkCommandBufferAllocateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkCommandBufferAllocateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkCommandBufferAllocateInfo_getpNext(PyVkCommandBufferAllocateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkCommandBufferAllocateInfo_getcommandBufferCount(PyVkCommandBufferAllocateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->commandBufferCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkCommandBufferAllocateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkCommandBufferAllocateInfo_getpNext, NULL, "", NULL},
                
                    { "commandBufferCount", (getter)PyVkCommandBufferAllocateInfo_getcommandBufferCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkCommandBufferAllocateInfo_init(PyVkCommandBufferAllocateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* commandPool = NULL;
PyObject* level = NULL;
PyObject* commandBufferCount = NULL;
static char *kwlist[] = {"sType","pNext","commandPool","level","commandBufferCount",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &commandPool, &level, &commandBufferCount)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (commandPool != NULL && commandPool != Py_None) {
                
                (self->base)->commandPool = PyCapsule_GetPointer(commandPool, "VkCommandPool");
            
 } 

                if (level != NULL && level != Py_None) {
                
                    (self->base)->level = PyLong_AsLong(level);
                
 } 

                if (commandBufferCount != NULL && commandBufferCount != Py_None) {
                (self->base)->commandBufferCount = (uint32_t) PyLong_AsLong(commandBufferCount);
 } 

return 0; }
            static PyTypeObject PyVkCommandBufferAllocateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkCommandBufferAllocateInfo", sizeof(PyVkCommandBufferAllocateInfo), 0,
                (destructor)PyVkCommandBufferAllocateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkCommandBufferAllocateInfo object",0,0,0,0,0,0,0,0,
                PyVkCommandBufferAllocateInfo_getsetters,0,0,0,0,0,(initproc)PyVkCommandBufferAllocateInfo_init,0,PyVkCommandBufferAllocateInfo_new,};
        
            static void PyVkCommandBufferInheritanceInfo_del(PyVkCommandBufferInheritanceInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkCommandBufferInheritanceInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkCommandBufferInheritanceInfo *self;
                self = (PyVkCommandBufferInheritanceInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkCommandBufferInheritanceInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkCommandBufferInheritanceInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkCommandBufferInheritanceInfo_getpNext(PyVkCommandBufferInheritanceInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkCommandBufferInheritanceInfo_getsubpass(PyVkCommandBufferInheritanceInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->subpass);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkCommandBufferInheritanceInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkCommandBufferInheritanceInfo_getpNext, NULL, "", NULL},
                
                    { "subpass", (getter)PyVkCommandBufferInheritanceInfo_getsubpass, NULL, "", NULL},
                {NULL}};

            static int
            PyVkCommandBufferInheritanceInfo_init(PyVkCommandBufferInheritanceInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* renderPass = NULL;
PyObject* subpass = NULL;
PyObject* framebuffer = NULL;
PyObject* occlusionQueryEnable = NULL;
PyObject* queryFlags = NULL;
PyObject* pipelineStatistics = NULL;
static char *kwlist[] = {"sType","pNext","renderPass","subpass","framebuffer","occlusionQueryEnable","queryFlags","pipelineStatistics",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOO", kwlist, &sType, &pNext, &renderPass, &subpass, &framebuffer, &occlusionQueryEnable, &queryFlags, &pipelineStatistics)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (renderPass != NULL && renderPass != Py_None) {
                
                (self->base)->renderPass = PyCapsule_GetPointer(renderPass, "VkRenderPass");
            
 } 

                if (subpass != NULL && subpass != Py_None) {
                (self->base)->subpass = (uint32_t) PyLong_AsLong(subpass);
 } 

                if (framebuffer != NULL && framebuffer != Py_None) {
                
                (self->base)->framebuffer = PyCapsule_GetPointer(framebuffer, "VkFramebuffer");
            
 } 

                if (occlusionQueryEnable != NULL && occlusionQueryEnable != Py_None) {
                
                    (self->base)->occlusionQueryEnable = PyLong_AsLong(occlusionQueryEnable);
                
 } 

                if (queryFlags != NULL && queryFlags != Py_None) {
                
                    (self->base)->queryFlags = PyLong_AsLong(queryFlags);
                
 } 

                if (pipelineStatistics != NULL && pipelineStatistics != Py_None) {
                
                    (self->base)->pipelineStatistics = PyLong_AsLong(pipelineStatistics);
                
 } 

return 0; }
            static PyTypeObject PyVkCommandBufferInheritanceInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkCommandBufferInheritanceInfo", sizeof(PyVkCommandBufferInheritanceInfo), 0,
                (destructor)PyVkCommandBufferInheritanceInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkCommandBufferInheritanceInfo object",0,0,0,0,0,0,0,0,
                PyVkCommandBufferInheritanceInfo_getsetters,0,0,0,0,0,(initproc)PyVkCommandBufferInheritanceInfo_init,0,PyVkCommandBufferInheritanceInfo_new,};
        
            static void PyVkCommandBufferBeginInfo_del(PyVkCommandBufferBeginInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkCommandBufferBeginInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkCommandBufferBeginInfo *self;
                self = (PyVkCommandBufferBeginInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkCommandBufferBeginInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkCommandBufferBeginInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkCommandBufferBeginInfo_getpNext(PyVkCommandBufferBeginInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkCommandBufferBeginInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkCommandBufferBeginInfo_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkCommandBufferBeginInfo_init(PyVkCommandBufferBeginInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* pInheritanceInfo = NULL;
static char *kwlist[] = {"sType","pNext","flags","pInheritanceInfo",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &sType, &pNext, &flags, &pInheritanceInfo)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (pInheritanceInfo != NULL && pInheritanceInfo != Py_None) {
                
                    (self->base)->pInheritanceInfo = (((PyVkCommandBufferInheritanceInfo*)pInheritanceInfo)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkCommandBufferBeginInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkCommandBufferBeginInfo", sizeof(PyVkCommandBufferBeginInfo), 0,
                (destructor)PyVkCommandBufferBeginInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkCommandBufferBeginInfo object",0,0,0,0,0,0,0,0,
                PyVkCommandBufferBeginInfo_getsetters,0,0,0,0,0,(initproc)PyVkCommandBufferBeginInfo_init,0,PyVkCommandBufferBeginInfo_new,};
        
            static void PyVkRenderPassBeginInfo_del(PyVkRenderPassBeginInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkRenderPassBeginInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkRenderPassBeginInfo *self;
                self = (PyVkRenderPassBeginInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkRenderPassBeginInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkRenderPassBeginInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkRenderPassBeginInfo_getpNext(PyVkRenderPassBeginInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkRenderPassBeginInfo_getclearValueCount(PyVkRenderPassBeginInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->clearValueCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkRenderPassBeginInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkRenderPassBeginInfo_getpNext, NULL, "", NULL},
                
                    { "clearValueCount", (getter)PyVkRenderPassBeginInfo_getclearValueCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkRenderPassBeginInfo_init(PyVkRenderPassBeginInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* renderPass = NULL;
PyObject* framebuffer = NULL;
PyObject* renderArea = NULL;
PyObject* clearValueCount = NULL;
PyObject* pClearValues = NULL;
static char *kwlist[] = {"sType","pNext","renderPass","framebuffer","renderArea","clearValueCount","pClearValues",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOO", kwlist, &sType, &pNext, &renderPass, &framebuffer, &renderArea, &clearValueCount, &pClearValues)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (renderPass != NULL && renderPass != Py_None) {
                
                (self->base)->renderPass = PyCapsule_GetPointer(renderPass, "VkRenderPass");
            
 } 

                if (framebuffer != NULL && framebuffer != Py_None) {
                
                (self->base)->framebuffer = PyCapsule_GetPointer(framebuffer, "VkFramebuffer");
            
 } 

                if (renderArea != NULL && renderArea != Py_None) {
                
                    (self->base)->renderArea = *(((PyVkRect2D*)renderArea)->base);
                
 } 

                if (clearValueCount != NULL && clearValueCount != Py_None) {
                (self->base)->clearValueCount = (uint32_t) PyLong_AsLong(clearValueCount);
 } 

                if (pClearValues != NULL && pClearValues != Py_None) {
                
                    (self->base)->pClearValues = (((PyVkClearValue*)pClearValues)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkRenderPassBeginInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkRenderPassBeginInfo", sizeof(PyVkRenderPassBeginInfo), 0,
                (destructor)PyVkRenderPassBeginInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkRenderPassBeginInfo object",0,0,0,0,0,0,0,0,
                PyVkRenderPassBeginInfo_getsetters,0,0,0,0,0,(initproc)PyVkRenderPassBeginInfo_init,0,PyVkRenderPassBeginInfo_new,};
        
            static void PyVkClearDepthStencilValue_del(PyVkClearDepthStencilValue* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkClearDepthStencilValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkClearDepthStencilValue *self;
                self = (PyVkClearDepthStencilValue *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkClearDepthStencilValue));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkClearDepthStencilValue");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkClearDepthStencilValue_getdepth(PyVkClearDepthStencilValue *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->depth);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkClearDepthStencilValue_getstencil(PyVkClearDepthStencilValue *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->stencil);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkClearDepthStencilValue_getsetters[] = {
                
                    { "depth", (getter)PyVkClearDepthStencilValue_getdepth, NULL, "", NULL},
                
                    { "stencil", (getter)PyVkClearDepthStencilValue_getstencil, NULL, "", NULL},
                {NULL}};

            static int
            PyVkClearDepthStencilValue_init(PyVkClearDepthStencilValue *self, PyObject *args, PyObject *kwds) {
            PyObject* depth = NULL;
PyObject* stencil = NULL;
static char *kwlist[] = {"depth","stencil",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OO", kwlist, &depth, &stencil)) return -1;

                if (depth != NULL && depth != Py_None) {
                (self->base)->depth = (float) PyFloat_AsDouble(depth);
 } 

                if (stencil != NULL && stencil != Py_None) {
                (self->base)->stencil = (uint32_t) PyLong_AsLong(stencil);
 } 

return 0; }
            static PyTypeObject PyVkClearDepthStencilValueType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkClearDepthStencilValue", sizeof(PyVkClearDepthStencilValue), 0,
                (destructor)PyVkClearDepthStencilValue_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkClearDepthStencilValue object",0,0,0,0,0,0,0,0,
                PyVkClearDepthStencilValue_getsetters,0,0,0,0,0,(initproc)PyVkClearDepthStencilValue_init,0,PyVkClearDepthStencilValue_new,};
        
            static void PyVkClearAttachment_del(PyVkClearAttachment* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkClearAttachment_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkClearAttachment *self;
                self = (PyVkClearAttachment *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkClearAttachment));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkClearAttachment");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkClearAttachment_getcolorAttachment(PyVkClearAttachment *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->colorAttachment);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkClearAttachment_getsetters[] = {
                
                    { "colorAttachment", (getter)PyVkClearAttachment_getcolorAttachment, NULL, "", NULL},
                {NULL}};

            static int
            PyVkClearAttachment_init(PyVkClearAttachment *self, PyObject *args, PyObject *kwds) {
            PyObject* aspectMask = NULL;
PyObject* colorAttachment = NULL;
PyObject* clearValue = NULL;
static char *kwlist[] = {"aspectMask","colorAttachment","clearValue",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &aspectMask, &colorAttachment, &clearValue)) return -1;

                if (aspectMask != NULL && aspectMask != Py_None) {
                
                    (self->base)->aspectMask = PyLong_AsLong(aspectMask);
                
 } 

                if (colorAttachment != NULL && colorAttachment != Py_None) {
                (self->base)->colorAttachment = (uint32_t) PyLong_AsLong(colorAttachment);
 } 

                if (clearValue != NULL && clearValue != Py_None) {
                
                    (self->base)->clearValue = *(((PyVkClearValue*)clearValue)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkClearAttachmentType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkClearAttachment", sizeof(PyVkClearAttachment), 0,
                (destructor)PyVkClearAttachment_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkClearAttachment object",0,0,0,0,0,0,0,0,
                PyVkClearAttachment_getsetters,0,0,0,0,0,(initproc)PyVkClearAttachment_init,0,PyVkClearAttachment_new,};
        
            static void PyVkAttachmentDescription_del(PyVkAttachmentDescription* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkAttachmentDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkAttachmentDescription *self;
                self = (PyVkAttachmentDescription *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkAttachmentDescription));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkAttachmentDescription");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkAttachmentDescription_getsetters[] = {
                {NULL}};

            static int
            PyVkAttachmentDescription_init(PyVkAttachmentDescription *self, PyObject *args, PyObject *kwds) {
            PyObject* flags = NULL;
PyObject* format = NULL;
PyObject* samples = NULL;
PyObject* loadOp = NULL;
PyObject* storeOp = NULL;
PyObject* stencilLoadOp = NULL;
PyObject* stencilStoreOp = NULL;
PyObject* initialLayout = NULL;
PyObject* finalLayout = NULL;
static char *kwlist[] = {"flags","format","samples","loadOp","storeOp","stencilLoadOp","stencilStoreOp","initialLayout","finalLayout",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOO", kwlist, &flags, &format, &samples, &loadOp, &storeOp, &stencilLoadOp, &stencilStoreOp, &initialLayout, &finalLayout)) return -1;

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (format != NULL && format != Py_None) {
                
                    (self->base)->format = PyLong_AsLong(format);
                
 } 

                if (samples != NULL && samples != Py_None) {
                
                    (self->base)->samples = PyLong_AsLong(samples);
                
 } 

                if (loadOp != NULL && loadOp != Py_None) {
                
                    (self->base)->loadOp = PyLong_AsLong(loadOp);
                
 } 

                if (storeOp != NULL && storeOp != Py_None) {
                
                    (self->base)->storeOp = PyLong_AsLong(storeOp);
                
 } 

                if (stencilLoadOp != NULL && stencilLoadOp != Py_None) {
                
                    (self->base)->stencilLoadOp = PyLong_AsLong(stencilLoadOp);
                
 } 

                if (stencilStoreOp != NULL && stencilStoreOp != Py_None) {
                
                    (self->base)->stencilStoreOp = PyLong_AsLong(stencilStoreOp);
                
 } 

                if (initialLayout != NULL && initialLayout != Py_None) {
                
                    (self->base)->initialLayout = PyLong_AsLong(initialLayout);
                
 } 

                if (finalLayout != NULL && finalLayout != Py_None) {
                
                    (self->base)->finalLayout = PyLong_AsLong(finalLayout);
                
 } 

return 0; }
            static PyTypeObject PyVkAttachmentDescriptionType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkAttachmentDescription", sizeof(PyVkAttachmentDescription), 0,
                (destructor)PyVkAttachmentDescription_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkAttachmentDescription object",0,0,0,0,0,0,0,0,
                PyVkAttachmentDescription_getsetters,0,0,0,0,0,(initproc)PyVkAttachmentDescription_init,0,PyVkAttachmentDescription_new,};
        
            static void PyVkAttachmentReference_del(PyVkAttachmentReference* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkAttachmentReference_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkAttachmentReference *self;
                self = (PyVkAttachmentReference *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkAttachmentReference));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkAttachmentReference");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkAttachmentReference_getattachment(PyVkAttachmentReference *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->attachment);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkAttachmentReference_getsetters[] = {
                
                    { "attachment", (getter)PyVkAttachmentReference_getattachment, NULL, "", NULL},
                {NULL}};

            static int
            PyVkAttachmentReference_init(PyVkAttachmentReference *self, PyObject *args, PyObject *kwds) {
            PyObject* attachment = NULL;
PyObject* layout = NULL;
static char *kwlist[] = {"attachment","layout",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OO", kwlist, &attachment, &layout)) return -1;

                if (attachment != NULL && attachment != Py_None) {
                (self->base)->attachment = (uint32_t) PyLong_AsLong(attachment);
 } 

                if (layout != NULL && layout != Py_None) {
                
                    (self->base)->layout = PyLong_AsLong(layout);
                
 } 

return 0; }
            static PyTypeObject PyVkAttachmentReferenceType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkAttachmentReference", sizeof(PyVkAttachmentReference), 0,
                (destructor)PyVkAttachmentReference_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkAttachmentReference object",0,0,0,0,0,0,0,0,
                PyVkAttachmentReference_getsetters,0,0,0,0,0,(initproc)PyVkAttachmentReference_init,0,PyVkAttachmentReference_new,};
        
            static void PyVkSubpassDescription_del(PyVkSubpassDescription* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSubpassDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSubpassDescription *self;
                self = (PyVkSubpassDescription *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSubpassDescription));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSubpassDescription");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkSubpassDescription_getinputAttachmentCount(PyVkSubpassDescription *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->inputAttachmentCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSubpassDescription_getcolorAttachmentCount(PyVkSubpassDescription *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->colorAttachmentCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSubpassDescription_getpreserveAttachmentCount(PyVkSubpassDescription *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->preserveAttachmentCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSubpassDescription_getpPreserveAttachments(PyVkSubpassDescription *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (*((self->base)->pPreserveAttachments)));
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkSubpassDescription_getsetters[] = {
                
                    { "inputAttachmentCount", (getter)PyVkSubpassDescription_getinputAttachmentCount, NULL, "", NULL},
                
                    { "colorAttachmentCount", (getter)PyVkSubpassDescription_getcolorAttachmentCount, NULL, "", NULL},
                
                    { "preserveAttachmentCount", (getter)PyVkSubpassDescription_getpreserveAttachmentCount, NULL, "", NULL},
                
                    { "pPreserveAttachments", (getter)PyVkSubpassDescription_getpPreserveAttachments, NULL, "", NULL},
                {NULL}};

            static int
            PyVkSubpassDescription_init(PyVkSubpassDescription *self, PyObject *args, PyObject *kwds) {
            PyObject* flags = NULL;
PyObject* pipelineBindPoint = NULL;
PyObject* inputAttachmentCount = NULL;
PyObject* pInputAttachments = NULL;
PyObject* colorAttachmentCount = NULL;
PyObject* pColorAttachments = NULL;
PyObject* pResolveAttachments = NULL;
PyObject* pDepthStencilAttachment = NULL;
PyObject* preserveAttachmentCount = NULL;
PyObject* pPreserveAttachments = NULL;
static char *kwlist[] = {"flags","pipelineBindPoint","inputAttachmentCount","pInputAttachments","colorAttachmentCount","pColorAttachments","pResolveAttachments","pDepthStencilAttachment","preserveAttachmentCount","pPreserveAttachments",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOOO", kwlist, &flags, &pipelineBindPoint, &inputAttachmentCount, &pInputAttachments, &colorAttachmentCount, &pColorAttachments, &pResolveAttachments, &pDepthStencilAttachment, &preserveAttachmentCount, &pPreserveAttachments)) return -1;

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (pipelineBindPoint != NULL && pipelineBindPoint != Py_None) {
                
                    (self->base)->pipelineBindPoint = PyLong_AsLong(pipelineBindPoint);
                
 } 

                if (inputAttachmentCount != NULL && inputAttachmentCount != Py_None) {
                (self->base)->inputAttachmentCount = (uint32_t) PyLong_AsLong(inputAttachmentCount);
 } 

                if (pInputAttachments != NULL && pInputAttachments != Py_None) {
                
                    (self->base)->pInputAttachments = (((PyVkAttachmentReference*)pInputAttachments)->base);
                
 } 

                if (colorAttachmentCount != NULL && colorAttachmentCount != Py_None) {
                (self->base)->colorAttachmentCount = (uint32_t) PyLong_AsLong(colorAttachmentCount);
 } 

                if (pColorAttachments != NULL && pColorAttachments != Py_None) {
                
                    (self->base)->pColorAttachments = (((PyVkAttachmentReference*)pColorAttachments)->base);
                
 } 

                if (pResolveAttachments != NULL && pResolveAttachments != Py_None) {
                
                    (self->base)->pResolveAttachments = (((PyVkAttachmentReference*)pResolveAttachments)->base);
                
 } 

                if (pDepthStencilAttachment != NULL && pDepthStencilAttachment != Py_None) {
                
                    (self->base)->pDepthStencilAttachment = (((PyVkAttachmentReference*)pDepthStencilAttachment)->base);
                
 } 

                if (preserveAttachmentCount != NULL && preserveAttachmentCount != Py_None) {
                (self->base)->preserveAttachmentCount = (uint32_t) PyLong_AsLong(preserveAttachmentCount);
 } 

                if (pPreserveAttachments != NULL && pPreserveAttachments != Py_None) {
                
        uint32_t tmp50362009 = (uint32_t) PyLong_AsLong(pPreserveAttachments);
        uint32_t *tmp23727626 = malloc(sizeof(uint32_t));
        memcpy(tmp23727626, &tmp50362009, sizeof(uint32_t));
        (self->base)->pPreserveAttachments = tmp23727626;
        
 } 

return 0; }
            static PyTypeObject PyVkSubpassDescriptionType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSubpassDescription", sizeof(PyVkSubpassDescription), 0,
                (destructor)PyVkSubpassDescription_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSubpassDescription object",0,0,0,0,0,0,0,0,
                PyVkSubpassDescription_getsetters,0,0,0,0,0,(initproc)PyVkSubpassDescription_init,0,PyVkSubpassDescription_new,};
        
            static void PyVkSubpassDependency_del(PyVkSubpassDependency* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSubpassDependency_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSubpassDependency *self;
                self = (PyVkSubpassDependency *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSubpassDependency));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSubpassDependency");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkSubpassDependency_getsrcSubpass(PyVkSubpassDependency *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->srcSubpass);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSubpassDependency_getdstSubpass(PyVkSubpassDependency *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->dstSubpass);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkSubpassDependency_getsetters[] = {
                
                    { "srcSubpass", (getter)PyVkSubpassDependency_getsrcSubpass, NULL, "", NULL},
                
                    { "dstSubpass", (getter)PyVkSubpassDependency_getdstSubpass, NULL, "", NULL},
                {NULL}};

            static int
            PyVkSubpassDependency_init(PyVkSubpassDependency *self, PyObject *args, PyObject *kwds) {
            PyObject* srcSubpass = NULL;
PyObject* dstSubpass = NULL;
PyObject* srcStageMask = NULL;
PyObject* dstStageMask = NULL;
PyObject* srcAccessMask = NULL;
PyObject* dstAccessMask = NULL;
PyObject* dependencyFlags = NULL;
static char *kwlist[] = {"srcSubpass","dstSubpass","srcStageMask","dstStageMask","srcAccessMask","dstAccessMask","dependencyFlags",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOO", kwlist, &srcSubpass, &dstSubpass, &srcStageMask, &dstStageMask, &srcAccessMask, &dstAccessMask, &dependencyFlags)) return -1;

                if (srcSubpass != NULL && srcSubpass != Py_None) {
                (self->base)->srcSubpass = (uint32_t) PyLong_AsLong(srcSubpass);
 } 

                if (dstSubpass != NULL && dstSubpass != Py_None) {
                (self->base)->dstSubpass = (uint32_t) PyLong_AsLong(dstSubpass);
 } 

                if (srcStageMask != NULL && srcStageMask != Py_None) {
                
                    (self->base)->srcStageMask = PyLong_AsLong(srcStageMask);
                
 } 

                if (dstStageMask != NULL && dstStageMask != Py_None) {
                
                    (self->base)->dstStageMask = PyLong_AsLong(dstStageMask);
                
 } 

                if (srcAccessMask != NULL && srcAccessMask != Py_None) {
                
                    (self->base)->srcAccessMask = PyLong_AsLong(srcAccessMask);
                
 } 

                if (dstAccessMask != NULL && dstAccessMask != Py_None) {
                
                    (self->base)->dstAccessMask = PyLong_AsLong(dstAccessMask);
                
 } 

                if (dependencyFlags != NULL && dependencyFlags != Py_None) {
                
                    (self->base)->dependencyFlags = PyLong_AsLong(dependencyFlags);
                
 } 

return 0; }
            static PyTypeObject PyVkSubpassDependencyType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSubpassDependency", sizeof(PyVkSubpassDependency), 0,
                (destructor)PyVkSubpassDependency_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSubpassDependency object",0,0,0,0,0,0,0,0,
                PyVkSubpassDependency_getsetters,0,0,0,0,0,(initproc)PyVkSubpassDependency_init,0,PyVkSubpassDependency_new,};
        
            static void PyVkRenderPassCreateInfo_del(PyVkRenderPassCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkRenderPassCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkRenderPassCreateInfo *self;
                self = (PyVkRenderPassCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkRenderPassCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkRenderPassCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkRenderPassCreateInfo_getpNext(PyVkRenderPassCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkRenderPassCreateInfo_getattachmentCount(PyVkRenderPassCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->attachmentCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkRenderPassCreateInfo_getsubpassCount(PyVkRenderPassCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->subpassCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkRenderPassCreateInfo_getdependencyCount(PyVkRenderPassCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->dependencyCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkRenderPassCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkRenderPassCreateInfo_getpNext, NULL, "", NULL},
                
                    { "attachmentCount", (getter)PyVkRenderPassCreateInfo_getattachmentCount, NULL, "", NULL},
                
                    { "subpassCount", (getter)PyVkRenderPassCreateInfo_getsubpassCount, NULL, "", NULL},
                
                    { "dependencyCount", (getter)PyVkRenderPassCreateInfo_getdependencyCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkRenderPassCreateInfo_init(PyVkRenderPassCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* attachmentCount = NULL;
PyObject* pAttachments = NULL;
PyObject* subpassCount = NULL;
PyObject* pSubpasses = NULL;
PyObject* dependencyCount = NULL;
PyObject* pDependencies = NULL;
static char *kwlist[] = {"sType","pNext","flags","attachmentCount","pAttachments","subpassCount","pSubpasses","dependencyCount","pDependencies",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOO", kwlist, &sType, &pNext, &flags, &attachmentCount, &pAttachments, &subpassCount, &pSubpasses, &dependencyCount, &pDependencies)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (attachmentCount != NULL && attachmentCount != Py_None) {
                (self->base)->attachmentCount = (uint32_t) PyLong_AsLong(attachmentCount);
 } 

                if (pAttachments != NULL && pAttachments != Py_None) {
                
                    (self->base)->pAttachments = (((PyVkAttachmentDescription*)pAttachments)->base);
                
 } 

                if (subpassCount != NULL && subpassCount != Py_None) {
                (self->base)->subpassCount = (uint32_t) PyLong_AsLong(subpassCount);
 } 

                if (pSubpasses != NULL && pSubpasses != Py_None) {
                
                    (self->base)->pSubpasses = (((PyVkSubpassDescription*)pSubpasses)->base);
                
 } 

                if (dependencyCount != NULL && dependencyCount != Py_None) {
                (self->base)->dependencyCount = (uint32_t) PyLong_AsLong(dependencyCount);
 } 

                if (pDependencies != NULL && pDependencies != Py_None) {
                
                    (self->base)->pDependencies = (((PyVkSubpassDependency*)pDependencies)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkRenderPassCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkRenderPassCreateInfo", sizeof(PyVkRenderPassCreateInfo), 0,
                (destructor)PyVkRenderPassCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkRenderPassCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkRenderPassCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkRenderPassCreateInfo_init,0,PyVkRenderPassCreateInfo_new,};
        
            static void PyVkEventCreateInfo_del(PyVkEventCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkEventCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkEventCreateInfo *self;
                self = (PyVkEventCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkEventCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkEventCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkEventCreateInfo_getpNext(PyVkEventCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkEventCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkEventCreateInfo_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkEventCreateInfo_init(PyVkEventCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
static char *kwlist[] = {"sType","pNext","flags",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &sType, &pNext, &flags)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

return 0; }
            static PyTypeObject PyVkEventCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkEventCreateInfo", sizeof(PyVkEventCreateInfo), 0,
                (destructor)PyVkEventCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkEventCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkEventCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkEventCreateInfo_init,0,PyVkEventCreateInfo_new,};
        
            static void PyVkFenceCreateInfo_del(PyVkFenceCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkFenceCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkFenceCreateInfo *self;
                self = (PyVkFenceCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkFenceCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkFenceCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkFenceCreateInfo_getpNext(PyVkFenceCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkFenceCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkFenceCreateInfo_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkFenceCreateInfo_init(PyVkFenceCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
static char *kwlist[] = {"sType","pNext","flags",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &sType, &pNext, &flags)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

return 0; }
            static PyTypeObject PyVkFenceCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkFenceCreateInfo", sizeof(PyVkFenceCreateInfo), 0,
                (destructor)PyVkFenceCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkFenceCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkFenceCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkFenceCreateInfo_init,0,PyVkFenceCreateInfo_new,};
        
            static void PyVkPhysicalDeviceFeatures_del(PyVkPhysicalDeviceFeatures* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPhysicalDeviceFeatures_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPhysicalDeviceFeatures *self;
                self = (PyVkPhysicalDeviceFeatures *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPhysicalDeviceFeatures));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPhysicalDeviceFeatures");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkPhysicalDeviceFeatures_getsetters[] = {
                {NULL}};

            static int
            PyVkPhysicalDeviceFeatures_init(PyVkPhysicalDeviceFeatures *self, PyObject *args, PyObject *kwds) {
            PyObject* robustBufferAccess = NULL;
PyObject* fullDrawIndexUint32 = NULL;
PyObject* imageCubeArray = NULL;
PyObject* independentBlend = NULL;
PyObject* geometryShader = NULL;
PyObject* tessellationShader = NULL;
PyObject* sampleRateShading = NULL;
PyObject* dualSrcBlend = NULL;
PyObject* logicOp = NULL;
PyObject* multiDrawIndirect = NULL;
PyObject* drawIndirectFirstInstance = NULL;
PyObject* depthClamp = NULL;
PyObject* depthBiasClamp = NULL;
PyObject* fillModeNonSolid = NULL;
PyObject* depthBounds = NULL;
PyObject* wideLines = NULL;
PyObject* largePoints = NULL;
PyObject* alphaToOne = NULL;
PyObject* multiViewport = NULL;
PyObject* samplerAnisotropy = NULL;
PyObject* textureCompressionETC2 = NULL;
PyObject* textureCompressionASTC_LDR = NULL;
PyObject* textureCompressionBC = NULL;
PyObject* occlusionQueryPrecise = NULL;
PyObject* pipelineStatisticsQuery = NULL;
PyObject* vertexPipelineStoresAndAtomics = NULL;
PyObject* fragmentStoresAndAtomics = NULL;
PyObject* shaderTessellationAndGeometryPointSize = NULL;
PyObject* shaderImageGatherExtended = NULL;
PyObject* shaderStorageImageExtendedFormats = NULL;
PyObject* shaderStorageImageMultisample = NULL;
PyObject* shaderStorageImageReadWithoutFormat = NULL;
PyObject* shaderStorageImageWriteWithoutFormat = NULL;
PyObject* shaderUniformBufferArrayDynamicIndexing = NULL;
PyObject* shaderSampledImageArrayDynamicIndexing = NULL;
PyObject* shaderStorageBufferArrayDynamicIndexing = NULL;
PyObject* shaderStorageImageArrayDynamicIndexing = NULL;
PyObject* shaderClipDistance = NULL;
PyObject* shaderCullDistance = NULL;
PyObject* shaderFloat64 = NULL;
PyObject* shaderInt64 = NULL;
PyObject* shaderInt16 = NULL;
PyObject* shaderResourceResidency = NULL;
PyObject* shaderResourceMinLod = NULL;
PyObject* sparseBinding = NULL;
PyObject* sparseResidencyBuffer = NULL;
PyObject* sparseResidencyImage2D = NULL;
PyObject* sparseResidencyImage3D = NULL;
PyObject* sparseResidency2Samples = NULL;
PyObject* sparseResidency4Samples = NULL;
PyObject* sparseResidency8Samples = NULL;
PyObject* sparseResidency16Samples = NULL;
PyObject* sparseResidencyAliased = NULL;
PyObject* variableMultisampleRate = NULL;
PyObject* inheritedQueries = NULL;
static char *kwlist[] = {"robustBufferAccess","fullDrawIndexUint32","imageCubeArray","independentBlend","geometryShader","tessellationShader","sampleRateShading","dualSrcBlend","logicOp","multiDrawIndirect","drawIndirectFirstInstance","depthClamp","depthBiasClamp","fillModeNonSolid","depthBounds","wideLines","largePoints","alphaToOne","multiViewport","samplerAnisotropy","textureCompressionETC2","textureCompressionASTC_LDR","textureCompressionBC","occlusionQueryPrecise","pipelineStatisticsQuery","vertexPipelineStoresAndAtomics","fragmentStoresAndAtomics","shaderTessellationAndGeometryPointSize","shaderImageGatherExtended","shaderStorageImageExtendedFormats","shaderStorageImageMultisample","shaderStorageImageReadWithoutFormat","shaderStorageImageWriteWithoutFormat","shaderUniformBufferArrayDynamicIndexing","shaderSampledImageArrayDynamicIndexing","shaderStorageBufferArrayDynamicIndexing","shaderStorageImageArrayDynamicIndexing","shaderClipDistance","shaderCullDistance","shaderFloat64","shaderInt64","shaderInt16","shaderResourceResidency","shaderResourceMinLod","sparseBinding","sparseResidencyBuffer","sparseResidencyImage2D","sparseResidencyImage3D","sparseResidency2Samples","sparseResidency4Samples","sparseResidency8Samples","sparseResidency16Samples","sparseResidencyAliased","variableMultisampleRate","inheritedQueries",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO", kwlist, &robustBufferAccess, &fullDrawIndexUint32, &imageCubeArray, &independentBlend, &geometryShader, &tessellationShader, &sampleRateShading, &dualSrcBlend, &logicOp, &multiDrawIndirect, &drawIndirectFirstInstance, &depthClamp, &depthBiasClamp, &fillModeNonSolid, &depthBounds, &wideLines, &largePoints, &alphaToOne, &multiViewport, &samplerAnisotropy, &textureCompressionETC2, &textureCompressionASTC_LDR, &textureCompressionBC, &occlusionQueryPrecise, &pipelineStatisticsQuery, &vertexPipelineStoresAndAtomics, &fragmentStoresAndAtomics, &shaderTessellationAndGeometryPointSize, &shaderImageGatherExtended, &shaderStorageImageExtendedFormats, &shaderStorageImageMultisample, &shaderStorageImageReadWithoutFormat, &shaderStorageImageWriteWithoutFormat, &shaderUniformBufferArrayDynamicIndexing, &shaderSampledImageArrayDynamicIndexing, &shaderStorageBufferArrayDynamicIndexing, &shaderStorageImageArrayDynamicIndexing, &shaderClipDistance, &shaderCullDistance, &shaderFloat64, &shaderInt64, &shaderInt16, &shaderResourceResidency, &shaderResourceMinLod, &sparseBinding, &sparseResidencyBuffer, &sparseResidencyImage2D, &sparseResidencyImage3D, &sparseResidency2Samples, &sparseResidency4Samples, &sparseResidency8Samples, &sparseResidency16Samples, &sparseResidencyAliased, &variableMultisampleRate, &inheritedQueries)) return -1;

                if (robustBufferAccess != NULL && robustBufferAccess != Py_None) {
                
                    (self->base)->robustBufferAccess = PyLong_AsLong(robustBufferAccess);
                
 } 

                if (fullDrawIndexUint32 != NULL && fullDrawIndexUint32 != Py_None) {
                
                    (self->base)->fullDrawIndexUint32 = PyLong_AsLong(fullDrawIndexUint32);
                
 } 

                if (imageCubeArray != NULL && imageCubeArray != Py_None) {
                
                    (self->base)->imageCubeArray = PyLong_AsLong(imageCubeArray);
                
 } 

                if (independentBlend != NULL && independentBlend != Py_None) {
                
                    (self->base)->independentBlend = PyLong_AsLong(independentBlend);
                
 } 

                if (geometryShader != NULL && geometryShader != Py_None) {
                
                    (self->base)->geometryShader = PyLong_AsLong(geometryShader);
                
 } 

                if (tessellationShader != NULL && tessellationShader != Py_None) {
                
                    (self->base)->tessellationShader = PyLong_AsLong(tessellationShader);
                
 } 

                if (sampleRateShading != NULL && sampleRateShading != Py_None) {
                
                    (self->base)->sampleRateShading = PyLong_AsLong(sampleRateShading);
                
 } 

                if (dualSrcBlend != NULL && dualSrcBlend != Py_None) {
                
                    (self->base)->dualSrcBlend = PyLong_AsLong(dualSrcBlend);
                
 } 

                if (logicOp != NULL && logicOp != Py_None) {
                
                    (self->base)->logicOp = PyLong_AsLong(logicOp);
                
 } 

                if (multiDrawIndirect != NULL && multiDrawIndirect != Py_None) {
                
                    (self->base)->multiDrawIndirect = PyLong_AsLong(multiDrawIndirect);
                
 } 

                if (drawIndirectFirstInstance != NULL && drawIndirectFirstInstance != Py_None) {
                
                    (self->base)->drawIndirectFirstInstance = PyLong_AsLong(drawIndirectFirstInstance);
                
 } 

                if (depthClamp != NULL && depthClamp != Py_None) {
                
                    (self->base)->depthClamp = PyLong_AsLong(depthClamp);
                
 } 

                if (depthBiasClamp != NULL && depthBiasClamp != Py_None) {
                
                    (self->base)->depthBiasClamp = PyLong_AsLong(depthBiasClamp);
                
 } 

                if (fillModeNonSolid != NULL && fillModeNonSolid != Py_None) {
                
                    (self->base)->fillModeNonSolid = PyLong_AsLong(fillModeNonSolid);
                
 } 

                if (depthBounds != NULL && depthBounds != Py_None) {
                
                    (self->base)->depthBounds = PyLong_AsLong(depthBounds);
                
 } 

                if (wideLines != NULL && wideLines != Py_None) {
                
                    (self->base)->wideLines = PyLong_AsLong(wideLines);
                
 } 

                if (largePoints != NULL && largePoints != Py_None) {
                
                    (self->base)->largePoints = PyLong_AsLong(largePoints);
                
 } 

                if (alphaToOne != NULL && alphaToOne != Py_None) {
                
                    (self->base)->alphaToOne = PyLong_AsLong(alphaToOne);
                
 } 

                if (multiViewport != NULL && multiViewport != Py_None) {
                
                    (self->base)->multiViewport = PyLong_AsLong(multiViewport);
                
 } 

                if (samplerAnisotropy != NULL && samplerAnisotropy != Py_None) {
                
                    (self->base)->samplerAnisotropy = PyLong_AsLong(samplerAnisotropy);
                
 } 

                if (textureCompressionETC2 != NULL && textureCompressionETC2 != Py_None) {
                
                    (self->base)->textureCompressionETC2 = PyLong_AsLong(textureCompressionETC2);
                
 } 

                if (textureCompressionASTC_LDR != NULL && textureCompressionASTC_LDR != Py_None) {
                
                    (self->base)->textureCompressionASTC_LDR = PyLong_AsLong(textureCompressionASTC_LDR);
                
 } 

                if (textureCompressionBC != NULL && textureCompressionBC != Py_None) {
                
                    (self->base)->textureCompressionBC = PyLong_AsLong(textureCompressionBC);
                
 } 

                if (occlusionQueryPrecise != NULL && occlusionQueryPrecise != Py_None) {
                
                    (self->base)->occlusionQueryPrecise = PyLong_AsLong(occlusionQueryPrecise);
                
 } 

                if (pipelineStatisticsQuery != NULL && pipelineStatisticsQuery != Py_None) {
                
                    (self->base)->pipelineStatisticsQuery = PyLong_AsLong(pipelineStatisticsQuery);
                
 } 

                if (vertexPipelineStoresAndAtomics != NULL && vertexPipelineStoresAndAtomics != Py_None) {
                
                    (self->base)->vertexPipelineStoresAndAtomics = PyLong_AsLong(vertexPipelineStoresAndAtomics);
                
 } 

                if (fragmentStoresAndAtomics != NULL && fragmentStoresAndAtomics != Py_None) {
                
                    (self->base)->fragmentStoresAndAtomics = PyLong_AsLong(fragmentStoresAndAtomics);
                
 } 

                if (shaderTessellationAndGeometryPointSize != NULL && shaderTessellationAndGeometryPointSize != Py_None) {
                
                    (self->base)->shaderTessellationAndGeometryPointSize = PyLong_AsLong(shaderTessellationAndGeometryPointSize);
                
 } 

                if (shaderImageGatherExtended != NULL && shaderImageGatherExtended != Py_None) {
                
                    (self->base)->shaderImageGatherExtended = PyLong_AsLong(shaderImageGatherExtended);
                
 } 

                if (shaderStorageImageExtendedFormats != NULL && shaderStorageImageExtendedFormats != Py_None) {
                
                    (self->base)->shaderStorageImageExtendedFormats = PyLong_AsLong(shaderStorageImageExtendedFormats);
                
 } 

                if (shaderStorageImageMultisample != NULL && shaderStorageImageMultisample != Py_None) {
                
                    (self->base)->shaderStorageImageMultisample = PyLong_AsLong(shaderStorageImageMultisample);
                
 } 

                if (shaderStorageImageReadWithoutFormat != NULL && shaderStorageImageReadWithoutFormat != Py_None) {
                
                    (self->base)->shaderStorageImageReadWithoutFormat = PyLong_AsLong(shaderStorageImageReadWithoutFormat);
                
 } 

                if (shaderStorageImageWriteWithoutFormat != NULL && shaderStorageImageWriteWithoutFormat != Py_None) {
                
                    (self->base)->shaderStorageImageWriteWithoutFormat = PyLong_AsLong(shaderStorageImageWriteWithoutFormat);
                
 } 

                if (shaderUniformBufferArrayDynamicIndexing != NULL && shaderUniformBufferArrayDynamicIndexing != Py_None) {
                
                    (self->base)->shaderUniformBufferArrayDynamicIndexing = PyLong_AsLong(shaderUniformBufferArrayDynamicIndexing);
                
 } 

                if (shaderSampledImageArrayDynamicIndexing != NULL && shaderSampledImageArrayDynamicIndexing != Py_None) {
                
                    (self->base)->shaderSampledImageArrayDynamicIndexing = PyLong_AsLong(shaderSampledImageArrayDynamicIndexing);
                
 } 

                if (shaderStorageBufferArrayDynamicIndexing != NULL && shaderStorageBufferArrayDynamicIndexing != Py_None) {
                
                    (self->base)->shaderStorageBufferArrayDynamicIndexing = PyLong_AsLong(shaderStorageBufferArrayDynamicIndexing);
                
 } 

                if (shaderStorageImageArrayDynamicIndexing != NULL && shaderStorageImageArrayDynamicIndexing != Py_None) {
                
                    (self->base)->shaderStorageImageArrayDynamicIndexing = PyLong_AsLong(shaderStorageImageArrayDynamicIndexing);
                
 } 

                if (shaderClipDistance != NULL && shaderClipDistance != Py_None) {
                
                    (self->base)->shaderClipDistance = PyLong_AsLong(shaderClipDistance);
                
 } 

                if (shaderCullDistance != NULL && shaderCullDistance != Py_None) {
                
                    (self->base)->shaderCullDistance = PyLong_AsLong(shaderCullDistance);
                
 } 

                if (shaderFloat64 != NULL && shaderFloat64 != Py_None) {
                
                    (self->base)->shaderFloat64 = PyLong_AsLong(shaderFloat64);
                
 } 

                if (shaderInt64 != NULL && shaderInt64 != Py_None) {
                
                    (self->base)->shaderInt64 = PyLong_AsLong(shaderInt64);
                
 } 

                if (shaderInt16 != NULL && shaderInt16 != Py_None) {
                
                    (self->base)->shaderInt16 = PyLong_AsLong(shaderInt16);
                
 } 

                if (shaderResourceResidency != NULL && shaderResourceResidency != Py_None) {
                
                    (self->base)->shaderResourceResidency = PyLong_AsLong(shaderResourceResidency);
                
 } 

                if (shaderResourceMinLod != NULL && shaderResourceMinLod != Py_None) {
                
                    (self->base)->shaderResourceMinLod = PyLong_AsLong(shaderResourceMinLod);
                
 } 

                if (sparseBinding != NULL && sparseBinding != Py_None) {
                
                    (self->base)->sparseBinding = PyLong_AsLong(sparseBinding);
                
 } 

                if (sparseResidencyBuffer != NULL && sparseResidencyBuffer != Py_None) {
                
                    (self->base)->sparseResidencyBuffer = PyLong_AsLong(sparseResidencyBuffer);
                
 } 

                if (sparseResidencyImage2D != NULL && sparseResidencyImage2D != Py_None) {
                
                    (self->base)->sparseResidencyImage2D = PyLong_AsLong(sparseResidencyImage2D);
                
 } 

                if (sparseResidencyImage3D != NULL && sparseResidencyImage3D != Py_None) {
                
                    (self->base)->sparseResidencyImage3D = PyLong_AsLong(sparseResidencyImage3D);
                
 } 

                if (sparseResidency2Samples != NULL && sparseResidency2Samples != Py_None) {
                
                    (self->base)->sparseResidency2Samples = PyLong_AsLong(sparseResidency2Samples);
                
 } 

                if (sparseResidency4Samples != NULL && sparseResidency4Samples != Py_None) {
                
                    (self->base)->sparseResidency4Samples = PyLong_AsLong(sparseResidency4Samples);
                
 } 

                if (sparseResidency8Samples != NULL && sparseResidency8Samples != Py_None) {
                
                    (self->base)->sparseResidency8Samples = PyLong_AsLong(sparseResidency8Samples);
                
 } 

                if (sparseResidency16Samples != NULL && sparseResidency16Samples != Py_None) {
                
                    (self->base)->sparseResidency16Samples = PyLong_AsLong(sparseResidency16Samples);
                
 } 

                if (sparseResidencyAliased != NULL && sparseResidencyAliased != Py_None) {
                
                    (self->base)->sparseResidencyAliased = PyLong_AsLong(sparseResidencyAliased);
                
 } 

                if (variableMultisampleRate != NULL && variableMultisampleRate != Py_None) {
                
                    (self->base)->variableMultisampleRate = PyLong_AsLong(variableMultisampleRate);
                
 } 

                if (inheritedQueries != NULL && inheritedQueries != Py_None) {
                
                    (self->base)->inheritedQueries = PyLong_AsLong(inheritedQueries);
                
 } 

return 0; }
            static PyTypeObject PyVkPhysicalDeviceFeaturesType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPhysicalDeviceFeatures", sizeof(PyVkPhysicalDeviceFeatures), 0,
                (destructor)PyVkPhysicalDeviceFeatures_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPhysicalDeviceFeatures object",0,0,0,0,0,0,0,0,
                PyVkPhysicalDeviceFeatures_getsetters,0,0,0,0,0,(initproc)PyVkPhysicalDeviceFeatures_init,0,PyVkPhysicalDeviceFeatures_new,};
        
            static void PyVkPhysicalDeviceSparseProperties_del(PyVkPhysicalDeviceSparseProperties* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPhysicalDeviceSparseProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPhysicalDeviceSparseProperties *self;
                self = (PyVkPhysicalDeviceSparseProperties *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPhysicalDeviceSparseProperties));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPhysicalDeviceSparseProperties");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkPhysicalDeviceSparseProperties_getsetters[] = {
                {NULL}};

            static int
            PyVkPhysicalDeviceSparseProperties_init(PyVkPhysicalDeviceSparseProperties *self, PyObject *args, PyObject *kwds) {
            return 0; }
            static PyTypeObject PyVkPhysicalDeviceSparsePropertiesType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPhysicalDeviceSparseProperties", sizeof(PyVkPhysicalDeviceSparseProperties), 0,
                (destructor)PyVkPhysicalDeviceSparseProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPhysicalDeviceSparseProperties object",0,0,0,0,0,0,0,0,
                PyVkPhysicalDeviceSparseProperties_getsetters,0,0,0,0,0,(initproc)PyVkPhysicalDeviceSparseProperties_init,0,PyVkPhysicalDeviceSparseProperties_new,};
        
            static void PyVkPhysicalDeviceLimits_del(PyVkPhysicalDeviceLimits* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPhysicalDeviceLimits_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPhysicalDeviceLimits *self;
                self = (PyVkPhysicalDeviceLimits *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPhysicalDeviceLimits));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPhysicalDeviceLimits");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxImageDimension1D(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxImageDimension1D);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxImageDimension2D(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxImageDimension2D);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxImageDimension3D(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxImageDimension3D);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxImageDimensionCube(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxImageDimensionCube);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxImageArrayLayers(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxImageArrayLayers);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxTexelBufferElements(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxTexelBufferElements);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxUniformBufferRange(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxUniformBufferRange);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxStorageBufferRange(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxStorageBufferRange);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxPushConstantsSize(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxPushConstantsSize);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxMemoryAllocationCount(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxMemoryAllocationCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxSamplerAllocationCount(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxSamplerAllocationCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxBoundDescriptorSets(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxBoundDescriptorSets);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSamplers(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorSamplers);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorUniformBuffers(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorUniformBuffers);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageBuffers(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorStorageBuffers);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSampledImages(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorSampledImages);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageImages(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorStorageImages);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorInputAttachments(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorInputAttachments);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageResources(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageResources);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetSamplers(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetSamplers);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffers(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetUniformBuffers);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffersDynamic(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetUniformBuffersDynamic);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffers(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetStorageBuffers);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffersDynamic(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetStorageBuffersDynamic);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetSampledImages(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetSampledImages);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageImages(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetStorageImages);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetInputAttachments(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetInputAttachments);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxVertexInputAttributes(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxVertexInputAttributes);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxVertexInputBindings(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxVertexInputBindings);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxVertexInputAttributeOffset(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxVertexInputAttributeOffset);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxVertexInputBindingStride(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxVertexInputBindingStride);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxVertexOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxVertexOutputComponents);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationGenerationLevel(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationGenerationLevel);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationPatchSize(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationPatchSize);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexInputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationControlPerVertexInputComponents);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationControlPerVertexOutputComponents);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationControlPerPatchOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationControlPerPatchOutputComponents);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationControlTotalOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationControlTotalOutputComponents);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationInputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationEvaluationInputComponents);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationEvaluationOutputComponents);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxGeometryShaderInvocations(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxGeometryShaderInvocations);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxGeometryInputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxGeometryInputComponents);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxGeometryOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxGeometryOutputComponents);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxGeometryOutputVertices(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxGeometryOutputVertices);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxGeometryTotalOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxGeometryTotalOutputComponents);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxFragmentInputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxFragmentInputComponents);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxFragmentOutputAttachments(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxFragmentOutputAttachments);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxFragmentDualSrcAttachments(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxFragmentDualSrcAttachments);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxFragmentCombinedOutputResources(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxFragmentCombinedOutputResources);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxComputeSharedMemorySize(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxComputeSharedMemorySize);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupCount(PyVkPhysicalDeviceLimits *self, void *closure){
            
        PyObject* value = PyList_New(0);
        int nb = sizeof((self->base)->maxComputeWorkGroupCount) / sizeof((self->base)->maxComputeWorkGroupCount[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* py_tmp = PyLong_FromLong((long) (self->base)->maxComputeWorkGroupCount[i]);
            PyList_Append(value, py_tmp);
        }
        
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupInvocations(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxComputeWorkGroupInvocations);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupSize(PyVkPhysicalDeviceLimits *self, void *closure){
            
        PyObject* value = PyList_New(0);
        int nb = sizeof((self->base)->maxComputeWorkGroupSize) / sizeof((self->base)->maxComputeWorkGroupSize[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* py_tmp = PyLong_FromLong((long) (self->base)->maxComputeWorkGroupSize[i]);
            PyList_Append(value, py_tmp);
        }
        
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getsubPixelPrecisionBits(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->subPixelPrecisionBits);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getsubTexelPrecisionBits(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->subTexelPrecisionBits);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmipmapPrecisionBits(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->mipmapPrecisionBits);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxDrawIndexedIndexValue(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxDrawIndexedIndexValue);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxDrawIndirectCount(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxDrawIndirectCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxSamplerLodBias(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->maxSamplerLodBias);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxSamplerAnisotropy(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->maxSamplerAnisotropy);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxViewports(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxViewports);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxViewportDimensions(PyVkPhysicalDeviceLimits *self, void *closure){
            
        PyObject* value = PyList_New(0);
        int nb = sizeof((self->base)->maxViewportDimensions) / sizeof((self->base)->maxViewportDimensions[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* py_tmp = PyLong_FromLong((long) (self->base)->maxViewportDimensions[i]);
            PyList_Append(value, py_tmp);
        }
        
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getviewportBoundsRange(PyVkPhysicalDeviceLimits *self, void *closure){
            
        PyObject* value = PyList_New(0);
        int nb = sizeof((self->base)->viewportBoundsRange) / sizeof((self->base)->viewportBoundsRange[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->viewportBoundsRange[i]);
            PyList_Append(value, py_tmp);
        }
        
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getviewportSubPixelBits(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->viewportSubPixelBits);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getminMemoryMapAlignment(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->minMemoryMapAlignment);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getminTexelOffset(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->minTexelOffset);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxTexelOffset(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxTexelOffset);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getminTexelGatherOffset(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->minTexelGatherOffset);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxTexelGatherOffset(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxTexelGatherOffset);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getminInterpolationOffset(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->minInterpolationOffset);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxInterpolationOffset(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->maxInterpolationOffset);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getsubPixelInterpolationOffsetBits(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->subPixelInterpolationOffsetBits);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxFramebufferWidth(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxFramebufferWidth);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxFramebufferHeight(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxFramebufferHeight);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxFramebufferLayers(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxFramebufferLayers);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxColorAttachments(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxColorAttachments);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxSampleMaskWords(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxSampleMaskWords);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_gettimestampPeriod(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->timestampPeriod);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxClipDistances(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxClipDistances);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxCullDistances(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxCullDistances);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getmaxCombinedClipAndCullDistances(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxCombinedClipAndCullDistances);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getdiscreteQueuePriorities(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->discreteQueuePriorities);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getpointSizeRange(PyVkPhysicalDeviceLimits *self, void *closure){
            
        PyObject* value = PyList_New(0);
        int nb = sizeof((self->base)->pointSizeRange) / sizeof((self->base)->pointSizeRange[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->pointSizeRange[i]);
            PyList_Append(value, py_tmp);
        }
        
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getlineWidthRange(PyVkPhysicalDeviceLimits *self, void *closure){
            
        PyObject* value = PyList_New(0);
        int nb = sizeof((self->base)->lineWidthRange) / sizeof((self->base)->lineWidthRange[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->lineWidthRange[i]);
            PyList_Append(value, py_tmp);
        }
        
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getpointSizeGranularity(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->pointSizeGranularity);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPhysicalDeviceLimits_getlineWidthGranularity(PyVkPhysicalDeviceLimits *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->lineWidthGranularity);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPhysicalDeviceLimits_getsetters[] = {
                
                    { "maxImageDimension1D", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimension1D, NULL, "", NULL},
                
                    { "maxImageDimension2D", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimension2D, NULL, "", NULL},
                
                    { "maxImageDimension3D", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimension3D, NULL, "", NULL},
                
                    { "maxImageDimensionCube", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimensionCube, NULL, "", NULL},
                
                    { "maxImageArrayLayers", (getter)PyVkPhysicalDeviceLimits_getmaxImageArrayLayers, NULL, "", NULL},
                
                    { "maxTexelBufferElements", (getter)PyVkPhysicalDeviceLimits_getmaxTexelBufferElements, NULL, "", NULL},
                
                    { "maxUniformBufferRange", (getter)PyVkPhysicalDeviceLimits_getmaxUniformBufferRange, NULL, "", NULL},
                
                    { "maxStorageBufferRange", (getter)PyVkPhysicalDeviceLimits_getmaxStorageBufferRange, NULL, "", NULL},
                
                    { "maxPushConstantsSize", (getter)PyVkPhysicalDeviceLimits_getmaxPushConstantsSize, NULL, "", NULL},
                
                    { "maxMemoryAllocationCount", (getter)PyVkPhysicalDeviceLimits_getmaxMemoryAllocationCount, NULL, "", NULL},
                
                    { "maxSamplerAllocationCount", (getter)PyVkPhysicalDeviceLimits_getmaxSamplerAllocationCount, NULL, "", NULL},
                
                    { "maxBoundDescriptorSets", (getter)PyVkPhysicalDeviceLimits_getmaxBoundDescriptorSets, NULL, "", NULL},
                
                    { "maxPerStageDescriptorSamplers", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSamplers, NULL, "", NULL},
                
                    { "maxPerStageDescriptorUniformBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorUniformBuffers, NULL, "", NULL},
                
                    { "maxPerStageDescriptorStorageBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageBuffers, NULL, "", NULL},
                
                    { "maxPerStageDescriptorSampledImages", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSampledImages, NULL, "", NULL},
                
                    { "maxPerStageDescriptorStorageImages", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageImages, NULL, "", NULL},
                
                    { "maxPerStageDescriptorInputAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorInputAttachments, NULL, "", NULL},
                
                    { "maxPerStageResources", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageResources, NULL, "", NULL},
                
                    { "maxDescriptorSetSamplers", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetSamplers, NULL, "", NULL},
                
                    { "maxDescriptorSetUniformBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffers, NULL, "", NULL},
                
                    { "maxDescriptorSetUniformBuffersDynamic", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffersDynamic, NULL, "", NULL},
                
                    { "maxDescriptorSetStorageBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffers, NULL, "", NULL},
                
                    { "maxDescriptorSetStorageBuffersDynamic", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffersDynamic, NULL, "", NULL},
                
                    { "maxDescriptorSetSampledImages", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetSampledImages, NULL, "", NULL},
                
                    { "maxDescriptorSetStorageImages", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageImages, NULL, "", NULL},
                
                    { "maxDescriptorSetInputAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetInputAttachments, NULL, "", NULL},
                
                    { "maxVertexInputAttributes", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputAttributes, NULL, "", NULL},
                
                    { "maxVertexInputBindings", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputBindings, NULL, "", NULL},
                
                    { "maxVertexInputAttributeOffset", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputAttributeOffset, NULL, "", NULL},
                
                    { "maxVertexInputBindingStride", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputBindingStride, NULL, "", NULL},
                
                    { "maxVertexOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxVertexOutputComponents, NULL, "", NULL},
                
                    { "maxTessellationGenerationLevel", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationGenerationLevel, NULL, "", NULL},
                
                    { "maxTessellationPatchSize", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationPatchSize, NULL, "", NULL},
                
                    { "maxTessellationControlPerVertexInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexInputComponents, NULL, "", NULL},
                
                    { "maxTessellationControlPerVertexOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexOutputComponents, NULL, "", NULL},
                
                    { "maxTessellationControlPerPatchOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlPerPatchOutputComponents, NULL, "", NULL},
                
                    { "maxTessellationControlTotalOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlTotalOutputComponents, NULL, "", NULL},
                
                    { "maxTessellationEvaluationInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationInputComponents, NULL, "", NULL},
                
                    { "maxTessellationEvaluationOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationOutputComponents, NULL, "", NULL},
                
                    { "maxGeometryShaderInvocations", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryShaderInvocations, NULL, "", NULL},
                
                    { "maxGeometryInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryInputComponents, NULL, "", NULL},
                
                    { "maxGeometryOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryOutputComponents, NULL, "", NULL},
                
                    { "maxGeometryOutputVertices", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryOutputVertices, NULL, "", NULL},
                
                    { "maxGeometryTotalOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryTotalOutputComponents, NULL, "", NULL},
                
                    { "maxFragmentInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentInputComponents, NULL, "", NULL},
                
                    { "maxFragmentOutputAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentOutputAttachments, NULL, "", NULL},
                
                    { "maxFragmentDualSrcAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentDualSrcAttachments, NULL, "", NULL},
                
                    { "maxFragmentCombinedOutputResources", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentCombinedOutputResources, NULL, "", NULL},
                
                    { "maxComputeSharedMemorySize", (getter)PyVkPhysicalDeviceLimits_getmaxComputeSharedMemorySize, NULL, "", NULL},
                
                    { "maxComputeWorkGroupCount", (getter)PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupCount, NULL, "", NULL},
                
                    { "maxComputeWorkGroupInvocations", (getter)PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupInvocations, NULL, "", NULL},
                
                    { "maxComputeWorkGroupSize", (getter)PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupSize, NULL, "", NULL},
                
                    { "subPixelPrecisionBits", (getter)PyVkPhysicalDeviceLimits_getsubPixelPrecisionBits, NULL, "", NULL},
                
                    { "subTexelPrecisionBits", (getter)PyVkPhysicalDeviceLimits_getsubTexelPrecisionBits, NULL, "", NULL},
                
                    { "mipmapPrecisionBits", (getter)PyVkPhysicalDeviceLimits_getmipmapPrecisionBits, NULL, "", NULL},
                
                    { "maxDrawIndexedIndexValue", (getter)PyVkPhysicalDeviceLimits_getmaxDrawIndexedIndexValue, NULL, "", NULL},
                
                    { "maxDrawIndirectCount", (getter)PyVkPhysicalDeviceLimits_getmaxDrawIndirectCount, NULL, "", NULL},
                
                    { "maxSamplerLodBias", (getter)PyVkPhysicalDeviceLimits_getmaxSamplerLodBias, NULL, "", NULL},
                
                    { "maxSamplerAnisotropy", (getter)PyVkPhysicalDeviceLimits_getmaxSamplerAnisotropy, NULL, "", NULL},
                
                    { "maxViewports", (getter)PyVkPhysicalDeviceLimits_getmaxViewports, NULL, "", NULL},
                
                    { "maxViewportDimensions", (getter)PyVkPhysicalDeviceLimits_getmaxViewportDimensions, NULL, "", NULL},
                
                    { "viewportBoundsRange", (getter)PyVkPhysicalDeviceLimits_getviewportBoundsRange, NULL, "", NULL},
                
                    { "viewportSubPixelBits", (getter)PyVkPhysicalDeviceLimits_getviewportSubPixelBits, NULL, "", NULL},
                
                    { "minMemoryMapAlignment", (getter)PyVkPhysicalDeviceLimits_getminMemoryMapAlignment, NULL, "", NULL},
                
                    { "minTexelOffset", (getter)PyVkPhysicalDeviceLimits_getminTexelOffset, NULL, "", NULL},
                
                    { "maxTexelOffset", (getter)PyVkPhysicalDeviceLimits_getmaxTexelOffset, NULL, "", NULL},
                
                    { "minTexelGatherOffset", (getter)PyVkPhysicalDeviceLimits_getminTexelGatherOffset, NULL, "", NULL},
                
                    { "maxTexelGatherOffset", (getter)PyVkPhysicalDeviceLimits_getmaxTexelGatherOffset, NULL, "", NULL},
                
                    { "minInterpolationOffset", (getter)PyVkPhysicalDeviceLimits_getminInterpolationOffset, NULL, "", NULL},
                
                    { "maxInterpolationOffset", (getter)PyVkPhysicalDeviceLimits_getmaxInterpolationOffset, NULL, "", NULL},
                
                    { "subPixelInterpolationOffsetBits", (getter)PyVkPhysicalDeviceLimits_getsubPixelInterpolationOffsetBits, NULL, "", NULL},
                
                    { "maxFramebufferWidth", (getter)PyVkPhysicalDeviceLimits_getmaxFramebufferWidth, NULL, "", NULL},
                
                    { "maxFramebufferHeight", (getter)PyVkPhysicalDeviceLimits_getmaxFramebufferHeight, NULL, "", NULL},
                
                    { "maxFramebufferLayers", (getter)PyVkPhysicalDeviceLimits_getmaxFramebufferLayers, NULL, "", NULL},
                
                    { "maxColorAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxColorAttachments, NULL, "", NULL},
                
                    { "maxSampleMaskWords", (getter)PyVkPhysicalDeviceLimits_getmaxSampleMaskWords, NULL, "", NULL},
                
                    { "timestampPeriod", (getter)PyVkPhysicalDeviceLimits_gettimestampPeriod, NULL, "", NULL},
                
                    { "maxClipDistances", (getter)PyVkPhysicalDeviceLimits_getmaxClipDistances, NULL, "", NULL},
                
                    { "maxCullDistances", (getter)PyVkPhysicalDeviceLimits_getmaxCullDistances, NULL, "", NULL},
                
                    { "maxCombinedClipAndCullDistances", (getter)PyVkPhysicalDeviceLimits_getmaxCombinedClipAndCullDistances, NULL, "", NULL},
                
                    { "discreteQueuePriorities", (getter)PyVkPhysicalDeviceLimits_getdiscreteQueuePriorities, NULL, "", NULL},
                
                    { "pointSizeRange", (getter)PyVkPhysicalDeviceLimits_getpointSizeRange, NULL, "", NULL},
                
                    { "lineWidthRange", (getter)PyVkPhysicalDeviceLimits_getlineWidthRange, NULL, "", NULL},
                
                    { "pointSizeGranularity", (getter)PyVkPhysicalDeviceLimits_getpointSizeGranularity, NULL, "", NULL},
                
                    { "lineWidthGranularity", (getter)PyVkPhysicalDeviceLimits_getlineWidthGranularity, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPhysicalDeviceLimits_init(PyVkPhysicalDeviceLimits *self, PyObject *args, PyObject *kwds) {
            return 0; }
            static PyTypeObject PyVkPhysicalDeviceLimitsType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPhysicalDeviceLimits", sizeof(PyVkPhysicalDeviceLimits), 0,
                (destructor)PyVkPhysicalDeviceLimits_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPhysicalDeviceLimits object",0,0,0,0,0,0,0,0,
                PyVkPhysicalDeviceLimits_getsetters,0,0,0,0,0,(initproc)PyVkPhysicalDeviceLimits_init,0,PyVkPhysicalDeviceLimits_new,};
        
            static void PyVkSemaphoreCreateInfo_del(PyVkSemaphoreCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSemaphoreCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSemaphoreCreateInfo *self;
                self = (PyVkSemaphoreCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSemaphoreCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSemaphoreCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkSemaphoreCreateInfo_getpNext(PyVkSemaphoreCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkSemaphoreCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkSemaphoreCreateInfo_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkSemaphoreCreateInfo_init(PyVkSemaphoreCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
static char *kwlist[] = {"sType","pNext","flags",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &sType, &pNext, &flags)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

return 0; }
            static PyTypeObject PyVkSemaphoreCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSemaphoreCreateInfo", sizeof(PyVkSemaphoreCreateInfo), 0,
                (destructor)PyVkSemaphoreCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSemaphoreCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkSemaphoreCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkSemaphoreCreateInfo_init,0,PyVkSemaphoreCreateInfo_new,};
        
            static void PyVkQueryPoolCreateInfo_del(PyVkQueryPoolCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkQueryPoolCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkQueryPoolCreateInfo *self;
                self = (PyVkQueryPoolCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkQueryPoolCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkQueryPoolCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkQueryPoolCreateInfo_getpNext(PyVkQueryPoolCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkQueryPoolCreateInfo_getqueryCount(PyVkQueryPoolCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->queryCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkQueryPoolCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkQueryPoolCreateInfo_getpNext, NULL, "", NULL},
                
                    { "queryCount", (getter)PyVkQueryPoolCreateInfo_getqueryCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkQueryPoolCreateInfo_init(PyVkQueryPoolCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* queryType = NULL;
PyObject* queryCount = NULL;
PyObject* pipelineStatistics = NULL;
static char *kwlist[] = {"sType","pNext","flags","queryType","queryCount","pipelineStatistics",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOO", kwlist, &sType, &pNext, &flags, &queryType, &queryCount, &pipelineStatistics)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (queryType != NULL && queryType != Py_None) {
                
                    (self->base)->queryType = PyLong_AsLong(queryType);
                
 } 

                if (queryCount != NULL && queryCount != Py_None) {
                (self->base)->queryCount = (uint32_t) PyLong_AsLong(queryCount);
 } 

                if (pipelineStatistics != NULL && pipelineStatistics != Py_None) {
                
                    (self->base)->pipelineStatistics = PyLong_AsLong(pipelineStatistics);
                
 } 

return 0; }
            static PyTypeObject PyVkQueryPoolCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkQueryPoolCreateInfo", sizeof(PyVkQueryPoolCreateInfo), 0,
                (destructor)PyVkQueryPoolCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkQueryPoolCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkQueryPoolCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkQueryPoolCreateInfo_init,0,PyVkQueryPoolCreateInfo_new,};
        
            static void PyVkFramebufferCreateInfo_del(PyVkFramebufferCreateInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkFramebufferCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkFramebufferCreateInfo *self;
                self = (PyVkFramebufferCreateInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkFramebufferCreateInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkFramebufferCreateInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkFramebufferCreateInfo_getpNext(PyVkFramebufferCreateInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkFramebufferCreateInfo_getattachmentCount(PyVkFramebufferCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->attachmentCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkFramebufferCreateInfo_getwidth(PyVkFramebufferCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->width);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkFramebufferCreateInfo_getheight(PyVkFramebufferCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->height);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkFramebufferCreateInfo_getlayers(PyVkFramebufferCreateInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->layers);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkFramebufferCreateInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkFramebufferCreateInfo_getpNext, NULL, "", NULL},
                
                    { "attachmentCount", (getter)PyVkFramebufferCreateInfo_getattachmentCount, NULL, "", NULL},
                
                    { "width", (getter)PyVkFramebufferCreateInfo_getwidth, NULL, "", NULL},
                
                    { "height", (getter)PyVkFramebufferCreateInfo_getheight, NULL, "", NULL},
                
                    { "layers", (getter)PyVkFramebufferCreateInfo_getlayers, NULL, "", NULL},
                {NULL}};

            static int
            PyVkFramebufferCreateInfo_init(PyVkFramebufferCreateInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* renderPass = NULL;
PyObject* attachmentCount = NULL;
PyObject* pAttachments = NULL;
PyObject* width = NULL;
PyObject* height = NULL;
PyObject* layers = NULL;
static char *kwlist[] = {"sType","pNext","flags","renderPass","attachmentCount","pAttachments","width","height","layers",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOO", kwlist, &sType, &pNext, &flags, &renderPass, &attachmentCount, &pAttachments, &width, &height, &layers)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (renderPass != NULL && renderPass != Py_None) {
                
                (self->base)->renderPass = PyCapsule_GetPointer(renderPass, "VkRenderPass");
            
 } 

                if (attachmentCount != NULL && attachmentCount != Py_None) {
                (self->base)->attachmentCount = (uint32_t) PyLong_AsLong(attachmentCount);
 } 

                if (pAttachments != NULL && pAttachments != Py_None) {
                
                (self->base)->pAttachments = PyCapsule_GetPointer(pAttachments, "VkImageView");
            
 } 

                if (width != NULL && width != Py_None) {
                (self->base)->width = (uint32_t) PyLong_AsLong(width);
 } 

                if (height != NULL && height != Py_None) {
                (self->base)->height = (uint32_t) PyLong_AsLong(height);
 } 

                if (layers != NULL && layers != Py_None) {
                (self->base)->layers = (uint32_t) PyLong_AsLong(layers);
 } 

return 0; }
            static PyTypeObject PyVkFramebufferCreateInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkFramebufferCreateInfo", sizeof(PyVkFramebufferCreateInfo), 0,
                (destructor)PyVkFramebufferCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkFramebufferCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkFramebufferCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkFramebufferCreateInfo_init,0,PyVkFramebufferCreateInfo_new,};
        
            static void PyVkDrawIndirectCommand_del(PyVkDrawIndirectCommand* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDrawIndirectCommand_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDrawIndirectCommand *self;
                self = (PyVkDrawIndirectCommand *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDrawIndirectCommand));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDrawIndirectCommand");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDrawIndirectCommand_getvertexCount(PyVkDrawIndirectCommand *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->vertexCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDrawIndirectCommand_getinstanceCount(PyVkDrawIndirectCommand *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->instanceCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDrawIndirectCommand_getfirstVertex(PyVkDrawIndirectCommand *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->firstVertex);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDrawIndirectCommand_getfirstInstance(PyVkDrawIndirectCommand *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->firstInstance);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDrawIndirectCommand_getsetters[] = {
                
                    { "vertexCount", (getter)PyVkDrawIndirectCommand_getvertexCount, NULL, "", NULL},
                
                    { "instanceCount", (getter)PyVkDrawIndirectCommand_getinstanceCount, NULL, "", NULL},
                
                    { "firstVertex", (getter)PyVkDrawIndirectCommand_getfirstVertex, NULL, "", NULL},
                
                    { "firstInstance", (getter)PyVkDrawIndirectCommand_getfirstInstance, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDrawIndirectCommand_init(PyVkDrawIndirectCommand *self, PyObject *args, PyObject *kwds) {
            PyObject* vertexCount = NULL;
PyObject* instanceCount = NULL;
PyObject* firstVertex = NULL;
PyObject* firstInstance = NULL;
static char *kwlist[] = {"vertexCount","instanceCount","firstVertex","firstInstance",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &vertexCount, &instanceCount, &firstVertex, &firstInstance)) return -1;

                if (vertexCount != NULL && vertexCount != Py_None) {
                (self->base)->vertexCount = (uint32_t) PyLong_AsLong(vertexCount);
 } 

                if (instanceCount != NULL && instanceCount != Py_None) {
                (self->base)->instanceCount = (uint32_t) PyLong_AsLong(instanceCount);
 } 

                if (firstVertex != NULL && firstVertex != Py_None) {
                (self->base)->firstVertex = (uint32_t) PyLong_AsLong(firstVertex);
 } 

                if (firstInstance != NULL && firstInstance != Py_None) {
                (self->base)->firstInstance = (uint32_t) PyLong_AsLong(firstInstance);
 } 

return 0; }
            static PyTypeObject PyVkDrawIndirectCommandType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDrawIndirectCommand", sizeof(PyVkDrawIndirectCommand), 0,
                (destructor)PyVkDrawIndirectCommand_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDrawIndirectCommand object",0,0,0,0,0,0,0,0,
                PyVkDrawIndirectCommand_getsetters,0,0,0,0,0,(initproc)PyVkDrawIndirectCommand_init,0,PyVkDrawIndirectCommand_new,};
        
            static void PyVkDrawIndexedIndirectCommand_del(PyVkDrawIndexedIndirectCommand* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDrawIndexedIndirectCommand_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDrawIndexedIndirectCommand *self;
                self = (PyVkDrawIndexedIndirectCommand *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDrawIndexedIndirectCommand));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDrawIndexedIndirectCommand");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDrawIndexedIndirectCommand_getindexCount(PyVkDrawIndexedIndirectCommand *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->indexCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDrawIndexedIndirectCommand_getinstanceCount(PyVkDrawIndexedIndirectCommand *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->instanceCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDrawIndexedIndirectCommand_getfirstIndex(PyVkDrawIndexedIndirectCommand *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->firstIndex);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDrawIndexedIndirectCommand_getvertexOffset(PyVkDrawIndexedIndirectCommand *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->vertexOffset);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDrawIndexedIndirectCommand_getfirstInstance(PyVkDrawIndexedIndirectCommand *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->firstInstance);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDrawIndexedIndirectCommand_getsetters[] = {
                
                    { "indexCount", (getter)PyVkDrawIndexedIndirectCommand_getindexCount, NULL, "", NULL},
                
                    { "instanceCount", (getter)PyVkDrawIndexedIndirectCommand_getinstanceCount, NULL, "", NULL},
                
                    { "firstIndex", (getter)PyVkDrawIndexedIndirectCommand_getfirstIndex, NULL, "", NULL},
                
                    { "vertexOffset", (getter)PyVkDrawIndexedIndirectCommand_getvertexOffset, NULL, "", NULL},
                
                    { "firstInstance", (getter)PyVkDrawIndexedIndirectCommand_getfirstInstance, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDrawIndexedIndirectCommand_init(PyVkDrawIndexedIndirectCommand *self, PyObject *args, PyObject *kwds) {
            PyObject* indexCount = NULL;
PyObject* instanceCount = NULL;
PyObject* firstIndex = NULL;
PyObject* vertexOffset = NULL;
PyObject* firstInstance = NULL;
static char *kwlist[] = {"indexCount","instanceCount","firstIndex","vertexOffset","firstInstance",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &indexCount, &instanceCount, &firstIndex, &vertexOffset, &firstInstance)) return -1;

                if (indexCount != NULL && indexCount != Py_None) {
                (self->base)->indexCount = (uint32_t) PyLong_AsLong(indexCount);
 } 

                if (instanceCount != NULL && instanceCount != Py_None) {
                (self->base)->instanceCount = (uint32_t) PyLong_AsLong(instanceCount);
 } 

                if (firstIndex != NULL && firstIndex != Py_None) {
                (self->base)->firstIndex = (uint32_t) PyLong_AsLong(firstIndex);
 } 

                if (vertexOffset != NULL && vertexOffset != Py_None) {
                (self->base)->vertexOffset = (int32_t) PyLong_AsLong(vertexOffset);
 } 

                if (firstInstance != NULL && firstInstance != Py_None) {
                (self->base)->firstInstance = (uint32_t) PyLong_AsLong(firstInstance);
 } 

return 0; }
            static PyTypeObject PyVkDrawIndexedIndirectCommandType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDrawIndexedIndirectCommand", sizeof(PyVkDrawIndexedIndirectCommand), 0,
                (destructor)PyVkDrawIndexedIndirectCommand_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDrawIndexedIndirectCommand object",0,0,0,0,0,0,0,0,
                PyVkDrawIndexedIndirectCommand_getsetters,0,0,0,0,0,(initproc)PyVkDrawIndexedIndirectCommand_init,0,PyVkDrawIndexedIndirectCommand_new,};
        
            static void PyVkDispatchIndirectCommand_del(PyVkDispatchIndirectCommand* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDispatchIndirectCommand_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDispatchIndirectCommand *self;
                self = (PyVkDispatchIndirectCommand *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDispatchIndirectCommand));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDispatchIndirectCommand");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDispatchIndirectCommand_getx(PyVkDispatchIndirectCommand *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->x);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDispatchIndirectCommand_gety(PyVkDispatchIndirectCommand *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->y);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDispatchIndirectCommand_getz(PyVkDispatchIndirectCommand *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->z);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDispatchIndirectCommand_getsetters[] = {
                
                    { "x", (getter)PyVkDispatchIndirectCommand_getx, NULL, "", NULL},
                
                    { "y", (getter)PyVkDispatchIndirectCommand_gety, NULL, "", NULL},
                
                    { "z", (getter)PyVkDispatchIndirectCommand_getz, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDispatchIndirectCommand_init(PyVkDispatchIndirectCommand *self, PyObject *args, PyObject *kwds) {
            PyObject* x = NULL;
PyObject* y = NULL;
PyObject* z = NULL;
static char *kwlist[] = {"x","y","z",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &x, &y, &z)) return -1;

                if (x != NULL && x != Py_None) {
                (self->base)->x = (uint32_t) PyLong_AsLong(x);
 } 

                if (y != NULL && y != Py_None) {
                (self->base)->y = (uint32_t) PyLong_AsLong(y);
 } 

                if (z != NULL && z != Py_None) {
                (self->base)->z = (uint32_t) PyLong_AsLong(z);
 } 

return 0; }
            static PyTypeObject PyVkDispatchIndirectCommandType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDispatchIndirectCommand", sizeof(PyVkDispatchIndirectCommand), 0,
                (destructor)PyVkDispatchIndirectCommand_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDispatchIndirectCommand object",0,0,0,0,0,0,0,0,
                PyVkDispatchIndirectCommand_getsetters,0,0,0,0,0,(initproc)PyVkDispatchIndirectCommand_init,0,PyVkDispatchIndirectCommand_new,};
        
            static void PyVkSubmitInfo_del(PyVkSubmitInfo* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSubmitInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSubmitInfo *self;
                self = (PyVkSubmitInfo *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSubmitInfo));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSubmitInfo");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkSubmitInfo_getpNext(PyVkSubmitInfo *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSubmitInfo_getwaitSemaphoreCount(PyVkSubmitInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->waitSemaphoreCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSubmitInfo_getcommandBufferCount(PyVkSubmitInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->commandBufferCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSubmitInfo_getsignalSemaphoreCount(PyVkSubmitInfo *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->signalSemaphoreCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkSubmitInfo_getsetters[] = {
                
                    { "pNext", (getter)PyVkSubmitInfo_getpNext, NULL, "", NULL},
                
                    { "waitSemaphoreCount", (getter)PyVkSubmitInfo_getwaitSemaphoreCount, NULL, "", NULL},
                
                    { "commandBufferCount", (getter)PyVkSubmitInfo_getcommandBufferCount, NULL, "", NULL},
                
                    { "signalSemaphoreCount", (getter)PyVkSubmitInfo_getsignalSemaphoreCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkSubmitInfo_init(PyVkSubmitInfo *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* waitSemaphoreCount = NULL;
PyObject* pWaitSemaphores = NULL;
PyObject* pWaitDstStageMask = NULL;
PyObject* commandBufferCount = NULL;
PyObject* pCommandBuffers = NULL;
PyObject* signalSemaphoreCount = NULL;
PyObject* pSignalSemaphores = NULL;
static char *kwlist[] = {"sType","pNext","waitSemaphoreCount","pWaitSemaphores","pWaitDstStageMask","commandBufferCount","pCommandBuffers","signalSemaphoreCount","pSignalSemaphores",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOO", kwlist, &sType, &pNext, &waitSemaphoreCount, &pWaitSemaphores, &pWaitDstStageMask, &commandBufferCount, &pCommandBuffers, &signalSemaphoreCount, &pSignalSemaphores)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (waitSemaphoreCount != NULL && waitSemaphoreCount != Py_None) {
                (self->base)->waitSemaphoreCount = (uint32_t) PyLong_AsLong(waitSemaphoreCount);
 } 

                if (pWaitSemaphores != NULL && pWaitSemaphores != Py_None) {
                
                (self->base)->pWaitSemaphores = PyCapsule_GetPointer(pWaitSemaphores, "VkSemaphore");
            
 } 

                if (pWaitDstStageMask != NULL && pWaitDstStageMask != Py_None) {
                
                    VkPipelineStageFlags tmp = PyLong_AsLong(pWaitDstStageMask);
                    (self->base)->pWaitDstStageMask = &tmp;
                
 } 

                if (commandBufferCount != NULL && commandBufferCount != Py_None) {
                (self->base)->commandBufferCount = (uint32_t) PyLong_AsLong(commandBufferCount);
 } 

                if (pCommandBuffers != NULL && pCommandBuffers != Py_None) {
                
                (self->base)->pCommandBuffers = PyCapsule_GetPointer(pCommandBuffers, "VkCommandBuffer");
            
 } 

                if (signalSemaphoreCount != NULL && signalSemaphoreCount != Py_None) {
                (self->base)->signalSemaphoreCount = (uint32_t) PyLong_AsLong(signalSemaphoreCount);
 } 

                if (pSignalSemaphores != NULL && pSignalSemaphores != Py_None) {
                
                (self->base)->pSignalSemaphores = PyCapsule_GetPointer(pSignalSemaphores, "VkSemaphore");
            
 } 

return 0; }
            static PyTypeObject PyVkSubmitInfoType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSubmitInfo", sizeof(PyVkSubmitInfo), 0,
                (destructor)PyVkSubmitInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSubmitInfo object",0,0,0,0,0,0,0,0,
                PyVkSubmitInfo_getsetters,0,0,0,0,0,(initproc)PyVkSubmitInfo_init,0,PyVkSubmitInfo_new,};
        
            static void PyVkDisplayPropertiesKHR_del(PyVkDisplayPropertiesKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDisplayPropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDisplayPropertiesKHR *self;
                self = (PyVkDisplayPropertiesKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDisplayPropertiesKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplayPropertiesKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDisplayPropertiesKHR_getdisplayName(PyVkDisplayPropertiesKHR *self, void *closure){
            PyObject* value = PyUnicode_FromString((const char *) (self->base)->displayName);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDisplayPropertiesKHR_getsetters[] = {
                
                    { "displayName", (getter)PyVkDisplayPropertiesKHR_getdisplayName, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDisplayPropertiesKHR_init(PyVkDisplayPropertiesKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* display = NULL;
PyObject* displayName = NULL;
PyObject* physicalDimensions = NULL;
PyObject* physicalResolution = NULL;
PyObject* supportedTransforms = NULL;
PyObject* planeReorderPossible = NULL;
PyObject* persistentContent = NULL;
static char *kwlist[] = {"display","displayName","physicalDimensions","physicalResolution","supportedTransforms","planeReorderPossible","persistentContent",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOO", kwlist, &display, &displayName, &physicalDimensions, &physicalResolution, &supportedTransforms, &planeReorderPossible, &persistentContent)) return -1;

                if (display != NULL && display != Py_None) {
                
                (self->base)->display = PyCapsule_GetPointer(display, "VkDisplayKHR");
            
 } 

                if (displayName != NULL && displayName != Py_None) {
                
        PyObject * tmp51509885 = PyUnicode_AsASCIIString(displayName);
        char* tmp16762162 = PyBytes_AsString(tmp51509885);
        strcpy((self->base)->displayName, tmp16762162);
        Py_DECREF(tmp51509885);
        
 } 

                if (physicalDimensions != NULL && physicalDimensions != Py_None) {
                
                    (self->base)->physicalDimensions = *(((PyVkExtent2D*)physicalDimensions)->base);
                
 } 

                if (physicalResolution != NULL && physicalResolution != Py_None) {
                
                    (self->base)->physicalResolution = *(((PyVkExtent2D*)physicalResolution)->base);
                
 } 

                if (supportedTransforms != NULL && supportedTransforms != Py_None) {
                
                    (self->base)->supportedTransforms = PyLong_AsLong(supportedTransforms);
                
 } 

                if (planeReorderPossible != NULL && planeReorderPossible != Py_None) {
                
                    (self->base)->planeReorderPossible = PyLong_AsLong(planeReorderPossible);
                
 } 

                if (persistentContent != NULL && persistentContent != Py_None) {
                
                    (self->base)->persistentContent = PyLong_AsLong(persistentContent);
                
 } 

return 0; }
            static PyTypeObject PyVkDisplayPropertiesKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplayPropertiesKHR", sizeof(PyVkDisplayPropertiesKHR), 0,
                (destructor)PyVkDisplayPropertiesKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplayPropertiesKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplayPropertiesKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplayPropertiesKHR_init,0,PyVkDisplayPropertiesKHR_new,};
        
            static void PyVkDisplayPlanePropertiesKHR_del(PyVkDisplayPlanePropertiesKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDisplayPlanePropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDisplayPlanePropertiesKHR *self;
                self = (PyVkDisplayPlanePropertiesKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDisplayPlanePropertiesKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplayPlanePropertiesKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDisplayPlanePropertiesKHR_getcurrentStackIndex(PyVkDisplayPlanePropertiesKHR *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->currentStackIndex);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDisplayPlanePropertiesKHR_getsetters[] = {
                
                    { "currentStackIndex", (getter)PyVkDisplayPlanePropertiesKHR_getcurrentStackIndex, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDisplayPlanePropertiesKHR_init(PyVkDisplayPlanePropertiesKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* currentDisplay = NULL;
PyObject* currentStackIndex = NULL;
static char *kwlist[] = {"currentDisplay","currentStackIndex",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OO", kwlist, &currentDisplay, &currentStackIndex)) return -1;

                if (currentDisplay != NULL && currentDisplay != Py_None) {
                
                (self->base)->currentDisplay = PyCapsule_GetPointer(currentDisplay, "VkDisplayKHR");
            
 } 

                if (currentStackIndex != NULL && currentStackIndex != Py_None) {
                (self->base)->currentStackIndex = (uint32_t) PyLong_AsLong(currentStackIndex);
 } 

return 0; }
            static PyTypeObject PyVkDisplayPlanePropertiesKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplayPlanePropertiesKHR", sizeof(PyVkDisplayPlanePropertiesKHR), 0,
                (destructor)PyVkDisplayPlanePropertiesKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplayPlanePropertiesKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplayPlanePropertiesKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplayPlanePropertiesKHR_init,0,PyVkDisplayPlanePropertiesKHR_new,};
        
            static void PyVkDisplayModeParametersKHR_del(PyVkDisplayModeParametersKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDisplayModeParametersKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDisplayModeParametersKHR *self;
                self = (PyVkDisplayModeParametersKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDisplayModeParametersKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplayModeParametersKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDisplayModeParametersKHR_getrefreshRate(PyVkDisplayModeParametersKHR *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->refreshRate);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDisplayModeParametersKHR_getsetters[] = {
                
                    { "refreshRate", (getter)PyVkDisplayModeParametersKHR_getrefreshRate, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDisplayModeParametersKHR_init(PyVkDisplayModeParametersKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* visibleRegion = NULL;
PyObject* refreshRate = NULL;
static char *kwlist[] = {"visibleRegion","refreshRate",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OO", kwlist, &visibleRegion, &refreshRate)) return -1;

                if (visibleRegion != NULL && visibleRegion != Py_None) {
                
                    (self->base)->visibleRegion = *(((PyVkExtent2D*)visibleRegion)->base);
                
 } 

                if (refreshRate != NULL && refreshRate != Py_None) {
                (self->base)->refreshRate = (uint32_t) PyLong_AsLong(refreshRate);
 } 

return 0; }
            static PyTypeObject PyVkDisplayModeParametersKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplayModeParametersKHR", sizeof(PyVkDisplayModeParametersKHR), 0,
                (destructor)PyVkDisplayModeParametersKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplayModeParametersKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplayModeParametersKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplayModeParametersKHR_init,0,PyVkDisplayModeParametersKHR_new,};
        
            static void PyVkDisplayModePropertiesKHR_del(PyVkDisplayModePropertiesKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDisplayModePropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDisplayModePropertiesKHR *self;
                self = (PyVkDisplayModePropertiesKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDisplayModePropertiesKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplayModePropertiesKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkDisplayModePropertiesKHR_getsetters[] = {
                {NULL}};

            static int
            PyVkDisplayModePropertiesKHR_init(PyVkDisplayModePropertiesKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* displayMode = NULL;
PyObject* parameters = NULL;
static char *kwlist[] = {"displayMode","parameters",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OO", kwlist, &displayMode, &parameters)) return -1;

                if (displayMode != NULL && displayMode != Py_None) {
                
                (self->base)->displayMode = PyCapsule_GetPointer(displayMode, "VkDisplayModeKHR");
            
 } 

                if (parameters != NULL && parameters != Py_None) {
                
                    (self->base)->parameters = *(((PyVkDisplayModeParametersKHR*)parameters)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkDisplayModePropertiesKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplayModePropertiesKHR", sizeof(PyVkDisplayModePropertiesKHR), 0,
                (destructor)PyVkDisplayModePropertiesKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplayModePropertiesKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplayModePropertiesKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplayModePropertiesKHR_init,0,PyVkDisplayModePropertiesKHR_new,};
        
            static void PyVkDisplayModeCreateInfoKHR_del(PyVkDisplayModeCreateInfoKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDisplayModeCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDisplayModeCreateInfoKHR *self;
                self = (PyVkDisplayModeCreateInfoKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDisplayModeCreateInfoKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplayModeCreateInfoKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDisplayModeCreateInfoKHR_getpNext(PyVkDisplayModeCreateInfoKHR *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDisplayModeCreateInfoKHR_getsetters[] = {
                
                    { "pNext", (getter)PyVkDisplayModeCreateInfoKHR_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDisplayModeCreateInfoKHR_init(PyVkDisplayModeCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* parameters = NULL;
static char *kwlist[] = {"sType","pNext","flags","parameters",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &sType, &pNext, &flags, &parameters)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (parameters != NULL && parameters != Py_None) {
                
                    (self->base)->parameters = *(((PyVkDisplayModeParametersKHR*)parameters)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkDisplayModeCreateInfoKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplayModeCreateInfoKHR", sizeof(PyVkDisplayModeCreateInfoKHR), 0,
                (destructor)PyVkDisplayModeCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplayModeCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplayModeCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplayModeCreateInfoKHR_init,0,PyVkDisplayModeCreateInfoKHR_new,};
        
            static void PyVkDisplayPlaneCapabilitiesKHR_del(PyVkDisplayPlaneCapabilitiesKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDisplayPlaneCapabilitiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDisplayPlaneCapabilitiesKHR *self;
                self = (PyVkDisplayPlaneCapabilitiesKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDisplayPlaneCapabilitiesKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplayPlaneCapabilitiesKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkDisplayPlaneCapabilitiesKHR_getsetters[] = {
                {NULL}};

            static int
            PyVkDisplayPlaneCapabilitiesKHR_init(PyVkDisplayPlaneCapabilitiesKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* supportedAlpha = NULL;
PyObject* minSrcPosition = NULL;
PyObject* maxSrcPosition = NULL;
PyObject* minSrcExtent = NULL;
PyObject* maxSrcExtent = NULL;
PyObject* minDstPosition = NULL;
PyObject* maxDstPosition = NULL;
PyObject* minDstExtent = NULL;
PyObject* maxDstExtent = NULL;
static char *kwlist[] = {"supportedAlpha","minSrcPosition","maxSrcPosition","minSrcExtent","maxSrcExtent","minDstPosition","maxDstPosition","minDstExtent","maxDstExtent",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOO", kwlist, &supportedAlpha, &minSrcPosition, &maxSrcPosition, &minSrcExtent, &maxSrcExtent, &minDstPosition, &maxDstPosition, &minDstExtent, &maxDstExtent)) return -1;

                if (supportedAlpha != NULL && supportedAlpha != Py_None) {
                
                    (self->base)->supportedAlpha = PyLong_AsLong(supportedAlpha);
                
 } 

                if (minSrcPosition != NULL && minSrcPosition != Py_None) {
                
                    (self->base)->minSrcPosition = *(((PyVkOffset2D*)minSrcPosition)->base);
                
 } 

                if (maxSrcPosition != NULL && maxSrcPosition != Py_None) {
                
                    (self->base)->maxSrcPosition = *(((PyVkOffset2D*)maxSrcPosition)->base);
                
 } 

                if (minSrcExtent != NULL && minSrcExtent != Py_None) {
                
                    (self->base)->minSrcExtent = *(((PyVkExtent2D*)minSrcExtent)->base);
                
 } 

                if (maxSrcExtent != NULL && maxSrcExtent != Py_None) {
                
                    (self->base)->maxSrcExtent = *(((PyVkExtent2D*)maxSrcExtent)->base);
                
 } 

                if (minDstPosition != NULL && minDstPosition != Py_None) {
                
                    (self->base)->minDstPosition = *(((PyVkOffset2D*)minDstPosition)->base);
                
 } 

                if (maxDstPosition != NULL && maxDstPosition != Py_None) {
                
                    (self->base)->maxDstPosition = *(((PyVkOffset2D*)maxDstPosition)->base);
                
 } 

                if (minDstExtent != NULL && minDstExtent != Py_None) {
                
                    (self->base)->minDstExtent = *(((PyVkExtent2D*)minDstExtent)->base);
                
 } 

                if (maxDstExtent != NULL && maxDstExtent != Py_None) {
                
                    (self->base)->maxDstExtent = *(((PyVkExtent2D*)maxDstExtent)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkDisplayPlaneCapabilitiesKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplayPlaneCapabilitiesKHR", sizeof(PyVkDisplayPlaneCapabilitiesKHR), 0,
                (destructor)PyVkDisplayPlaneCapabilitiesKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplayPlaneCapabilitiesKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplayPlaneCapabilitiesKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplayPlaneCapabilitiesKHR_init,0,PyVkDisplayPlaneCapabilitiesKHR_new,};
        
            static void PyVkDisplaySurfaceCreateInfoKHR_del(PyVkDisplaySurfaceCreateInfoKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDisplaySurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDisplaySurfaceCreateInfoKHR *self;
                self = (PyVkDisplaySurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDisplaySurfaceCreateInfoKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplaySurfaceCreateInfoKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDisplaySurfaceCreateInfoKHR_getpNext(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDisplaySurfaceCreateInfoKHR_getplaneIndex(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->planeIndex);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDisplaySurfaceCreateInfoKHR_getplaneStackIndex(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->planeStackIndex);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDisplaySurfaceCreateInfoKHR_getglobalAlpha(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure){
            PyObject* value = PyFloat_FromDouble((double) (self->base)->globalAlpha);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDisplaySurfaceCreateInfoKHR_getsetters[] = {
                
                    { "pNext", (getter)PyVkDisplaySurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
                
                    { "planeIndex", (getter)PyVkDisplaySurfaceCreateInfoKHR_getplaneIndex, NULL, "", NULL},
                
                    { "planeStackIndex", (getter)PyVkDisplaySurfaceCreateInfoKHR_getplaneStackIndex, NULL, "", NULL},
                
                    { "globalAlpha", (getter)PyVkDisplaySurfaceCreateInfoKHR_getglobalAlpha, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDisplaySurfaceCreateInfoKHR_init(PyVkDisplaySurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* displayMode = NULL;
PyObject* planeIndex = NULL;
PyObject* planeStackIndex = NULL;
PyObject* transform = NULL;
PyObject* globalAlpha = NULL;
PyObject* alphaMode = NULL;
PyObject* imageExtent = NULL;
static char *kwlist[] = {"sType","pNext","flags","displayMode","planeIndex","planeStackIndex","transform","globalAlpha","alphaMode","imageExtent",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOOO", kwlist, &sType, &pNext, &flags, &displayMode, &planeIndex, &planeStackIndex, &transform, &globalAlpha, &alphaMode, &imageExtent)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (displayMode != NULL && displayMode != Py_None) {
                
                (self->base)->displayMode = PyCapsule_GetPointer(displayMode, "VkDisplayModeKHR");
            
 } 

                if (planeIndex != NULL && planeIndex != Py_None) {
                (self->base)->planeIndex = (uint32_t) PyLong_AsLong(planeIndex);
 } 

                if (planeStackIndex != NULL && planeStackIndex != Py_None) {
                (self->base)->planeStackIndex = (uint32_t) PyLong_AsLong(planeStackIndex);
 } 

                if (transform != NULL && transform != Py_None) {
                
                    (self->base)->transform = PyLong_AsLong(transform);
                
 } 

                if (globalAlpha != NULL && globalAlpha != Py_None) {
                (self->base)->globalAlpha = (float) PyFloat_AsDouble(globalAlpha);
 } 

                if (alphaMode != NULL && alphaMode != Py_None) {
                
                    (self->base)->alphaMode = PyLong_AsLong(alphaMode);
                
 } 

                if (imageExtent != NULL && imageExtent != Py_None) {
                
                    (self->base)->imageExtent = *(((PyVkExtent2D*)imageExtent)->base);
                
 } 

return 0; }
            static PyTypeObject PyVkDisplaySurfaceCreateInfoKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplaySurfaceCreateInfoKHR", sizeof(PyVkDisplaySurfaceCreateInfoKHR), 0,
                (destructor)PyVkDisplaySurfaceCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplaySurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplaySurfaceCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplaySurfaceCreateInfoKHR_init,0,PyVkDisplaySurfaceCreateInfoKHR_new,};
        
            static void PyVkDisplayPresentInfoKHR_del(PyVkDisplayPresentInfoKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDisplayPresentInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDisplayPresentInfoKHR *self;
                self = (PyVkDisplayPresentInfoKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDisplayPresentInfoKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplayPresentInfoKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDisplayPresentInfoKHR_getpNext(PyVkDisplayPresentInfoKHR *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDisplayPresentInfoKHR_getsetters[] = {
                
                    { "pNext", (getter)PyVkDisplayPresentInfoKHR_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDisplayPresentInfoKHR_init(PyVkDisplayPresentInfoKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* srcRect = NULL;
PyObject* dstRect = NULL;
PyObject* persistent = NULL;
static char *kwlist[] = {"sType","pNext","srcRect","dstRect","persistent",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &srcRect, &dstRect, &persistent)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (srcRect != NULL && srcRect != Py_None) {
                
                    (self->base)->srcRect = *(((PyVkRect2D*)srcRect)->base);
                
 } 

                if (dstRect != NULL && dstRect != Py_None) {
                
                    (self->base)->dstRect = *(((PyVkRect2D*)dstRect)->base);
                
 } 

                if (persistent != NULL && persistent != Py_None) {
                
                    (self->base)->persistent = PyLong_AsLong(persistent);
                
 } 

return 0; }
            static PyTypeObject PyVkDisplayPresentInfoKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplayPresentInfoKHR", sizeof(PyVkDisplayPresentInfoKHR), 0,
                (destructor)PyVkDisplayPresentInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplayPresentInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplayPresentInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplayPresentInfoKHR_init,0,PyVkDisplayPresentInfoKHR_new,};
        
            static void PyVkSurfaceCapabilitiesKHR_del(PyVkSurfaceCapabilitiesKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSurfaceCapabilitiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSurfaceCapabilitiesKHR *self;
                self = (PyVkSurfaceCapabilitiesKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSurfaceCapabilitiesKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSurfaceCapabilitiesKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkSurfaceCapabilitiesKHR_getminImageCount(PyVkSurfaceCapabilitiesKHR *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->minImageCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSurfaceCapabilitiesKHR_getmaxImageCount(PyVkSurfaceCapabilitiesKHR *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxImageCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSurfaceCapabilitiesKHR_getmaxImageArrayLayers(PyVkSurfaceCapabilitiesKHR *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->maxImageArrayLayers);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkSurfaceCapabilitiesKHR_getsetters[] = {
                
                    { "minImageCount", (getter)PyVkSurfaceCapabilitiesKHR_getminImageCount, NULL, "", NULL},
                
                    { "maxImageCount", (getter)PyVkSurfaceCapabilitiesKHR_getmaxImageCount, NULL, "", NULL},
                
                    { "maxImageArrayLayers", (getter)PyVkSurfaceCapabilitiesKHR_getmaxImageArrayLayers, NULL, "", NULL},
                {NULL}};

            static int
            PyVkSurfaceCapabilitiesKHR_init(PyVkSurfaceCapabilitiesKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* minImageCount = NULL;
PyObject* maxImageCount = NULL;
PyObject* currentExtent = NULL;
PyObject* minImageExtent = NULL;
PyObject* maxImageExtent = NULL;
PyObject* maxImageArrayLayers = NULL;
PyObject* supportedTransforms = NULL;
PyObject* currentTransform = NULL;
PyObject* supportedCompositeAlpha = NULL;
PyObject* supportedUsageFlags = NULL;
static char *kwlist[] = {"minImageCount","maxImageCount","currentExtent","minImageExtent","maxImageExtent","maxImageArrayLayers","supportedTransforms","currentTransform","supportedCompositeAlpha","supportedUsageFlags",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOOO", kwlist, &minImageCount, &maxImageCount, &currentExtent, &minImageExtent, &maxImageExtent, &maxImageArrayLayers, &supportedTransforms, &currentTransform, &supportedCompositeAlpha, &supportedUsageFlags)) return -1;

                if (minImageCount != NULL && minImageCount != Py_None) {
                (self->base)->minImageCount = (uint32_t) PyLong_AsLong(minImageCount);
 } 

                if (maxImageCount != NULL && maxImageCount != Py_None) {
                (self->base)->maxImageCount = (uint32_t) PyLong_AsLong(maxImageCount);
 } 

                if (currentExtent != NULL && currentExtent != Py_None) {
                
                    (self->base)->currentExtent = *(((PyVkExtent2D*)currentExtent)->base);
                
 } 

                if (minImageExtent != NULL && minImageExtent != Py_None) {
                
                    (self->base)->minImageExtent = *(((PyVkExtent2D*)minImageExtent)->base);
                
 } 

                if (maxImageExtent != NULL && maxImageExtent != Py_None) {
                
                    (self->base)->maxImageExtent = *(((PyVkExtent2D*)maxImageExtent)->base);
                
 } 

                if (maxImageArrayLayers != NULL && maxImageArrayLayers != Py_None) {
                (self->base)->maxImageArrayLayers = (uint32_t) PyLong_AsLong(maxImageArrayLayers);
 } 

                if (supportedTransforms != NULL && supportedTransforms != Py_None) {
                
                    (self->base)->supportedTransforms = PyLong_AsLong(supportedTransforms);
                
 } 

                if (currentTransform != NULL && currentTransform != Py_None) {
                
                    (self->base)->currentTransform = PyLong_AsLong(currentTransform);
                
 } 

                if (supportedCompositeAlpha != NULL && supportedCompositeAlpha != Py_None) {
                
                    (self->base)->supportedCompositeAlpha = PyLong_AsLong(supportedCompositeAlpha);
                
 } 

                if (supportedUsageFlags != NULL && supportedUsageFlags != Py_None) {
                
                    (self->base)->supportedUsageFlags = PyLong_AsLong(supportedUsageFlags);
                
 } 

return 0; }
            static PyTypeObject PyVkSurfaceCapabilitiesKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSurfaceCapabilitiesKHR", sizeof(PyVkSurfaceCapabilitiesKHR), 0,
                (destructor)PyVkSurfaceCapabilitiesKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSurfaceCapabilitiesKHR object",0,0,0,0,0,0,0,0,
                PyVkSurfaceCapabilitiesKHR_getsetters,0,0,0,0,0,(initproc)PyVkSurfaceCapabilitiesKHR_init,0,PyVkSurfaceCapabilitiesKHR_new,};
        
#ifdef VK_USE_PLATFORM_ANDROID_KHR

            static void PyVkAndroidSurfaceCreateInfoKHR_del(PyVkAndroidSurfaceCreateInfoKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkAndroidSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkAndroidSurfaceCreateInfoKHR *self;
                self = (PyVkAndroidSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkAndroidSurfaceCreateInfoKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkAndroidSurfaceCreateInfoKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkAndroidSurfaceCreateInfoKHR_getpNext(PyVkAndroidSurfaceCreateInfoKHR *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkAndroidSurfaceCreateInfoKHR_getsetters[] = {
                
                    { "pNext", (getter)PyVkAndroidSurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkAndroidSurfaceCreateInfoKHR_init(PyVkAndroidSurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* window = NULL;
static char *kwlist[] = {"sType","pNext","flags","window",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &sType, &pNext, &flags, &window)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

return 0; }
            static PyTypeObject PyVkAndroidSurfaceCreateInfoKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkAndroidSurfaceCreateInfoKHR", sizeof(PyVkAndroidSurfaceCreateInfoKHR), 0,
                (destructor)PyVkAndroidSurfaceCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkAndroidSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkAndroidSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkAndroidSurfaceCreateInfoKHR_init,0,PyVkAndroidSurfaceCreateInfoKHR_new,};
        
#endif

#ifdef VK_USE_PLATFORM_MIR_KHR

            static void PyVkMirSurfaceCreateInfoKHR_del(PyVkMirSurfaceCreateInfoKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkMirSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkMirSurfaceCreateInfoKHR *self;
                self = (PyVkMirSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkMirSurfaceCreateInfoKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkMirSurfaceCreateInfoKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkMirSurfaceCreateInfoKHR_getpNext(PyVkMirSurfaceCreateInfoKHR *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkMirSurfaceCreateInfoKHR_getsetters[] = {
                
                    { "pNext", (getter)PyVkMirSurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkMirSurfaceCreateInfoKHR_init(PyVkMirSurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* connection = NULL;
PyObject* mirSurface = NULL;
static char *kwlist[] = {"sType","pNext","flags","connection","mirSurface",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &flags, &connection, &mirSurface)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

return 0; }
            static PyTypeObject PyVkMirSurfaceCreateInfoKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkMirSurfaceCreateInfoKHR", sizeof(PyVkMirSurfaceCreateInfoKHR), 0,
                (destructor)PyVkMirSurfaceCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkMirSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkMirSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkMirSurfaceCreateInfoKHR_init,0,PyVkMirSurfaceCreateInfoKHR_new,};
        
#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

            static void PyVkWaylandSurfaceCreateInfoKHR_del(PyVkWaylandSurfaceCreateInfoKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkWaylandSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkWaylandSurfaceCreateInfoKHR *self;
                self = (PyVkWaylandSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkWaylandSurfaceCreateInfoKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkWaylandSurfaceCreateInfoKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkWaylandSurfaceCreateInfoKHR_getpNext(PyVkWaylandSurfaceCreateInfoKHR *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkWaylandSurfaceCreateInfoKHR_getsetters[] = {
                
                    { "pNext", (getter)PyVkWaylandSurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkWaylandSurfaceCreateInfoKHR_init(PyVkWaylandSurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* display = NULL;
PyObject* surface = NULL;
static char *kwlist[] = {"sType","pNext","flags","display","surface",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &flags, &display, &surface)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

return 0; }
            static PyTypeObject PyVkWaylandSurfaceCreateInfoKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkWaylandSurfaceCreateInfoKHR", sizeof(PyVkWaylandSurfaceCreateInfoKHR), 0,
                (destructor)PyVkWaylandSurfaceCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkWaylandSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkWaylandSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkWaylandSurfaceCreateInfoKHR_init,0,PyVkWaylandSurfaceCreateInfoKHR_new,};
        
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

            static void PyVkWin32SurfaceCreateInfoKHR_del(PyVkWin32SurfaceCreateInfoKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkWin32SurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkWin32SurfaceCreateInfoKHR *self;
                self = (PyVkWin32SurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkWin32SurfaceCreateInfoKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkWin32SurfaceCreateInfoKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkWin32SurfaceCreateInfoKHR_getpNext(PyVkWin32SurfaceCreateInfoKHR *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkWin32SurfaceCreateInfoKHR_getsetters[] = {
                
                    { "pNext", (getter)PyVkWin32SurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkWin32SurfaceCreateInfoKHR_init(PyVkWin32SurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* hinstance = NULL;
PyObject* hwnd = NULL;
static char *kwlist[] = {"sType","pNext","flags","hinstance","hwnd",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &flags, &hinstance, &hwnd)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

return 0; }
            static PyTypeObject PyVkWin32SurfaceCreateInfoKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkWin32SurfaceCreateInfoKHR", sizeof(PyVkWin32SurfaceCreateInfoKHR), 0,
                (destructor)PyVkWin32SurfaceCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkWin32SurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkWin32SurfaceCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkWin32SurfaceCreateInfoKHR_init,0,PyVkWin32SurfaceCreateInfoKHR_new,};
        
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR

            static void PyVkXlibSurfaceCreateInfoKHR_del(PyVkXlibSurfaceCreateInfoKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkXlibSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkXlibSurfaceCreateInfoKHR *self;
                self = (PyVkXlibSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkXlibSurfaceCreateInfoKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkXlibSurfaceCreateInfoKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkXlibSurfaceCreateInfoKHR_getpNext(PyVkXlibSurfaceCreateInfoKHR *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkXlibSurfaceCreateInfoKHR_getdpy(PyVkXlibSurfaceCreateInfoKHR *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkXlibSurfaceCreateInfoKHR_getwindow(PyVkXlibSurfaceCreateInfoKHR *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->window);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkXlibSurfaceCreateInfoKHR_getsetters[] = {
                
                    { "pNext", (getter)PyVkXlibSurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
                
                    { "dpy", (getter)PyVkXlibSurfaceCreateInfoKHR_getdpy, NULL, "", NULL},
                
                    { "window", (getter)PyVkXlibSurfaceCreateInfoKHR_getwindow, NULL, "", NULL},
                {NULL}};

            static int
            PyVkXlibSurfaceCreateInfoKHR_init(PyVkXlibSurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* dpy = NULL;
PyObject* window = NULL;
static char *kwlist[] = {"sType","pNext","flags","dpy","window",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &flags, &dpy, &window)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (dpy != NULL && dpy != Py_None) {
                (self->base)->dpy = (Display *) PyLong_AsLong(dpy);
 } 

                if (window != NULL && window != Py_None) {
                (self->base)->window = (XID) PyLong_AsLong(window);
 } 

return 0; }
            static PyTypeObject PyVkXlibSurfaceCreateInfoKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkXlibSurfaceCreateInfoKHR", sizeof(PyVkXlibSurfaceCreateInfoKHR), 0,
                (destructor)PyVkXlibSurfaceCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkXlibSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkXlibSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkXlibSurfaceCreateInfoKHR_init,0,PyVkXlibSurfaceCreateInfoKHR_new,};
        
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

            static void PyVkXcbSurfaceCreateInfoKHR_del(PyVkXcbSurfaceCreateInfoKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkXcbSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkXcbSurfaceCreateInfoKHR *self;
                self = (PyVkXcbSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkXcbSurfaceCreateInfoKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkXcbSurfaceCreateInfoKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkXcbSurfaceCreateInfoKHR_getpNext(PyVkXcbSurfaceCreateInfoKHR *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkXcbSurfaceCreateInfoKHR_getsetters[] = {
                
                    { "pNext", (getter)PyVkXcbSurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkXcbSurfaceCreateInfoKHR_init(PyVkXcbSurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* connection = NULL;
PyObject* window = NULL;
static char *kwlist[] = {"sType","pNext","flags","connection","window",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &flags, &connection, &window)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

return 0; }
            static PyTypeObject PyVkXcbSurfaceCreateInfoKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkXcbSurfaceCreateInfoKHR", sizeof(PyVkXcbSurfaceCreateInfoKHR), 0,
                (destructor)PyVkXcbSurfaceCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkXcbSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkXcbSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkXcbSurfaceCreateInfoKHR_init,0,PyVkXcbSurfaceCreateInfoKHR_new,};
        
#endif

            static void PyVkSurfaceFormatKHR_del(PyVkSurfaceFormatKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSurfaceFormatKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSurfaceFormatKHR *self;
                self = (PyVkSurfaceFormatKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSurfaceFormatKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSurfaceFormatKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkSurfaceFormatKHR_getsetters[] = {
                {NULL}};

            static int
            PyVkSurfaceFormatKHR_init(PyVkSurfaceFormatKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* format = NULL;
PyObject* colorSpace = NULL;
static char *kwlist[] = {"format","colorSpace",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OO", kwlist, &format, &colorSpace)) return -1;

                if (format != NULL && format != Py_None) {
                
                    (self->base)->format = PyLong_AsLong(format);
                
 } 

                if (colorSpace != NULL && colorSpace != Py_None) {
                
                    (self->base)->colorSpace = PyLong_AsLong(colorSpace);
                
 } 

return 0; }
            static PyTypeObject PyVkSurfaceFormatKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSurfaceFormatKHR", sizeof(PyVkSurfaceFormatKHR), 0,
                (destructor)PyVkSurfaceFormatKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSurfaceFormatKHR object",0,0,0,0,0,0,0,0,
                PyVkSurfaceFormatKHR_getsetters,0,0,0,0,0,(initproc)PyVkSurfaceFormatKHR_init,0,PyVkSurfaceFormatKHR_new,};
        
            static void PyVkSwapchainCreateInfoKHR_del(PyVkSwapchainCreateInfoKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkSwapchainCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkSwapchainCreateInfoKHR *self;
                self = (PyVkSwapchainCreateInfoKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkSwapchainCreateInfoKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSwapchainCreateInfoKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkSwapchainCreateInfoKHR_getpNext(PyVkSwapchainCreateInfoKHR *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSwapchainCreateInfoKHR_getminImageCount(PyVkSwapchainCreateInfoKHR *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->minImageCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSwapchainCreateInfoKHR_getimageArrayLayers(PyVkSwapchainCreateInfoKHR *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->imageArrayLayers);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSwapchainCreateInfoKHR_getqueueFamilyIndexCount(PyVkSwapchainCreateInfoKHR *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->queueFamilyIndexCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkSwapchainCreateInfoKHR_getpQueueFamilyIndices(PyVkSwapchainCreateInfoKHR *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (*((self->base)->pQueueFamilyIndices)));
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkSwapchainCreateInfoKHR_getsetters[] = {
                
                    { "pNext", (getter)PyVkSwapchainCreateInfoKHR_getpNext, NULL, "", NULL},
                
                    { "minImageCount", (getter)PyVkSwapchainCreateInfoKHR_getminImageCount, NULL, "", NULL},
                
                    { "imageArrayLayers", (getter)PyVkSwapchainCreateInfoKHR_getimageArrayLayers, NULL, "", NULL},
                
                    { "queueFamilyIndexCount", (getter)PyVkSwapchainCreateInfoKHR_getqueueFamilyIndexCount, NULL, "", NULL},
                
                    { "pQueueFamilyIndices", (getter)PyVkSwapchainCreateInfoKHR_getpQueueFamilyIndices, NULL, "", NULL},
                {NULL}};

            static int
            PyVkSwapchainCreateInfoKHR_init(PyVkSwapchainCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* surface = NULL;
PyObject* minImageCount = NULL;
PyObject* imageFormat = NULL;
PyObject* imageColorSpace = NULL;
PyObject* imageExtent = NULL;
PyObject* imageArrayLayers = NULL;
PyObject* imageUsage = NULL;
PyObject* imageSharingMode = NULL;
PyObject* queueFamilyIndexCount = NULL;
PyObject* pQueueFamilyIndices = NULL;
PyObject* preTransform = NULL;
PyObject* compositeAlpha = NULL;
PyObject* presentMode = NULL;
PyObject* clipped = NULL;
PyObject* oldSwapchain = NULL;
static char *kwlist[] = {"sType","pNext","flags","surface","minImageCount","imageFormat","imageColorSpace","imageExtent","imageArrayLayers","imageUsage","imageSharingMode","queueFamilyIndexCount","pQueueFamilyIndices","preTransform","compositeAlpha","presentMode","clipped","oldSwapchain",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOOOOOOOOOOO", kwlist, &sType, &pNext, &flags, &surface, &minImageCount, &imageFormat, &imageColorSpace, &imageExtent, &imageArrayLayers, &imageUsage, &imageSharingMode, &queueFamilyIndexCount, &pQueueFamilyIndices, &preTransform, &compositeAlpha, &presentMode, &clipped, &oldSwapchain)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (surface != NULL && surface != Py_None) {
                
                (self->base)->surface = PyCapsule_GetPointer(surface, "VkSurfaceKHR");
            
 } 

                if (minImageCount != NULL && minImageCount != Py_None) {
                (self->base)->minImageCount = (uint32_t) PyLong_AsLong(minImageCount);
 } 

                if (imageFormat != NULL && imageFormat != Py_None) {
                
                    (self->base)->imageFormat = PyLong_AsLong(imageFormat);
                
 } 

                if (imageColorSpace != NULL && imageColorSpace != Py_None) {
                
                    (self->base)->imageColorSpace = PyLong_AsLong(imageColorSpace);
                
 } 

                if (imageExtent != NULL && imageExtent != Py_None) {
                
                    (self->base)->imageExtent = *(((PyVkExtent2D*)imageExtent)->base);
                
 } 

                if (imageArrayLayers != NULL && imageArrayLayers != Py_None) {
                (self->base)->imageArrayLayers = (uint32_t) PyLong_AsLong(imageArrayLayers);
 } 

                if (imageUsage != NULL && imageUsage != Py_None) {
                
                    (self->base)->imageUsage = PyLong_AsLong(imageUsage);
                
 } 

                if (imageSharingMode != NULL && imageSharingMode != Py_None) {
                
                    (self->base)->imageSharingMode = PyLong_AsLong(imageSharingMode);
                
 } 

                if (queueFamilyIndexCount != NULL && queueFamilyIndexCount != Py_None) {
                (self->base)->queueFamilyIndexCount = (uint32_t) PyLong_AsLong(queueFamilyIndexCount);
 } 

                if (pQueueFamilyIndices != NULL && pQueueFamilyIndices != Py_None) {
                
        uint32_t tmp16179722 = (uint32_t) PyLong_AsLong(pQueueFamilyIndices);
        uint32_t *tmp71496264 = malloc(sizeof(uint32_t));
        memcpy(tmp71496264, &tmp16179722, sizeof(uint32_t));
        (self->base)->pQueueFamilyIndices = tmp71496264;
        
 } 

                if (preTransform != NULL && preTransform != Py_None) {
                
                    (self->base)->preTransform = PyLong_AsLong(preTransform);
                
 } 

                if (compositeAlpha != NULL && compositeAlpha != Py_None) {
                
                    (self->base)->compositeAlpha = PyLong_AsLong(compositeAlpha);
                
 } 

                if (presentMode != NULL && presentMode != Py_None) {
                
                    (self->base)->presentMode = PyLong_AsLong(presentMode);
                
 } 

                if (clipped != NULL && clipped != Py_None) {
                
                    (self->base)->clipped = PyLong_AsLong(clipped);
                
 } 

                if (oldSwapchain != NULL && oldSwapchain != Py_None) {
                
                (self->base)->oldSwapchain = PyCapsule_GetPointer(oldSwapchain, "VkSwapchainKHR");
            
 } 

return 0; }
            static PyTypeObject PyVkSwapchainCreateInfoKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSwapchainCreateInfoKHR", sizeof(PyVkSwapchainCreateInfoKHR), 0,
                (destructor)PyVkSwapchainCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSwapchainCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkSwapchainCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkSwapchainCreateInfoKHR_init,0,PyVkSwapchainCreateInfoKHR_new,};
        
            static void PyVkPresentInfoKHR_del(PyVkPresentInfoKHR* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPresentInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPresentInfoKHR *self;
                self = (PyVkPresentInfoKHR *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPresentInfoKHR));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPresentInfoKHR");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPresentInfoKHR_getpNext(PyVkPresentInfoKHR *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPresentInfoKHR_getwaitSemaphoreCount(PyVkPresentInfoKHR *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->waitSemaphoreCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPresentInfoKHR_getswapchainCount(PyVkPresentInfoKHR *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->swapchainCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkPresentInfoKHR_getpImageIndices(PyVkPresentInfoKHR *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (*((self->base)->pImageIndices)));
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPresentInfoKHR_getsetters[] = {
                
                    { "pNext", (getter)PyVkPresentInfoKHR_getpNext, NULL, "", NULL},
                
                    { "waitSemaphoreCount", (getter)PyVkPresentInfoKHR_getwaitSemaphoreCount, NULL, "", NULL},
                
                    { "swapchainCount", (getter)PyVkPresentInfoKHR_getswapchainCount, NULL, "", NULL},
                
                    { "pImageIndices", (getter)PyVkPresentInfoKHR_getpImageIndices, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPresentInfoKHR_init(PyVkPresentInfoKHR *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* waitSemaphoreCount = NULL;
PyObject* pWaitSemaphores = NULL;
PyObject* swapchainCount = NULL;
PyObject* pSwapchains = NULL;
PyObject* pImageIndices = NULL;
PyObject* pResults = NULL;
static char *kwlist[] = {"sType","pNext","waitSemaphoreCount","pWaitSemaphores","swapchainCount","pSwapchains","pImageIndices","pResults",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOO", kwlist, &sType, &pNext, &waitSemaphoreCount, &pWaitSemaphores, &swapchainCount, &pSwapchains, &pImageIndices, &pResults)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (waitSemaphoreCount != NULL && waitSemaphoreCount != Py_None) {
                (self->base)->waitSemaphoreCount = (uint32_t) PyLong_AsLong(waitSemaphoreCount);
 } 

                if (pWaitSemaphores != NULL && pWaitSemaphores != Py_None) {
                
                (self->base)->pWaitSemaphores = PyCapsule_GetPointer(pWaitSemaphores, "VkSemaphore");
            
 } 

                if (swapchainCount != NULL && swapchainCount != Py_None) {
                (self->base)->swapchainCount = (uint32_t) PyLong_AsLong(swapchainCount);
 } 

                if (pSwapchains != NULL && pSwapchains != Py_None) {
                
                (self->base)->pSwapchains = PyCapsule_GetPointer(pSwapchains, "VkSwapchainKHR");
            
 } 

                if (pImageIndices != NULL && pImageIndices != Py_None) {
                
        uint32_t tmp92912676 = (uint32_t) PyLong_AsLong(pImageIndices);
        uint32_t *tmp44056472 = malloc(sizeof(uint32_t));
        memcpy(tmp44056472, &tmp92912676, sizeof(uint32_t));
        (self->base)->pImageIndices = tmp44056472;
        
 } 

                if (pResults != NULL && pResults != Py_None) {
                
                    VkResult tmp = PyLong_AsLong(pResults);
                    (self->base)->pResults = &tmp;
                
 } 

return 0; }
            static PyTypeObject PyVkPresentInfoKHRType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPresentInfoKHR", sizeof(PyVkPresentInfoKHR), 0,
                (destructor)PyVkPresentInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPresentInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkPresentInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkPresentInfoKHR_init,0,PyVkPresentInfoKHR_new,};
        
            static void PyVkDebugReportCallbackCreateInfoEXT_del(PyVkDebugReportCallbackCreateInfoEXT* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDebugReportCallbackCreateInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDebugReportCallbackCreateInfoEXT *self;
                self = (PyVkDebugReportCallbackCreateInfoEXT *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDebugReportCallbackCreateInfoEXT));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDebugReportCallbackCreateInfoEXT");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDebugReportCallbackCreateInfoEXT_getpNext(PyVkDebugReportCallbackCreateInfoEXT *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDebugReportCallbackCreateInfoEXT_getpUserData(PyVkDebugReportCallbackCreateInfoEXT *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDebugReportCallbackCreateInfoEXT_getsetters[] = {
                
                    { "pNext", (getter)PyVkDebugReportCallbackCreateInfoEXT_getpNext, NULL, "", NULL},
                
                    { "pUserData", (getter)PyVkDebugReportCallbackCreateInfoEXT_getpUserData, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDebugReportCallbackCreateInfoEXT_init(PyVkDebugReportCallbackCreateInfoEXT *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* flags = NULL;
PyObject* pfnCallback = NULL;
PyObject* pUserData = NULL;
static char *kwlist[] = {"sType","pNext","flags","pfnCallback","pUserData",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &flags, &pfnCallback, &pUserData)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (flags != NULL && flags != Py_None) {
                
                    (self->base)->flags = PyLong_AsLong(flags);
                
 } 

                if (pUserData != NULL && pUserData != Py_None) {
                (self->base)->pUserData = NULL;
 } 

return 0; }
            static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDebugReportCallbackCreateInfoEXT", sizeof(PyVkDebugReportCallbackCreateInfoEXT), 0,
                (destructor)PyVkDebugReportCallbackCreateInfoEXT_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDebugReportCallbackCreateInfoEXT object",0,0,0,0,0,0,0,0,
                PyVkDebugReportCallbackCreateInfoEXT_getsetters,0,0,0,0,0,(initproc)PyVkDebugReportCallbackCreateInfoEXT_init,0,PyVkDebugReportCallbackCreateInfoEXT_new,};
        
            static void PyVkDebugReportLayerFlagsEXT_del(PyVkDebugReportLayerFlagsEXT* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDebugReportLayerFlagsEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDebugReportLayerFlagsEXT *self;
                self = (PyVkDebugReportLayerFlagsEXT *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDebugReportLayerFlagsEXT));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDebugReportLayerFlagsEXT");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDebugReportLayerFlagsEXT_getpNext(PyVkDebugReportLayerFlagsEXT *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDebugReportLayerFlagsEXT_getenabledValidationFlags(PyVkDebugReportLayerFlagsEXT *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->enabledValidationFlags);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDebugReportLayerFlagsEXT_getsetters[] = {
                
                    { "pNext", (getter)PyVkDebugReportLayerFlagsEXT_getpNext, NULL, "", NULL},
                
                    { "enabledValidationFlags", (getter)PyVkDebugReportLayerFlagsEXT_getenabledValidationFlags, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDebugReportLayerFlagsEXT_init(PyVkDebugReportLayerFlagsEXT *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* enabledValidationFlags = NULL;
static char *kwlist[] = {"sType","pNext","enabledValidationFlags",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &sType, &pNext, &enabledValidationFlags)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (enabledValidationFlags != NULL && enabledValidationFlags != Py_None) {
                (self->base)->enabledValidationFlags = (uint64_t) PyLong_AsLong(enabledValidationFlags);
 } 

return 0; }
            static PyTypeObject PyVkDebugReportLayerFlagsEXTType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDebugReportLayerFlagsEXT", sizeof(PyVkDebugReportLayerFlagsEXT), 0,
                (destructor)PyVkDebugReportLayerFlagsEXT_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDebugReportLayerFlagsEXT object",0,0,0,0,0,0,0,0,
                PyVkDebugReportLayerFlagsEXT_getsetters,0,0,0,0,0,(initproc)PyVkDebugReportLayerFlagsEXT_init,0,PyVkDebugReportLayerFlagsEXT_new,};
        
            static void PyVkPipelineRasterizationStateRasterizationOrderAMD_del(PyVkPipelineRasterizationStateRasterizationOrderAMD* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkPipelineRasterizationStateRasterizationOrderAMD_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkPipelineRasterizationStateRasterizationOrderAMD *self;
                self = (PyVkPipelineRasterizationStateRasterizationOrderAMD *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkPipelineRasterizationStateRasterizationOrderAMD));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineRasterizationStateRasterizationOrderAMD");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkPipelineRasterizationStateRasterizationOrderAMD_getpNext(PyVkPipelineRasterizationStateRasterizationOrderAMD *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkPipelineRasterizationStateRasterizationOrderAMD_getsetters[] = {
                
                    { "pNext", (getter)PyVkPipelineRasterizationStateRasterizationOrderAMD_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkPipelineRasterizationStateRasterizationOrderAMD_init(PyVkPipelineRasterizationStateRasterizationOrderAMD *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* rasterizationOrder = NULL;
static char *kwlist[] = {"sType","pNext","rasterizationOrder",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &sType, &pNext, &rasterizationOrder)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (rasterizationOrder != NULL && rasterizationOrder != Py_None) {
                
                    (self->base)->rasterizationOrder = PyLong_AsLong(rasterizationOrder);
                
 } 

return 0; }
            static PyTypeObject PyVkPipelineRasterizationStateRasterizationOrderAMDType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineRasterizationStateRasterizationOrderAMD", sizeof(PyVkPipelineRasterizationStateRasterizationOrderAMD), 0,
                (destructor)PyVkPipelineRasterizationStateRasterizationOrderAMD_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineRasterizationStateRasterizationOrderAMD object",0,0,0,0,0,0,0,0,
                PyVkPipelineRasterizationStateRasterizationOrderAMD_getsetters,0,0,0,0,0,(initproc)PyVkPipelineRasterizationStateRasterizationOrderAMD_init,0,PyVkPipelineRasterizationStateRasterizationOrderAMD_new,};
        
            static void PyVkDebugMarkerObjectNameInfoEXT_del(PyVkDebugMarkerObjectNameInfoEXT* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDebugMarkerObjectNameInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDebugMarkerObjectNameInfoEXT *self;
                self = (PyVkDebugMarkerObjectNameInfoEXT *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDebugMarkerObjectNameInfoEXT));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDebugMarkerObjectNameInfoEXT");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDebugMarkerObjectNameInfoEXT_getpNext(PyVkDebugMarkerObjectNameInfoEXT *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDebugMarkerObjectNameInfoEXT_getobject(PyVkDebugMarkerObjectNameInfoEXT *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->object);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDebugMarkerObjectNameInfoEXT_getpObjectName(PyVkDebugMarkerObjectNameInfoEXT *self, void *closure){
            PyObject* value = PyUnicode_FromString((const char *) (self->base)->pObjectName);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDebugMarkerObjectNameInfoEXT_getsetters[] = {
                
                    { "pNext", (getter)PyVkDebugMarkerObjectNameInfoEXT_getpNext, NULL, "", NULL},
                
                    { "object", (getter)PyVkDebugMarkerObjectNameInfoEXT_getobject, NULL, "", NULL},
                
                    { "pObjectName", (getter)PyVkDebugMarkerObjectNameInfoEXT_getpObjectName, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDebugMarkerObjectNameInfoEXT_init(PyVkDebugMarkerObjectNameInfoEXT *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* objectType = NULL;
PyObject* object = NULL;
PyObject* pObjectName = NULL;
static char *kwlist[] = {"sType","pNext","objectType","object","pObjectName",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOO", kwlist, &sType, &pNext, &objectType, &object, &pObjectName)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (objectType != NULL && objectType != Py_None) {
                
                    (self->base)->objectType = PyLong_AsLong(objectType);
                
 } 

                if (object != NULL && object != Py_None) {
                (self->base)->object = (uint64_t) PyLong_AsLong(object);
 } 

                if (pObjectName != NULL && pObjectName != Py_None) {
                
        PyObject * tmp76008906 = PyUnicode_AsASCIIString(pObjectName);
        char* tmp38256156 = PyBytes_AsString(tmp76008906);
        strcpy((self->base)->pObjectName, tmp38256156);
        Py_DECREF(tmp76008906);
        
 } 

return 0; }
            static PyTypeObject PyVkDebugMarkerObjectNameInfoEXTType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDebugMarkerObjectNameInfoEXT", sizeof(PyVkDebugMarkerObjectNameInfoEXT), 0,
                (destructor)PyVkDebugMarkerObjectNameInfoEXT_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDebugMarkerObjectNameInfoEXT object",0,0,0,0,0,0,0,0,
                PyVkDebugMarkerObjectNameInfoEXT_getsetters,0,0,0,0,0,(initproc)PyVkDebugMarkerObjectNameInfoEXT_init,0,PyVkDebugMarkerObjectNameInfoEXT_new,};
        
            static void PyVkDebugMarkerObjectTagInfoEXT_del(PyVkDebugMarkerObjectTagInfoEXT* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDebugMarkerObjectTagInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDebugMarkerObjectTagInfoEXT *self;
                self = (PyVkDebugMarkerObjectTagInfoEXT *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDebugMarkerObjectTagInfoEXT));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDebugMarkerObjectTagInfoEXT");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDebugMarkerObjectTagInfoEXT_getpNext(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDebugMarkerObjectTagInfoEXT_getobject(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->object);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDebugMarkerObjectTagInfoEXT_gettagName(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->tagName);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDebugMarkerObjectTagInfoEXT_gettagSize(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->tagSize);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDebugMarkerObjectTagInfoEXT_getpTag(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDebugMarkerObjectTagInfoEXT_getsetters[] = {
                
                    { "pNext", (getter)PyVkDebugMarkerObjectTagInfoEXT_getpNext, NULL, "", NULL},
                
                    { "object", (getter)PyVkDebugMarkerObjectTagInfoEXT_getobject, NULL, "", NULL},
                
                    { "tagName", (getter)PyVkDebugMarkerObjectTagInfoEXT_gettagName, NULL, "", NULL},
                
                    { "tagSize", (getter)PyVkDebugMarkerObjectTagInfoEXT_gettagSize, NULL, "", NULL},
                
                    { "pTag", (getter)PyVkDebugMarkerObjectTagInfoEXT_getpTag, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDebugMarkerObjectTagInfoEXT_init(PyVkDebugMarkerObjectTagInfoEXT *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* objectType = NULL;
PyObject* object = NULL;
PyObject* tagName = NULL;
PyObject* tagSize = NULL;
PyObject* pTag = NULL;
static char *kwlist[] = {"sType","pNext","objectType","object","tagName","tagSize","pTag",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOO", kwlist, &sType, &pNext, &objectType, &object, &tagName, &tagSize, &pTag)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (objectType != NULL && objectType != Py_None) {
                
                    (self->base)->objectType = PyLong_AsLong(objectType);
                
 } 

                if (object != NULL && object != Py_None) {
                (self->base)->object = (uint64_t) PyLong_AsLong(object);
 } 

                if (tagName != NULL && tagName != Py_None) {
                (self->base)->tagName = (uint64_t) PyLong_AsLong(tagName);
 } 

                if (tagSize != NULL && tagSize != Py_None) {
                (self->base)->tagSize = (size_t) PyLong_AsLong(tagSize);
 } 

                if (pTag != NULL && pTag != Py_None) {
                (self->base)->pTag = NULL;
 } 

return 0; }
            static PyTypeObject PyVkDebugMarkerObjectTagInfoEXTType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDebugMarkerObjectTagInfoEXT", sizeof(PyVkDebugMarkerObjectTagInfoEXT), 0,
                (destructor)PyVkDebugMarkerObjectTagInfoEXT_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDebugMarkerObjectTagInfoEXT object",0,0,0,0,0,0,0,0,
                PyVkDebugMarkerObjectTagInfoEXT_getsetters,0,0,0,0,0,(initproc)PyVkDebugMarkerObjectTagInfoEXT_init,0,PyVkDebugMarkerObjectTagInfoEXT_new,};
        
            static void PyVkDebugMarkerMarkerInfoEXT_del(PyVkDebugMarkerMarkerInfoEXT* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDebugMarkerMarkerInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDebugMarkerMarkerInfoEXT *self;
                self = (PyVkDebugMarkerMarkerInfoEXT *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDebugMarkerMarkerInfoEXT));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDebugMarkerMarkerInfoEXT");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDebugMarkerMarkerInfoEXT_getpNext(PyVkDebugMarkerMarkerInfoEXT *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDebugMarkerMarkerInfoEXT_getpMarkerName(PyVkDebugMarkerMarkerInfoEXT *self, void *closure){
            PyObject* value = PyUnicode_FromString((const char *) (self->base)->pMarkerName);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkDebugMarkerMarkerInfoEXT_getcolor(PyVkDebugMarkerMarkerInfoEXT *self, void *closure){
            
        PyObject* value = PyList_New(0);
        int nb = sizeof((self->base)->color) / sizeof((self->base)->color[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->color[i]);
            PyList_Append(value, py_tmp);
        }
        
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDebugMarkerMarkerInfoEXT_getsetters[] = {
                
                    { "pNext", (getter)PyVkDebugMarkerMarkerInfoEXT_getpNext, NULL, "", NULL},
                
                    { "pMarkerName", (getter)PyVkDebugMarkerMarkerInfoEXT_getpMarkerName, NULL, "", NULL},
                
                    { "color", (getter)PyVkDebugMarkerMarkerInfoEXT_getcolor, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDebugMarkerMarkerInfoEXT_init(PyVkDebugMarkerMarkerInfoEXT *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* pMarkerName = NULL;
PyObject* color = NULL;
static char *kwlist[] = {"sType","pNext","pMarkerName","color",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &sType, &pNext, &pMarkerName, &color)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (pMarkerName != NULL && pMarkerName != Py_None) {
                
        PyObject * tmp90750495 = PyUnicode_AsASCIIString(pMarkerName);
        char* tmp49232285 = PyBytes_AsString(tmp90750495);
        strcpy((self->base)->pMarkerName, tmp49232285);
        Py_DECREF(tmp90750495);
        
 } 

                if (color != NULL && color != Py_None) {
                
        int tmp41304282 = PyList_Size(color);
        int tmp45345441;
        for (tmp45345441 = 0; tmp45345441 < tmp41304282; tmp45345441++) {
            float tmp = (float) PyFloat_AsDouble(
            PyList_GetItem(color, tmp45345441));
            ((self->base)->color)[tmp45345441] = tmp;
        }
        
 } 

return 0; }
            static PyTypeObject PyVkDebugMarkerMarkerInfoEXTType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDebugMarkerMarkerInfoEXT", sizeof(PyVkDebugMarkerMarkerInfoEXT), 0,
                (destructor)PyVkDebugMarkerMarkerInfoEXT_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDebugMarkerMarkerInfoEXT object",0,0,0,0,0,0,0,0,
                PyVkDebugMarkerMarkerInfoEXT_getsetters,0,0,0,0,0,(initproc)PyVkDebugMarkerMarkerInfoEXT_init,0,PyVkDebugMarkerMarkerInfoEXT_new,};
        
            static void PyVkDedicatedAllocationImageCreateInfoNV_del(PyVkDedicatedAllocationImageCreateInfoNV* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDedicatedAllocationImageCreateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDedicatedAllocationImageCreateInfoNV *self;
                self = (PyVkDedicatedAllocationImageCreateInfoNV *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDedicatedAllocationImageCreateInfoNV));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDedicatedAllocationImageCreateInfoNV");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDedicatedAllocationImageCreateInfoNV_getpNext(PyVkDedicatedAllocationImageCreateInfoNV *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDedicatedAllocationImageCreateInfoNV_getsetters[] = {
                
                    { "pNext", (getter)PyVkDedicatedAllocationImageCreateInfoNV_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDedicatedAllocationImageCreateInfoNV_init(PyVkDedicatedAllocationImageCreateInfoNV *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* dedicatedAllocation = NULL;
static char *kwlist[] = {"sType","pNext","dedicatedAllocation",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &sType, &pNext, &dedicatedAllocation)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (dedicatedAllocation != NULL && dedicatedAllocation != Py_None) {
                
                    (self->base)->dedicatedAllocation = PyLong_AsLong(dedicatedAllocation);
                
 } 

return 0; }
            static PyTypeObject PyVkDedicatedAllocationImageCreateInfoNVType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDedicatedAllocationImageCreateInfoNV", sizeof(PyVkDedicatedAllocationImageCreateInfoNV), 0,
                (destructor)PyVkDedicatedAllocationImageCreateInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDedicatedAllocationImageCreateInfoNV object",0,0,0,0,0,0,0,0,
                PyVkDedicatedAllocationImageCreateInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkDedicatedAllocationImageCreateInfoNV_init,0,PyVkDedicatedAllocationImageCreateInfoNV_new,};
        
            static void PyVkDedicatedAllocationBufferCreateInfoNV_del(PyVkDedicatedAllocationBufferCreateInfoNV* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDedicatedAllocationBufferCreateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDedicatedAllocationBufferCreateInfoNV *self;
                self = (PyVkDedicatedAllocationBufferCreateInfoNV *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDedicatedAllocationBufferCreateInfoNV));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDedicatedAllocationBufferCreateInfoNV");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDedicatedAllocationBufferCreateInfoNV_getpNext(PyVkDedicatedAllocationBufferCreateInfoNV *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDedicatedAllocationBufferCreateInfoNV_getsetters[] = {
                
                    { "pNext", (getter)PyVkDedicatedAllocationBufferCreateInfoNV_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDedicatedAllocationBufferCreateInfoNV_init(PyVkDedicatedAllocationBufferCreateInfoNV *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* dedicatedAllocation = NULL;
static char *kwlist[] = {"sType","pNext","dedicatedAllocation",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &sType, &pNext, &dedicatedAllocation)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (dedicatedAllocation != NULL && dedicatedAllocation != Py_None) {
                
                    (self->base)->dedicatedAllocation = PyLong_AsLong(dedicatedAllocation);
                
 } 

return 0; }
            static PyTypeObject PyVkDedicatedAllocationBufferCreateInfoNVType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDedicatedAllocationBufferCreateInfoNV", sizeof(PyVkDedicatedAllocationBufferCreateInfoNV), 0,
                (destructor)PyVkDedicatedAllocationBufferCreateInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDedicatedAllocationBufferCreateInfoNV object",0,0,0,0,0,0,0,0,
                PyVkDedicatedAllocationBufferCreateInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkDedicatedAllocationBufferCreateInfoNV_init,0,PyVkDedicatedAllocationBufferCreateInfoNV_new,};
        
            static void PyVkDedicatedAllocationMemoryAllocateInfoNV_del(PyVkDedicatedAllocationMemoryAllocateInfoNV* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkDedicatedAllocationMemoryAllocateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkDedicatedAllocationMemoryAllocateInfoNV *self;
                self = (PyVkDedicatedAllocationMemoryAllocateInfoNV *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkDedicatedAllocationMemoryAllocateInfoNV));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDedicatedAllocationMemoryAllocateInfoNV");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkDedicatedAllocationMemoryAllocateInfoNV_getpNext(PyVkDedicatedAllocationMemoryAllocateInfoNV *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkDedicatedAllocationMemoryAllocateInfoNV_getsetters[] = {
                
                    { "pNext", (getter)PyVkDedicatedAllocationMemoryAllocateInfoNV_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkDedicatedAllocationMemoryAllocateInfoNV_init(PyVkDedicatedAllocationMemoryAllocateInfoNV *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* image = NULL;
PyObject* buffer = NULL;
static char *kwlist[] = {"sType","pNext","image","buffer",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &sType, &pNext, &image, &buffer)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (image != NULL && image != Py_None) {
                
                (self->base)->image = PyCapsule_GetPointer(image, "VkImage");
            
 } 

                if (buffer != NULL && buffer != Py_None) {
                
                (self->base)->buffer = PyCapsule_GetPointer(buffer, "VkBuffer");
            
 } 

return 0; }
            static PyTypeObject PyVkDedicatedAllocationMemoryAllocateInfoNVType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDedicatedAllocationMemoryAllocateInfoNV", sizeof(PyVkDedicatedAllocationMemoryAllocateInfoNV), 0,
                (destructor)PyVkDedicatedAllocationMemoryAllocateInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDedicatedAllocationMemoryAllocateInfoNV object",0,0,0,0,0,0,0,0,
                PyVkDedicatedAllocationMemoryAllocateInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkDedicatedAllocationMemoryAllocateInfoNV_init,0,PyVkDedicatedAllocationMemoryAllocateInfoNV_new,};
        
            static void PyVkExternalImageFormatPropertiesNV_del(PyVkExternalImageFormatPropertiesNV* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkExternalImageFormatPropertiesNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkExternalImageFormatPropertiesNV *self;
                self = (PyVkExternalImageFormatPropertiesNV *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkExternalImageFormatPropertiesNV));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkExternalImageFormatPropertiesNV");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkExternalImageFormatPropertiesNV_getsetters[] = {
                {NULL}};

            static int
            PyVkExternalImageFormatPropertiesNV_init(PyVkExternalImageFormatPropertiesNV *self, PyObject *args, PyObject *kwds) {
            PyObject* imageFormatProperties = NULL;
PyObject* externalMemoryFeatures = NULL;
PyObject* exportFromImportedHandleTypes = NULL;
PyObject* compatibleHandleTypes = NULL;
static char *kwlist[] = {"imageFormatProperties","externalMemoryFeatures","exportFromImportedHandleTypes","compatibleHandleTypes",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &imageFormatProperties, &externalMemoryFeatures, &exportFromImportedHandleTypes, &compatibleHandleTypes)) return -1;

                if (imageFormatProperties != NULL && imageFormatProperties != Py_None) {
                
                    (self->base)->imageFormatProperties = *(((PyVkImageFormatProperties*)imageFormatProperties)->base);
                
 } 

                if (externalMemoryFeatures != NULL && externalMemoryFeatures != Py_None) {
                
                    (self->base)->externalMemoryFeatures = PyLong_AsLong(externalMemoryFeatures);
                
 } 

                if (exportFromImportedHandleTypes != NULL && exportFromImportedHandleTypes != Py_None) {
                
                    (self->base)->exportFromImportedHandleTypes = PyLong_AsLong(exportFromImportedHandleTypes);
                
 } 

                if (compatibleHandleTypes != NULL && compatibleHandleTypes != Py_None) {
                
                    (self->base)->compatibleHandleTypes = PyLong_AsLong(compatibleHandleTypes);
                
 } 

return 0; }
            static PyTypeObject PyVkExternalImageFormatPropertiesNVType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkExternalImageFormatPropertiesNV", sizeof(PyVkExternalImageFormatPropertiesNV), 0,
                (destructor)PyVkExternalImageFormatPropertiesNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkExternalImageFormatPropertiesNV object",0,0,0,0,0,0,0,0,
                PyVkExternalImageFormatPropertiesNV_getsetters,0,0,0,0,0,(initproc)PyVkExternalImageFormatPropertiesNV_init,0,PyVkExternalImageFormatPropertiesNV_new,};
        
            static void PyVkExternalMemoryImageCreateInfoNV_del(PyVkExternalMemoryImageCreateInfoNV* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkExternalMemoryImageCreateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkExternalMemoryImageCreateInfoNV *self;
                self = (PyVkExternalMemoryImageCreateInfoNV *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkExternalMemoryImageCreateInfoNV));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkExternalMemoryImageCreateInfoNV");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkExternalMemoryImageCreateInfoNV_getpNext(PyVkExternalMemoryImageCreateInfoNV *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkExternalMemoryImageCreateInfoNV_getsetters[] = {
                
                    { "pNext", (getter)PyVkExternalMemoryImageCreateInfoNV_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkExternalMemoryImageCreateInfoNV_init(PyVkExternalMemoryImageCreateInfoNV *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* handleTypes = NULL;
static char *kwlist[] = {"sType","pNext","handleTypes",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &sType, &pNext, &handleTypes)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (handleTypes != NULL && handleTypes != Py_None) {
                
                    (self->base)->handleTypes = PyLong_AsLong(handleTypes);
                
 } 

return 0; }
            static PyTypeObject PyVkExternalMemoryImageCreateInfoNVType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkExternalMemoryImageCreateInfoNV", sizeof(PyVkExternalMemoryImageCreateInfoNV), 0,
                (destructor)PyVkExternalMemoryImageCreateInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkExternalMemoryImageCreateInfoNV object",0,0,0,0,0,0,0,0,
                PyVkExternalMemoryImageCreateInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkExternalMemoryImageCreateInfoNV_init,0,PyVkExternalMemoryImageCreateInfoNV_new,};
        
            static void PyVkExportMemoryAllocateInfoNV_del(PyVkExportMemoryAllocateInfoNV* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkExportMemoryAllocateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkExportMemoryAllocateInfoNV *self;
                self = (PyVkExportMemoryAllocateInfoNV *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkExportMemoryAllocateInfoNV));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkExportMemoryAllocateInfoNV");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkExportMemoryAllocateInfoNV_getpNext(PyVkExportMemoryAllocateInfoNV *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkExportMemoryAllocateInfoNV_getsetters[] = {
                
                    { "pNext", (getter)PyVkExportMemoryAllocateInfoNV_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkExportMemoryAllocateInfoNV_init(PyVkExportMemoryAllocateInfoNV *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* handleTypes = NULL;
static char *kwlist[] = {"sType","pNext","handleTypes",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &sType, &pNext, &handleTypes)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (handleTypes != NULL && handleTypes != Py_None) {
                
                    (self->base)->handleTypes = PyLong_AsLong(handleTypes);
                
 } 

return 0; }
            static PyTypeObject PyVkExportMemoryAllocateInfoNVType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkExportMemoryAllocateInfoNV", sizeof(PyVkExportMemoryAllocateInfoNV), 0,
                (destructor)PyVkExportMemoryAllocateInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkExportMemoryAllocateInfoNV object",0,0,0,0,0,0,0,0,
                PyVkExportMemoryAllocateInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkExportMemoryAllocateInfoNV_init,0,PyVkExportMemoryAllocateInfoNV_new,};
        
#ifdef VK_USE_PLATFORM_WIN32_KHR

            static void PyVkImportMemoryWin32HandleInfoNV_del(PyVkImportMemoryWin32HandleInfoNV* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkImportMemoryWin32HandleInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkImportMemoryWin32HandleInfoNV *self;
                self = (PyVkImportMemoryWin32HandleInfoNV *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkImportMemoryWin32HandleInfoNV));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImportMemoryWin32HandleInfoNV");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkImportMemoryWin32HandleInfoNV_getpNext(PyVkImportMemoryWin32HandleInfoNV *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkImportMemoryWin32HandleInfoNV_getsetters[] = {
                
                    { "pNext", (getter)PyVkImportMemoryWin32HandleInfoNV_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkImportMemoryWin32HandleInfoNV_init(PyVkImportMemoryWin32HandleInfoNV *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* handleType = NULL;
PyObject* handle = NULL;
static char *kwlist[] = {"sType","pNext","handleType","handle",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &sType, &pNext, &handleType, &handle)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (handleType != NULL && handleType != Py_None) {
                
                    (self->base)->handleType = PyLong_AsLong(handleType);
                
 } 

return 0; }
            static PyTypeObject PyVkImportMemoryWin32HandleInfoNVType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImportMemoryWin32HandleInfoNV", sizeof(PyVkImportMemoryWin32HandleInfoNV), 0,
                (destructor)PyVkImportMemoryWin32HandleInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImportMemoryWin32HandleInfoNV object",0,0,0,0,0,0,0,0,
                PyVkImportMemoryWin32HandleInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkImportMemoryWin32HandleInfoNV_init,0,PyVkImportMemoryWin32HandleInfoNV_new,};
        
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

            static void PyVkExportMemoryWin32HandleInfoNV_del(PyVkExportMemoryWin32HandleInfoNV* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkExportMemoryWin32HandleInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkExportMemoryWin32HandleInfoNV *self;
                self = (PyVkExportMemoryWin32HandleInfoNV *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkExportMemoryWin32HandleInfoNV));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkExportMemoryWin32HandleInfoNV");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkExportMemoryWin32HandleInfoNV_getpNext(PyVkExportMemoryWin32HandleInfoNV *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkExportMemoryWin32HandleInfoNV_getsetters[] = {
                
                    { "pNext", (getter)PyVkExportMemoryWin32HandleInfoNV_getpNext, NULL, "", NULL},
                {NULL}};

            static int
            PyVkExportMemoryWin32HandleInfoNV_init(PyVkExportMemoryWin32HandleInfoNV *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* pAttributes = NULL;
PyObject* dwAccess = NULL;
static char *kwlist[] = {"sType","pNext","pAttributes","dwAccess",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOO", kwlist, &sType, &pNext, &pAttributes, &dwAccess)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

return 0; }
            static PyTypeObject PyVkExportMemoryWin32HandleInfoNVType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkExportMemoryWin32HandleInfoNV", sizeof(PyVkExportMemoryWin32HandleInfoNV), 0,
                (destructor)PyVkExportMemoryWin32HandleInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkExportMemoryWin32HandleInfoNV object",0,0,0,0,0,0,0,0,
                PyVkExportMemoryWin32HandleInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkExportMemoryWin32HandleInfoNV_init,0,PyVkExportMemoryWin32HandleInfoNV_new,};
        
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

            static void PyVkWin32KeyedMutexAcquireReleaseInfoNV_del(PyVkWin32KeyedMutexAcquireReleaseInfoNV* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkWin32KeyedMutexAcquireReleaseInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkWin32KeyedMutexAcquireReleaseInfoNV *self;
                self = (PyVkWin32KeyedMutexAcquireReleaseInfoNV *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkWin32KeyedMutexAcquireReleaseInfoNV));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkWin32KeyedMutexAcquireReleaseInfoNV");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpNext(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure){
            Py_INCREF(Py_None);PyObject* value = Py_None;
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkWin32KeyedMutexAcquireReleaseInfoNV_getacquireCount(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->acquireCount);
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpAcquireTimeoutMilliseconds(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (*((self->base)->pAcquireTimeoutMilliseconds)));
                Py_INCREF(value);
                return value;
            }
            
            static PyObject * PyVkWin32KeyedMutexAcquireReleaseInfoNV_getreleaseCount(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure){
            PyObject* value = PyLong_FromLong((long) (self->base)->releaseCount);
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkWin32KeyedMutexAcquireReleaseInfoNV_getsetters[] = {
                
                    { "pNext", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpNext, NULL, "", NULL},
                
                    { "acquireCount", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getacquireCount, NULL, "", NULL},
                
                    { "pAcquireTimeoutMilliseconds", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpAcquireTimeoutMilliseconds, NULL, "", NULL},
                
                    { "releaseCount", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getreleaseCount, NULL, "", NULL},
                {NULL}};

            static int
            PyVkWin32KeyedMutexAcquireReleaseInfoNV_init(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, PyObject *args, PyObject *kwds) {
            PyObject* sType = NULL;
PyObject* pNext = NULL;
PyObject* acquireCount = NULL;
PyObject* pAcquireSyncs = NULL;
PyObject* pAcquireKeys = NULL;
PyObject* pAcquireTimeoutMilliseconds = NULL;
PyObject* releaseCount = NULL;
PyObject* pReleaseSyncs = NULL;
PyObject* pReleaseKeys = NULL;
static char *kwlist[] = {"sType","pNext","acquireCount","pAcquireSyncs","pAcquireKeys","pAcquireTimeoutMilliseconds","releaseCount","pReleaseSyncs","pReleaseKeys",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOOOOOOOO", kwlist, &sType, &pNext, &acquireCount, &pAcquireSyncs, &pAcquireKeys, &pAcquireTimeoutMilliseconds, &releaseCount, &pReleaseSyncs, &pReleaseKeys)) return -1;

                if (sType != NULL && sType != Py_None) {
                
                    (self->base)->sType = PyLong_AsLong(sType);
                
 } 

                if (pNext != NULL && pNext != Py_None) {
                (self->base)->pNext = NULL;
 } 

                if (acquireCount != NULL && acquireCount != Py_None) {
                (self->base)->acquireCount = (uint32_t) PyLong_AsLong(acquireCount);
 } 

                if (pAcquireSyncs != NULL && pAcquireSyncs != Py_None) {
                
                (self->base)->pAcquireSyncs = PyCapsule_GetPointer(pAcquireSyncs, "VkDeviceMemory");
            
 } 

                if (pAcquireTimeoutMilliseconds != NULL && pAcquireTimeoutMilliseconds != Py_None) {
                
        uint32_t tmp51480937 = (uint32_t) PyLong_AsLong(pAcquireTimeoutMilliseconds);
        uint32_t *tmp87313927 = malloc(sizeof(uint32_t));
        memcpy(tmp87313927, &tmp51480937, sizeof(uint32_t));
        (self->base)->pAcquireTimeoutMilliseconds = tmp87313927;
        
 } 

                if (releaseCount != NULL && releaseCount != Py_None) {
                (self->base)->releaseCount = (uint32_t) PyLong_AsLong(releaseCount);
 } 

                if (pReleaseSyncs != NULL && pReleaseSyncs != Py_None) {
                
                (self->base)->pReleaseSyncs = PyCapsule_GetPointer(pReleaseSyncs, "VkDeviceMemory");
            
 } 

return 0; }
            static PyTypeObject PyVkWin32KeyedMutexAcquireReleaseInfoNVType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkWin32KeyedMutexAcquireReleaseInfoNV", sizeof(PyVkWin32KeyedMutexAcquireReleaseInfoNV), 0,
                (destructor)PyVkWin32KeyedMutexAcquireReleaseInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkWin32KeyedMutexAcquireReleaseInfoNV object",0,0,0,0,0,0,0,0,
                PyVkWin32KeyedMutexAcquireReleaseInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkWin32KeyedMutexAcquireReleaseInfoNV_init,0,PyVkWin32KeyedMutexAcquireReleaseInfoNV_new,};
        
#endif

            static void PyVkClearColorValue_del(PyVkClearColorValue* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkClearColorValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkClearColorValue *self;
                self = (PyVkClearColorValue *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkClearColorValue));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkClearColorValue");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
            static PyObject * PyVkClearColorValue_getfloat32(PyVkClearColorValue *self, void *closure){
            
        PyObject* value = PyList_New(0);
        int nb = sizeof((self->base)->float32) / sizeof((self->base)->float32[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->float32[i]);
            PyList_Append(value, py_tmp);
        }
        
                Py_INCREF(value);
                return value;
            }
            
                static PyGetSetDef PyVkClearColorValue_getsetters[] = {
                
                    { "float32", (getter)PyVkClearColorValue_getfloat32, NULL, "", NULL},
                {NULL}};

            static int
            PyVkClearColorValue_init(PyVkClearColorValue *self, PyObject *args, PyObject *kwds) {
            PyObject* float32 = NULL;
PyObject* int32 = NULL;
PyObject* uint32 = NULL;
static char *kwlist[] = {"float32","int32","uint32",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &float32, &int32, &uint32)) return -1;

int nb_union_arg = 0;

                if (float32 != NULL && float32 != Py_None) nb_union_arg++;
                
                if (int32 != NULL && int32 != Py_None) nb_union_arg++;
                
                if (uint32 != NULL && uint32 != Py_None) nb_union_arg++;
                
            if (nb_union_arg > 1) {
                PyErr_SetString(PyExc_TypeError, "Only one argument allowed");
                return -1;
            }

                if (float32 != NULL && float32 != Py_None) {
                
        int tmp84012378 = PyList_Size(float32);
        int tmp36718977;
        for (tmp36718977 = 0; tmp36718977 < tmp84012378; tmp36718977++) {
            float tmp = (float) PyFloat_AsDouble(
            PyList_GetItem(float32, tmp36718977));
            ((self->base)->float32)[tmp36718977] = tmp;
        }
        
 } 

return 0; }
            static PyTypeObject PyVkClearColorValueType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkClearColorValue", sizeof(PyVkClearColorValue), 0,
                (destructor)PyVkClearColorValue_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkClearColorValue object",0,0,0,0,0,0,0,0,
                PyVkClearColorValue_getsetters,0,0,0,0,0,(initproc)PyVkClearColorValue_init,0,PyVkClearColorValue_new,};
        
            static void PyVkClearValue_del(PyVkClearValue* self) {
                Py_TYPE(self)->tp_free((PyObject*)self); }
            
            static PyObject *
            PyVkClearValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
            {
                PyVkClearValue *self;
                self = (PyVkClearValue *)type->tp_alloc(type, 0);
                if ( self != NULL) {
                    self->base = malloc(sizeof(VkClearValue));
                    if (self->base == NULL) {
                        PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkClearValue");
                        return NULL;
                    }
                }

                return (PyObject *)self;
            }
            
                static PyGetSetDef PyVkClearValue_getsetters[] = {
                {NULL}};

            static int
            PyVkClearValue_init(PyVkClearValue *self, PyObject *args, PyObject *kwds) {
            PyObject* color = NULL;
PyObject* depthStencil = NULL;
static char *kwlist[] = {"color","depthStencil",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "|OO", kwlist, &color, &depthStencil)) return -1;

int nb_union_arg = 0;

                if (color != NULL && color != Py_None) nb_union_arg++;
                
                if (depthStencil != NULL && depthStencil != Py_None) nb_union_arg++;
                
            if (nb_union_arg > 1) {
                PyErr_SetString(PyExc_TypeError, "Only one argument allowed");
                return -1;
            }

return 0; }
            static PyTypeObject PyVkClearValueType = {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkClearValue", sizeof(PyVkClearValue), 0,
                (destructor)PyVkClearValue_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkClearValue object",0,0,0,0,0,0,0,0,
                PyVkClearValue_getsetters,0,0,0,0,0,(initproc)PyVkClearValue_init,0,PyVkClearValue_new,};
        
            static PyObject* PyvkCreateInstance(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pInstance = NULL;
static char *kwlist[] = {"pCreateInfo","pAllocator","pInstance",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &pCreateInfo, &pAllocator, &pInstance)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyInstance(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* instance = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"instance","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &instance, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkEnumeratePhysicalDevices(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* instance = NULL;
PyObject* pPhysicalDeviceCount = NULL;
PyObject* pPhysicalDevices = NULL;
static char *kwlist[] = {"instance","pPhysicalDeviceCount","pPhysicalDevices",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &instance, &pPhysicalDeviceCount, &pPhysicalDevices)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceProperties(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* pProperties = NULL;
static char *kwlist[] = {"physicalDevice","pProperties",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &physicalDevice, &pProperties)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceQueueFamilyProperties(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* pQueueFamilyPropertyCount = NULL;
PyObject* pQueueFamilyProperties = NULL;
static char *kwlist[] = {"physicalDevice","pQueueFamilyPropertyCount","pQueueFamilyProperties",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &physicalDevice, &pQueueFamilyPropertyCount, &pQueueFamilyProperties)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceMemoryProperties(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* pMemoryProperties = NULL;
static char *kwlist[] = {"physicalDevice","pMemoryProperties",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &physicalDevice, &pMemoryProperties)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceFeatures(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* pFeatures = NULL;
static char *kwlist[] = {"physicalDevice","pFeatures",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &physicalDevice, &pFeatures)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceFormatProperties(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* format = NULL;
PyObject* pFormatProperties = NULL;
static char *kwlist[] = {"physicalDevice","format","pFormatProperties",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &physicalDevice, &format, &pFormatProperties)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceImageFormatProperties(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* format = NULL;
PyObject* type = NULL;
PyObject* tiling = NULL;
PyObject* usage = NULL;
PyObject* flags = NULL;
PyObject* pImageFormatProperties = NULL;
static char *kwlist[] = {"physicalDevice","format","type","tiling","usage","flags","pImageFormatProperties",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &physicalDevice, &format, &type, &tiling, &usage, &flags, &pImageFormatProperties)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateDevice(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pDevice = NULL;
static char *kwlist[] = {"physicalDevice","pCreateInfo","pAllocator","pDevice",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &physicalDevice, &pCreateInfo, &pAllocator, &pDevice)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyDevice(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkEnumerateInstanceLayerProperties(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* pPropertyCount = NULL;
PyObject* pProperties = NULL;
static char *kwlist[] = {"pPropertyCount","pProperties",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &pPropertyCount, &pProperties)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkEnumerateInstanceExtensionProperties(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* pLayerName = NULL;
PyObject* pPropertyCount = NULL;
PyObject* pProperties = NULL;
static char *kwlist[] = {"pLayerName","pPropertyCount","pProperties",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &pLayerName, &pPropertyCount, &pProperties)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkEnumerateDeviceLayerProperties(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* pPropertyCount = NULL;
PyObject* pProperties = NULL;
static char *kwlist[] = {"physicalDevice","pPropertyCount","pProperties",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &physicalDevice, &pPropertyCount, &pProperties)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkEnumerateDeviceExtensionProperties(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* pLayerName = NULL;
PyObject* pPropertyCount = NULL;
PyObject* pProperties = NULL;
static char *kwlist[] = {"physicalDevice","pLayerName","pPropertyCount","pProperties",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &physicalDevice, &pLayerName, &pPropertyCount, &pProperties)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetDeviceQueue(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* queueFamilyIndex = NULL;
PyObject* queueIndex = NULL;
PyObject* pQueue = NULL;
static char *kwlist[] = {"device","queueFamilyIndex","queueIndex","pQueue",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &queueFamilyIndex, &queueIndex, &pQueue)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkQueueSubmit(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* queue = NULL;
PyObject* submitCount = NULL;
PyObject* pSubmits = NULL;
PyObject* fence = NULL;
static char *kwlist[] = {"queue","submitCount","pSubmits","fence",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &queue, &submitCount, &pSubmits, &fence)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkQueueWaitIdle(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* queue = NULL;
static char *kwlist[] = {"queue",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &queue)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDeviceWaitIdle(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
static char *kwlist[] = {"device",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &device)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkAllocateMemory(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pAllocateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pMemory = NULL;
static char *kwlist[] = {"device","pAllocateInfo","pAllocator","pMemory",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pAllocateInfo, &pAllocator, &pMemory)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkFreeMemory(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* memory = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","memory","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &memory, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkMapMemory(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* memory = NULL;
PyObject* offset = NULL;
PyObject* size = NULL;
PyObject* flags = NULL;
PyObject* ppData = NULL;
static char *kwlist[] = {"device","memory","offset","size","flags","ppData",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &device, &memory, &offset, &size, &flags, &ppData)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkUnmapMemory(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* memory = NULL;
static char *kwlist[] = {"device","memory",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &memory)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkFlushMappedMemoryRanges(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* memoryRangeCount = NULL;
PyObject* pMemoryRanges = NULL;
static char *kwlist[] = {"device","memoryRangeCount","pMemoryRanges",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &memoryRangeCount, &pMemoryRanges)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkInvalidateMappedMemoryRanges(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* memoryRangeCount = NULL;
PyObject* pMemoryRanges = NULL;
static char *kwlist[] = {"device","memoryRangeCount","pMemoryRanges",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &memoryRangeCount, &pMemoryRanges)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetDeviceMemoryCommitment(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* memory = NULL;
PyObject* pCommittedMemoryInBytes = NULL;
static char *kwlist[] = {"device","memory","pCommittedMemoryInBytes",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &memory, &pCommittedMemoryInBytes)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetBufferMemoryRequirements(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* buffer = NULL;
PyObject* pMemoryRequirements = NULL;
static char *kwlist[] = {"device","buffer","pMemoryRequirements",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &buffer, &pMemoryRequirements)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkBindBufferMemory(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* buffer = NULL;
PyObject* memory = NULL;
PyObject* memoryOffset = NULL;
static char *kwlist[] = {"device","buffer","memory","memoryOffset",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &buffer, &memory, &memoryOffset)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetImageMemoryRequirements(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* image = NULL;
PyObject* pMemoryRequirements = NULL;
static char *kwlist[] = {"device","image","pMemoryRequirements",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &image, &pMemoryRequirements)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkBindImageMemory(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* image = NULL;
PyObject* memory = NULL;
PyObject* memoryOffset = NULL;
static char *kwlist[] = {"device","image","memory","memoryOffset",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &image, &memory, &memoryOffset)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetImageSparseMemoryRequirements(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* image = NULL;
PyObject* pSparseMemoryRequirementCount = NULL;
PyObject* pSparseMemoryRequirements = NULL;
static char *kwlist[] = {"device","image","pSparseMemoryRequirementCount","pSparseMemoryRequirements",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &image, &pSparseMemoryRequirementCount, &pSparseMemoryRequirements)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceSparseImageFormatProperties(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* format = NULL;
PyObject* type = NULL;
PyObject* samples = NULL;
PyObject* usage = NULL;
PyObject* tiling = NULL;
PyObject* pPropertyCount = NULL;
PyObject* pProperties = NULL;
static char *kwlist[] = {"physicalDevice","format","type","samples","usage","tiling","pPropertyCount","pProperties",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &physicalDevice, &format, &type, &samples, &usage, &tiling, &pPropertyCount, &pProperties)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkQueueBindSparse(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* queue = NULL;
PyObject* bindInfoCount = NULL;
PyObject* pBindInfo = NULL;
PyObject* fence = NULL;
static char *kwlist[] = {"queue","bindInfoCount","pBindInfo","fence",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &queue, &bindInfoCount, &pBindInfo, &fence)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateFence(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pFence = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pFence",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pFence)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyFence(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* fence = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","fence","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &fence, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkResetFences(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* fenceCount = NULL;
PyObject* pFences = NULL;
static char *kwlist[] = {"device","fenceCount","pFences",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &fenceCount, &pFences)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetFenceStatus(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* fence = NULL;
static char *kwlist[] = {"device","fence",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &fence)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkWaitForFences(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* fenceCount = NULL;
PyObject* pFences = NULL;
PyObject* waitAll = NULL;
PyObject* timeout = NULL;
static char *kwlist[] = {"device","fenceCount","pFences","waitAll","timeout",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &device, &fenceCount, &pFences, &waitAll, &timeout)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateSemaphore(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pSemaphore = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pSemaphore",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pSemaphore)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroySemaphore(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* semaphore = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","semaphore","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &semaphore, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateEvent(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pEvent = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pEvent",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pEvent)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyEvent(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* event = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","event","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &event, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetEventStatus(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* event = NULL;
static char *kwlist[] = {"device","event",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &event)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkSetEvent(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* event = NULL;
static char *kwlist[] = {"device","event",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &event)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkResetEvent(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* event = NULL;
static char *kwlist[] = {"device","event",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &event)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateQueryPool(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pQueryPool = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pQueryPool",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pQueryPool)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyQueryPool(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* queryPool = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","queryPool","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &queryPool, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetQueryPoolResults(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* queryPool = NULL;
PyObject* firstQuery = NULL;
PyObject* queryCount = NULL;
PyObject* dataSize = NULL;
PyObject* pData = NULL;
PyObject* stride = NULL;
PyObject* flags = NULL;
static char *kwlist[] = {"device","queryPool","firstQuery","queryCount","dataSize","pData","stride","flags",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &device, &queryPool, &firstQuery, &queryCount, &dataSize, &pData, &stride, &flags)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateBuffer(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pBuffer = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pBuffer",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pBuffer)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyBuffer(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* buffer = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","buffer","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &buffer, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateBufferView(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pView = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pView",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pView)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyBufferView(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* bufferView = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","bufferView","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &bufferView, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateImage(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pImage = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pImage",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pImage)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyImage(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* image = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","image","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &image, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetImageSubresourceLayout(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* image = NULL;
PyObject* pSubresource = NULL;
PyObject* pLayout = NULL;
static char *kwlist[] = {"device","image","pSubresource","pLayout",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &image, &pSubresource, &pLayout)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateImageView(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pView = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pView",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pView)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyImageView(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* imageView = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","imageView","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &imageView, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateShaderModule(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pShaderModule = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pShaderModule",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pShaderModule)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyShaderModule(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* shaderModule = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","shaderModule","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &shaderModule, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreatePipelineCache(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pPipelineCache = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pPipelineCache",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pPipelineCache)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyPipelineCache(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pipelineCache = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","pipelineCache","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &pipelineCache, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPipelineCacheData(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pipelineCache = NULL;
PyObject* pDataSize = NULL;
PyObject* pData = NULL;
static char *kwlist[] = {"device","pipelineCache","pDataSize","pData",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pipelineCache, &pDataSize, &pData)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkMergePipelineCaches(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* dstCache = NULL;
PyObject* srcCacheCount = NULL;
PyObject* pSrcCaches = NULL;
static char *kwlist[] = {"device","dstCache","srcCacheCount","pSrcCaches",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &dstCache, &srcCacheCount, &pSrcCaches)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateGraphicsPipelines(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pipelineCache = NULL;
PyObject* createInfoCount = NULL;
PyObject* pCreateInfos = NULL;
PyObject* pAllocator = NULL;
PyObject* pPipelines = NULL;
static char *kwlist[] = {"device","pipelineCache","createInfoCount","pCreateInfos","pAllocator","pPipelines",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &device, &pipelineCache, &createInfoCount, &pCreateInfos, &pAllocator, &pPipelines)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateComputePipelines(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pipelineCache = NULL;
PyObject* createInfoCount = NULL;
PyObject* pCreateInfos = NULL;
PyObject* pAllocator = NULL;
PyObject* pPipelines = NULL;
static char *kwlist[] = {"device","pipelineCache","createInfoCount","pCreateInfos","pAllocator","pPipelines",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &device, &pipelineCache, &createInfoCount, &pCreateInfos, &pAllocator, &pPipelines)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyPipeline(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pipeline = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","pipeline","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &pipeline, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreatePipelineLayout(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pPipelineLayout = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pPipelineLayout",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pPipelineLayout)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyPipelineLayout(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pipelineLayout = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","pipelineLayout","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &pipelineLayout, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateSampler(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pSampler = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pSampler",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pSampler)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroySampler(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* sampler = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","sampler","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &sampler, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateDescriptorSetLayout(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pSetLayout = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pSetLayout",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pSetLayout)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyDescriptorSetLayout(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* descriptorSetLayout = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","descriptorSetLayout","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &descriptorSetLayout, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateDescriptorPool(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pDescriptorPool = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pDescriptorPool",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pDescriptorPool)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyDescriptorPool(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* descriptorPool = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","descriptorPool","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &descriptorPool, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkResetDescriptorPool(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* descriptorPool = NULL;
PyObject* flags = NULL;
static char *kwlist[] = {"device","descriptorPool","flags",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &descriptorPool, &flags)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkAllocateDescriptorSets(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pAllocateInfo = NULL;
PyObject* pDescriptorSets = NULL;
static char *kwlist[] = {"device","pAllocateInfo","pDescriptorSets",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &pAllocateInfo, &pDescriptorSets)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkFreeDescriptorSets(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* descriptorPool = NULL;
PyObject* descriptorSetCount = NULL;
PyObject* pDescriptorSets = NULL;
static char *kwlist[] = {"device","descriptorPool","descriptorSetCount","pDescriptorSets",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &descriptorPool, &descriptorSetCount, &pDescriptorSets)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkUpdateDescriptorSets(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* descriptorWriteCount = NULL;
PyObject* pDescriptorWrites = NULL;
PyObject* descriptorCopyCount = NULL;
PyObject* pDescriptorCopies = NULL;
static char *kwlist[] = {"device","descriptorWriteCount","pDescriptorWrites","descriptorCopyCount","pDescriptorCopies",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &device, &descriptorWriteCount, &pDescriptorWrites, &descriptorCopyCount, &pDescriptorCopies)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateFramebuffer(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pFramebuffer = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pFramebuffer",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pFramebuffer)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyFramebuffer(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* framebuffer = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","framebuffer","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &framebuffer, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateRenderPass(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pRenderPass = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pRenderPass",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pRenderPass)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyRenderPass(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* renderPass = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","renderPass","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &renderPass, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetRenderAreaGranularity(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* renderPass = NULL;
PyObject* pGranularity = NULL;
static char *kwlist[] = {"device","renderPass","pGranularity",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &renderPass, &pGranularity)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateCommandPool(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pCommandPool = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pCommandPool",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pCommandPool)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyCommandPool(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* commandPool = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","commandPool","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &commandPool, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkResetCommandPool(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* commandPool = NULL;
PyObject* flags = NULL;
static char *kwlist[] = {"device","commandPool","flags",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &commandPool, &flags)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkAllocateCommandBuffers(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pAllocateInfo = NULL;
PyObject* pCommandBuffers = NULL;
static char *kwlist[] = {"device","pAllocateInfo","pCommandBuffers",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &pAllocateInfo, &pCommandBuffers)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkFreeCommandBuffers(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* commandPool = NULL;
PyObject* commandBufferCount = NULL;
PyObject* pCommandBuffers = NULL;
static char *kwlist[] = {"device","commandPool","commandBufferCount","pCommandBuffers",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &commandPool, &commandBufferCount, &pCommandBuffers)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkBeginCommandBuffer(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* pBeginInfo = NULL;
static char *kwlist[] = {"commandBuffer","pBeginInfo",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &commandBuffer, &pBeginInfo)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkEndCommandBuffer(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
static char *kwlist[] = {"commandBuffer",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &commandBuffer)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkResetCommandBuffer(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* flags = NULL;
static char *kwlist[] = {"commandBuffer","flags",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &commandBuffer, &flags)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdBindPipeline(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* pipelineBindPoint = NULL;
PyObject* pipeline = NULL;
static char *kwlist[] = {"commandBuffer","pipelineBindPoint","pipeline",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &pipelineBindPoint, &pipeline)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdSetViewport(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* firstViewport = NULL;
PyObject* viewportCount = NULL;
PyObject* pViewports = NULL;
static char *kwlist[] = {"commandBuffer","firstViewport","viewportCount","pViewports",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &firstViewport, &viewportCount, &pViewports)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdSetScissor(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* firstScissor = NULL;
PyObject* scissorCount = NULL;
PyObject* pScissors = NULL;
static char *kwlist[] = {"commandBuffer","firstScissor","scissorCount","pScissors",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &firstScissor, &scissorCount, &pScissors)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdSetLineWidth(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* lineWidth = NULL;
static char *kwlist[] = {"commandBuffer","lineWidth",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &commandBuffer, &lineWidth)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdSetDepthBias(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* depthBiasConstantFactor = NULL;
PyObject* depthBiasClamp = NULL;
PyObject* depthBiasSlopeFactor = NULL;
static char *kwlist[] = {"commandBuffer","depthBiasConstantFactor","depthBiasClamp","depthBiasSlopeFactor",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &depthBiasConstantFactor, &depthBiasClamp, &depthBiasSlopeFactor)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdSetBlendConstants(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* blendConstants = NULL;
static char *kwlist[] = {"commandBuffer","blendConstants",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &commandBuffer, &blendConstants)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdSetDepthBounds(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* minDepthBounds = NULL;
PyObject* maxDepthBounds = NULL;
static char *kwlist[] = {"commandBuffer","minDepthBounds","maxDepthBounds",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &minDepthBounds, &maxDepthBounds)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdSetStencilCompareMask(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* faceMask = NULL;
PyObject* compareMask = NULL;
static char *kwlist[] = {"commandBuffer","faceMask","compareMask",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &faceMask, &compareMask)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdSetStencilWriteMask(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* faceMask = NULL;
PyObject* writeMask = NULL;
static char *kwlist[] = {"commandBuffer","faceMask","writeMask",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &faceMask, &writeMask)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdSetStencilReference(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* faceMask = NULL;
PyObject* reference = NULL;
static char *kwlist[] = {"commandBuffer","faceMask","reference",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &faceMask, &reference)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdBindDescriptorSets(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* pipelineBindPoint = NULL;
PyObject* layout = NULL;
PyObject* firstSet = NULL;
PyObject* descriptorSetCount = NULL;
PyObject* pDescriptorSets = NULL;
PyObject* dynamicOffsetCount = NULL;
PyObject* pDynamicOffsets = NULL;
static char *kwlist[] = {"commandBuffer","pipelineBindPoint","layout","firstSet","descriptorSetCount","pDescriptorSets","dynamicOffsetCount","pDynamicOffsets",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &commandBuffer, &pipelineBindPoint, &layout, &firstSet, &descriptorSetCount, &pDescriptorSets, &dynamicOffsetCount, &pDynamicOffsets)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdBindIndexBuffer(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* buffer = NULL;
PyObject* offset = NULL;
PyObject* indexType = NULL;
static char *kwlist[] = {"commandBuffer","buffer","offset","indexType",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &buffer, &offset, &indexType)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdBindVertexBuffers(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* firstBinding = NULL;
PyObject* bindingCount = NULL;
PyObject* pBuffers = NULL;
PyObject* pOffsets = NULL;
static char *kwlist[] = {"commandBuffer","firstBinding","bindingCount","pBuffers","pOffsets",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &firstBinding, &bindingCount, &pBuffers, &pOffsets)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdDraw(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* vertexCount = NULL;
PyObject* instanceCount = NULL;
PyObject* firstVertex = NULL;
PyObject* firstInstance = NULL;
static char *kwlist[] = {"commandBuffer","vertexCount","instanceCount","firstVertex","firstInstance",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &vertexCount, &instanceCount, &firstVertex, &firstInstance)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdDrawIndexed(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* indexCount = NULL;
PyObject* instanceCount = NULL;
PyObject* firstIndex = NULL;
PyObject* vertexOffset = NULL;
PyObject* firstInstance = NULL;
static char *kwlist[] = {"commandBuffer","indexCount","instanceCount","firstIndex","vertexOffset","firstInstance",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &commandBuffer, &indexCount, &instanceCount, &firstIndex, &vertexOffset, &firstInstance)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdDrawIndirect(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* buffer = NULL;
PyObject* offset = NULL;
PyObject* drawCount = NULL;
PyObject* stride = NULL;
static char *kwlist[] = {"commandBuffer","buffer","offset","drawCount","stride",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &buffer, &offset, &drawCount, &stride)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdDrawIndexedIndirect(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* buffer = NULL;
PyObject* offset = NULL;
PyObject* drawCount = NULL;
PyObject* stride = NULL;
static char *kwlist[] = {"commandBuffer","buffer","offset","drawCount","stride",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &buffer, &offset, &drawCount, &stride)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdDispatch(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* x = NULL;
PyObject* y = NULL;
PyObject* z = NULL;
static char *kwlist[] = {"commandBuffer","x","y","z",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &x, &y, &z)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdDispatchIndirect(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* buffer = NULL;
PyObject* offset = NULL;
static char *kwlist[] = {"commandBuffer","buffer","offset",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &buffer, &offset)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdCopyBuffer(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* srcBuffer = NULL;
PyObject* dstBuffer = NULL;
PyObject* regionCount = NULL;
PyObject* pRegions = NULL;
static char *kwlist[] = {"commandBuffer","srcBuffer","dstBuffer","regionCount","pRegions",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &srcBuffer, &dstBuffer, &regionCount, &pRegions)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdCopyImage(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* srcImage = NULL;
PyObject* srcImageLayout = NULL;
PyObject* dstImage = NULL;
PyObject* dstImageLayout = NULL;
PyObject* regionCount = NULL;
PyObject* pRegions = NULL;
static char *kwlist[] = {"commandBuffer","srcImage","srcImageLayout","dstImage","dstImageLayout","regionCount","pRegions",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &commandBuffer, &srcImage, &srcImageLayout, &dstImage, &dstImageLayout, &regionCount, &pRegions)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdBlitImage(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* srcImage = NULL;
PyObject* srcImageLayout = NULL;
PyObject* dstImage = NULL;
PyObject* dstImageLayout = NULL;
PyObject* regionCount = NULL;
PyObject* pRegions = NULL;
PyObject* filter = NULL;
static char *kwlist[] = {"commandBuffer","srcImage","srcImageLayout","dstImage","dstImageLayout","regionCount","pRegions","filter",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &commandBuffer, &srcImage, &srcImageLayout, &dstImage, &dstImageLayout, &regionCount, &pRegions, &filter)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdCopyBufferToImage(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* srcBuffer = NULL;
PyObject* dstImage = NULL;
PyObject* dstImageLayout = NULL;
PyObject* regionCount = NULL;
PyObject* pRegions = NULL;
static char *kwlist[] = {"commandBuffer","srcBuffer","dstImage","dstImageLayout","regionCount","pRegions",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &commandBuffer, &srcBuffer, &dstImage, &dstImageLayout, &regionCount, &pRegions)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdCopyImageToBuffer(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* srcImage = NULL;
PyObject* srcImageLayout = NULL;
PyObject* dstBuffer = NULL;
PyObject* regionCount = NULL;
PyObject* pRegions = NULL;
static char *kwlist[] = {"commandBuffer","srcImage","srcImageLayout","dstBuffer","regionCount","pRegions",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &commandBuffer, &srcImage, &srcImageLayout, &dstBuffer, &regionCount, &pRegions)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdUpdateBuffer(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* dstBuffer = NULL;
PyObject* dstOffset = NULL;
PyObject* dataSize = NULL;
PyObject* pData = NULL;
static char *kwlist[] = {"commandBuffer","dstBuffer","dstOffset","dataSize","pData",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &dstBuffer, &dstOffset, &dataSize, &pData)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdFillBuffer(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* dstBuffer = NULL;
PyObject* dstOffset = NULL;
PyObject* size = NULL;
PyObject* data = NULL;
static char *kwlist[] = {"commandBuffer","dstBuffer","dstOffset","size","data",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &dstBuffer, &dstOffset, &size, &data)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdClearColorImage(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* image = NULL;
PyObject* imageLayout = NULL;
PyObject* pColor = NULL;
PyObject* rangeCount = NULL;
PyObject* pRanges = NULL;
static char *kwlist[] = {"commandBuffer","image","imageLayout","pColor","rangeCount","pRanges",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &commandBuffer, &image, &imageLayout, &pColor, &rangeCount, &pRanges)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdClearDepthStencilImage(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* image = NULL;
PyObject* imageLayout = NULL;
PyObject* pDepthStencil = NULL;
PyObject* rangeCount = NULL;
PyObject* pRanges = NULL;
static char *kwlist[] = {"commandBuffer","image","imageLayout","pDepthStencil","rangeCount","pRanges",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &commandBuffer, &image, &imageLayout, &pDepthStencil, &rangeCount, &pRanges)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdClearAttachments(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* attachmentCount = NULL;
PyObject* pAttachments = NULL;
PyObject* rectCount = NULL;
PyObject* pRects = NULL;
static char *kwlist[] = {"commandBuffer","attachmentCount","pAttachments","rectCount","pRects",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &attachmentCount, &pAttachments, &rectCount, &pRects)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdResolveImage(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* srcImage = NULL;
PyObject* srcImageLayout = NULL;
PyObject* dstImage = NULL;
PyObject* dstImageLayout = NULL;
PyObject* regionCount = NULL;
PyObject* pRegions = NULL;
static char *kwlist[] = {"commandBuffer","srcImage","srcImageLayout","dstImage","dstImageLayout","regionCount","pRegions",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &commandBuffer, &srcImage, &srcImageLayout, &dstImage, &dstImageLayout, &regionCount, &pRegions)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdSetEvent(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* event = NULL;
PyObject* stageMask = NULL;
static char *kwlist[] = {"commandBuffer","event","stageMask",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &event, &stageMask)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdResetEvent(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* event = NULL;
PyObject* stageMask = NULL;
static char *kwlist[] = {"commandBuffer","event","stageMask",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &event, &stageMask)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdWaitEvents(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* eventCount = NULL;
PyObject* pEvents = NULL;
PyObject* srcStageMask = NULL;
PyObject* dstStageMask = NULL;
PyObject* memoryBarrierCount = NULL;
PyObject* pMemoryBarriers = NULL;
PyObject* bufferMemoryBarrierCount = NULL;
PyObject* pBufferMemoryBarriers = NULL;
PyObject* imageMemoryBarrierCount = NULL;
PyObject* pImageMemoryBarriers = NULL;
static char *kwlist[] = {"commandBuffer","eventCount","pEvents","srcStageMask","dstStageMask","memoryBarrierCount","pMemoryBarriers","bufferMemoryBarrierCount","pBufferMemoryBarriers","imageMemoryBarrierCount","pImageMemoryBarriers",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOOOO", kwlist, &commandBuffer, &eventCount, &pEvents, &srcStageMask, &dstStageMask, &memoryBarrierCount, &pMemoryBarriers, &bufferMemoryBarrierCount, &pBufferMemoryBarriers, &imageMemoryBarrierCount, &pImageMemoryBarriers)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdPipelineBarrier(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* srcStageMask = NULL;
PyObject* dstStageMask = NULL;
PyObject* dependencyFlags = NULL;
PyObject* memoryBarrierCount = NULL;
PyObject* pMemoryBarriers = NULL;
PyObject* bufferMemoryBarrierCount = NULL;
PyObject* pBufferMemoryBarriers = NULL;
PyObject* imageMemoryBarrierCount = NULL;
PyObject* pImageMemoryBarriers = NULL;
static char *kwlist[] = {"commandBuffer","srcStageMask","dstStageMask","dependencyFlags","memoryBarrierCount","pMemoryBarriers","bufferMemoryBarrierCount","pBufferMemoryBarriers","imageMemoryBarrierCount","pImageMemoryBarriers",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOOO", kwlist, &commandBuffer, &srcStageMask, &dstStageMask, &dependencyFlags, &memoryBarrierCount, &pMemoryBarriers, &bufferMemoryBarrierCount, &pBufferMemoryBarriers, &imageMemoryBarrierCount, &pImageMemoryBarriers)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdBeginQuery(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* queryPool = NULL;
PyObject* query = NULL;
PyObject* flags = NULL;
static char *kwlist[] = {"commandBuffer","queryPool","query","flags",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &queryPool, &query, &flags)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdEndQuery(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* queryPool = NULL;
PyObject* query = NULL;
static char *kwlist[] = {"commandBuffer","queryPool","query",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &queryPool, &query)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdResetQueryPool(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* queryPool = NULL;
PyObject* firstQuery = NULL;
PyObject* queryCount = NULL;
static char *kwlist[] = {"commandBuffer","queryPool","firstQuery","queryCount",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &queryPool, &firstQuery, &queryCount)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdWriteTimestamp(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* pipelineStage = NULL;
PyObject* queryPool = NULL;
PyObject* query = NULL;
static char *kwlist[] = {"commandBuffer","pipelineStage","queryPool","query",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &pipelineStage, &queryPool, &query)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdCopyQueryPoolResults(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* queryPool = NULL;
PyObject* firstQuery = NULL;
PyObject* queryCount = NULL;
PyObject* dstBuffer = NULL;
PyObject* dstOffset = NULL;
PyObject* stride = NULL;
PyObject* flags = NULL;
static char *kwlist[] = {"commandBuffer","queryPool","firstQuery","queryCount","dstBuffer","dstOffset","stride","flags",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &commandBuffer, &queryPool, &firstQuery, &queryCount, &dstBuffer, &dstOffset, &stride, &flags)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdPushConstants(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* layout = NULL;
PyObject* stageFlags = NULL;
PyObject* offset = NULL;
PyObject* size = NULL;
PyObject* pValues = NULL;
static char *kwlist[] = {"commandBuffer","layout","stageFlags","offset","size","pValues",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &commandBuffer, &layout, &stageFlags, &offset, &size, &pValues)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdBeginRenderPass(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* pRenderPassBegin = NULL;
PyObject* contents = NULL;
static char *kwlist[] = {"commandBuffer","pRenderPassBegin","contents",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &pRenderPassBegin, &contents)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdNextSubpass(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* contents = NULL;
static char *kwlist[] = {"commandBuffer","contents",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &commandBuffer, &contents)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdEndRenderPass(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
static char *kwlist[] = {"commandBuffer",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &commandBuffer)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdExecuteCommands(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* commandBufferCount = NULL;
PyObject* pCommandBuffers = NULL;
static char *kwlist[] = {"commandBuffer","commandBufferCount","pCommandBuffers",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &commandBufferCount, &pCommandBuffers)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateAndroidSurfaceKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* instance = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pSurface = NULL;
static char *kwlist[] = {"instance","pCreateInfo","pAllocator","pSurface",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &instance, &pCreateInfo, &pAllocator, &pSurface)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceDisplayPropertiesKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* pPropertyCount = NULL;
PyObject* pProperties = NULL;
static char *kwlist[] = {"physicalDevice","pPropertyCount","pProperties",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &physicalDevice, &pPropertyCount, &pProperties)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* pPropertyCount = NULL;
PyObject* pProperties = NULL;
static char *kwlist[] = {"physicalDevice","pPropertyCount","pProperties",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &physicalDevice, &pPropertyCount, &pProperties)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetDisplayPlaneSupportedDisplaysKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* planeIndex = NULL;
PyObject* pDisplayCount = NULL;
PyObject* pDisplays = NULL;
static char *kwlist[] = {"physicalDevice","planeIndex","pDisplayCount","pDisplays",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &physicalDevice, &planeIndex, &pDisplayCount, &pDisplays)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetDisplayModePropertiesKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* display = NULL;
PyObject* pPropertyCount = NULL;
PyObject* pProperties = NULL;
static char *kwlist[] = {"physicalDevice","display","pPropertyCount","pProperties",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &physicalDevice, &display, &pPropertyCount, &pProperties)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateDisplayModeKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* display = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pMode = NULL;
static char *kwlist[] = {"physicalDevice","display","pCreateInfo","pAllocator","pMode",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &physicalDevice, &display, &pCreateInfo, &pAllocator, &pMode)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetDisplayPlaneCapabilitiesKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* mode = NULL;
PyObject* planeIndex = NULL;
PyObject* pCapabilities = NULL;
static char *kwlist[] = {"physicalDevice","mode","planeIndex","pCapabilities",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &physicalDevice, &mode, &planeIndex, &pCapabilities)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateDisplayPlaneSurfaceKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* instance = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pSurface = NULL;
static char *kwlist[] = {"instance","pCreateInfo","pAllocator","pSurface",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &instance, &pCreateInfo, &pAllocator, &pSurface)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateSharedSwapchainsKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* swapchainCount = NULL;
PyObject* pCreateInfos = NULL;
PyObject* pAllocator = NULL;
PyObject* pSwapchains = NULL;
static char *kwlist[] = {"device","swapchainCount","pCreateInfos","pAllocator","pSwapchains",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &device, &swapchainCount, &pCreateInfos, &pAllocator, &pSwapchains)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateMirSurfaceKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* instance = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pSurface = NULL;
static char *kwlist[] = {"instance","pCreateInfo","pAllocator","pSurface",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &instance, &pCreateInfo, &pAllocator, &pSurface)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceMirPresentationSupportKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* queueFamilyIndex = NULL;
PyObject* connection = NULL;
static char *kwlist[] = {"physicalDevice","queueFamilyIndex","connection",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &physicalDevice, &queueFamilyIndex, &connection)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroySurfaceKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* instance = NULL;
PyObject* surface = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"instance","surface","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &instance, &surface, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceSurfaceSupportKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* queueFamilyIndex = NULL;
PyObject* surface = NULL;
PyObject* pSupported = NULL;
static char *kwlist[] = {"physicalDevice","queueFamilyIndex","surface","pSupported",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &physicalDevice, &queueFamilyIndex, &surface, &pSupported)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* surface = NULL;
PyObject* pSurfaceCapabilities = NULL;
static char *kwlist[] = {"physicalDevice","surface","pSurfaceCapabilities",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &physicalDevice, &surface, &pSurfaceCapabilities)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceSurfaceFormatsKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* surface = NULL;
PyObject* pSurfaceFormatCount = NULL;
PyObject* pSurfaceFormats = NULL;
static char *kwlist[] = {"physicalDevice","surface","pSurfaceFormatCount","pSurfaceFormats",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &physicalDevice, &surface, &pSurfaceFormatCount, &pSurfaceFormats)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceSurfacePresentModesKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* surface = NULL;
PyObject* pPresentModeCount = NULL;
PyObject* pPresentModes = NULL;
static char *kwlist[] = {"physicalDevice","surface","pPresentModeCount","pPresentModes",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &physicalDevice, &surface, &pPresentModeCount, &pPresentModes)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateSwapchainKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pSwapchain = NULL;
static char *kwlist[] = {"device","pCreateInfo","pAllocator","pSwapchain",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pCreateInfo, &pAllocator, &pSwapchain)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroySwapchainKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* swapchain = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"device","swapchain","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &swapchain, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetSwapchainImagesKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* swapchain = NULL;
PyObject* pSwapchainImageCount = NULL;
PyObject* pSwapchainImages = NULL;
static char *kwlist[] = {"device","swapchain","pSwapchainImageCount","pSwapchainImages",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &swapchain, &pSwapchainImageCount, &pSwapchainImages)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkAcquireNextImageKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* swapchain = NULL;
PyObject* timeout = NULL;
PyObject* semaphore = NULL;
PyObject* fence = NULL;
PyObject* pImageIndex = NULL;
static char *kwlist[] = {"device","swapchain","timeout","semaphore","fence","pImageIndex",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &device, &swapchain, &timeout, &semaphore, &fence, &pImageIndex)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkQueuePresentKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* queue = NULL;
PyObject* pPresentInfo = NULL;
static char *kwlist[] = {"queue","pPresentInfo",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &queue, &pPresentInfo)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateWaylandSurfaceKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* instance = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pSurface = NULL;
static char *kwlist[] = {"instance","pCreateInfo","pAllocator","pSurface",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &instance, &pCreateInfo, &pAllocator, &pSurface)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceWaylandPresentationSupportKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* queueFamilyIndex = NULL;
PyObject* display = NULL;
static char *kwlist[] = {"physicalDevice","queueFamilyIndex","display",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &physicalDevice, &queueFamilyIndex, &display)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateWin32SurfaceKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* instance = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pSurface = NULL;
static char *kwlist[] = {"instance","pCreateInfo","pAllocator","pSurface",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &instance, &pCreateInfo, &pAllocator, &pSurface)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceWin32PresentationSupportKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* queueFamilyIndex = NULL;
static char *kwlist[] = {"physicalDevice","queueFamilyIndex",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &physicalDevice, &queueFamilyIndex)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateXlibSurfaceKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* instance = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pSurface = NULL;
static char *kwlist[] = {"instance","pCreateInfo","pAllocator","pSurface",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &instance, &pCreateInfo, &pAllocator, &pSurface)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceXlibPresentationSupportKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* queueFamilyIndex = NULL;
PyObject* dpy = NULL;
PyObject* visualID = NULL;
static char *kwlist[] = {"physicalDevice","queueFamilyIndex","dpy","visualID",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &physicalDevice, &queueFamilyIndex, &dpy, &visualID)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateXcbSurfaceKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* instance = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pSurface = NULL;
static char *kwlist[] = {"instance","pCreateInfo","pAllocator","pSurface",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &instance, &pCreateInfo, &pAllocator, &pSurface)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceXcbPresentationSupportKHR(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* queueFamilyIndex = NULL;
PyObject* connection = NULL;
PyObject* visual_id = NULL;
static char *kwlist[] = {"physicalDevice","queueFamilyIndex","connection","visual_id",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &physicalDevice, &queueFamilyIndex, &connection, &visual_id)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCreateDebugReportCallbackEXT(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* instance = NULL;
PyObject* pCreateInfo = NULL;
PyObject* pAllocator = NULL;
PyObject* pCallback = NULL;
static char *kwlist[] = {"instance","pCreateInfo","pAllocator","pCallback",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &instance, &pCreateInfo, &pAllocator, &pCallback)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDestroyDebugReportCallbackEXT(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* instance = NULL;
PyObject* callback = NULL;
PyObject* pAllocator = NULL;
static char *kwlist[] = {"instance","callback","pAllocator",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &instance, &callback, &pAllocator)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDebugReportMessageEXT(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* instance = NULL;
PyObject* flags = NULL;
PyObject* objectType = NULL;
PyObject* object = NULL;
PyObject* location = NULL;
PyObject* messageCode = NULL;
PyObject* pLayerPrefix = NULL;
PyObject* pMessage = NULL;
static char *kwlist[] = {"instance","flags","objectType","object","location","messageCode","pLayerPrefix","pMessage",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &instance, &flags, &objectType, &object, &location, &messageCode, &pLayerPrefix, &pMessage)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDebugMarkerSetObjectNameEXT(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pNameInfo = NULL;
static char *kwlist[] = {"device","pNameInfo",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pNameInfo)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkDebugMarkerSetObjectTagEXT(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* pTagInfo = NULL;
static char *kwlist[] = {"device","pTagInfo",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pTagInfo)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdDebugMarkerBeginEXT(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* pMarkerInfo = NULL;
static char *kwlist[] = {"commandBuffer","pMarkerInfo",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &commandBuffer, &pMarkerInfo)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdDebugMarkerEndEXT(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
static char *kwlist[] = {"commandBuffer",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &commandBuffer)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdDebugMarkerInsertEXT(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* pMarkerInfo = NULL;
static char *kwlist[] = {"commandBuffer","pMarkerInfo",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &commandBuffer, &pMarkerInfo)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* physicalDevice = NULL;
PyObject* format = NULL;
PyObject* type = NULL;
PyObject* tiling = NULL;
PyObject* usage = NULL;
PyObject* flags = NULL;
PyObject* externalHandleType = NULL;
PyObject* pExternalImageFormatProperties = NULL;
static char *kwlist[] = {"physicalDevice","format","type","tiling","usage","flags","externalHandleType","pExternalImageFormatProperties",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &physicalDevice, &format, &type, &tiling, &usage, &flags, &externalHandleType, &pExternalImageFormatProperties)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkGetMemoryWin32HandleNV(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* device = NULL;
PyObject* memory = NULL;
PyObject* handleType = NULL;
PyObject* pHandle = NULL;
static char *kwlist[] = {"device","memory","handleType","pHandle",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &memory, &handleType, &pHandle)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdDrawIndirectCountAMD(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* buffer = NULL;
PyObject* offset = NULL;
PyObject* countBuffer = NULL;
PyObject* countBufferOffset = NULL;
PyObject* maxDrawCount = NULL;
PyObject* stride = NULL;
static char *kwlist[] = {"commandBuffer","buffer","offset","countBuffer","countBufferOffset","maxDrawCount","stride",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &commandBuffer, &buffer, &offset, &countBuffer, &countBufferOffset, &maxDrawCount, &stride)) return NULL;

            return Py_None; }
            
            static PyObject* PyvkCmdDrawIndexedIndirectCountAMD(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
            PyObject* commandBuffer = NULL;
PyObject* buffer = NULL;
PyObject* offset = NULL;
PyObject* countBuffer = NULL;
PyObject* countBufferOffset = NULL;
PyObject* maxDrawCount = NULL;
PyObject* stride = NULL;
static char *kwlist[] = {"commandBuffer","buffer","offset","countBuffer","countBufferOffset","maxDrawCount","stride",NULL};
if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &commandBuffer, &buffer, &offset, &countBuffer, &countBufferOffset, &maxDrawCount, &stride)) return NULL;

            return Py_None; }
            
static PyMethodDef VulkanMethods[] = {
{"load_sdk", load_sdk, METH_NOARGS, "Load SDK"},
{"VkShaderModule", PyHandle_VkShaderModule, METH_NOARGS, "Handle"},
{"VkImageView", PyHandle_VkImageView, METH_NOARGS, "Handle"},
{"VkBufferView", PyHandle_VkBufferView, METH_NOARGS, "Handle"},
{"VkPhysicalDevice", PyHandle_VkPhysicalDevice, METH_NOARGS, "Handle"},
{"VkBuffer", PyHandle_VkBuffer, METH_NOARGS, "Handle"},
{"VkEvent", PyHandle_VkEvent, METH_NOARGS, "Handle"},
{"VkQueryPool", PyHandle_VkQueryPool, METH_NOARGS, "Handle"},
{"VkSampler", PyHandle_VkSampler, METH_NOARGS, "Handle"},
{"VkCommandBuffer", PyHandle_VkCommandBuffer, METH_NOARGS, "Handle"},
{"VkDescriptorSet", PyHandle_VkDescriptorSet, METH_NOARGS, "Handle"},
{"VkDeviceMemory", PyHandle_VkDeviceMemory, METH_NOARGS, "Handle"},
{"VkCommandPool", PyHandle_VkCommandPool, METH_NOARGS, "Handle"},
{"VkSurfaceKHR", PyHandle_VkSurfaceKHR, METH_NOARGS, "Handle"},
{"VkPipelineCache", PyHandle_VkPipelineCache, METH_NOARGS, "Handle"},
{"VkInstance", PyHandle_VkInstance, METH_NOARGS, "Handle"},
{"VkDebugReportCallbackEXT", PyHandle_VkDebugReportCallbackEXT, METH_NOARGS, "Handle"},
{"VkFence", PyHandle_VkFence, METH_NOARGS, "Handle"},
{"VkFramebuffer", PyHandle_VkFramebuffer, METH_NOARGS, "Handle"},
{"VkDisplayModeKHR", PyHandle_VkDisplayModeKHR, METH_NOARGS, "Handle"},
{"VkDescriptorPool", PyHandle_VkDescriptorPool, METH_NOARGS, "Handle"},
{"VkSwapchainKHR", PyHandle_VkSwapchainKHR, METH_NOARGS, "Handle"},
{"VkDescriptorSetLayout", PyHandle_VkDescriptorSetLayout, METH_NOARGS, "Handle"},
{"VkImage", PyHandle_VkImage, METH_NOARGS, "Handle"},
{"VkSemaphore", PyHandle_VkSemaphore, METH_NOARGS, "Handle"},
{"VkDevice", PyHandle_VkDevice, METH_NOARGS, "Handle"},
{"VkDisplayKHR", PyHandle_VkDisplayKHR, METH_NOARGS, "Handle"},
{"VkQueue", PyHandle_VkQueue, METH_NOARGS, "Handle"},
{"VkPipeline", PyHandle_VkPipeline, METH_NOARGS, "Handle"},
{"VkPipelineLayout", PyHandle_VkPipelineLayout, METH_NOARGS, "Handle"},
{"VkRenderPass", PyHandle_VkRenderPass, METH_NOARGS, "Handle"},
{"vkCreateInstance", (PyCFunction) PyvkCreateInstance, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyInstance", (PyCFunction) PyvkDestroyInstance, METH_VARARGS | METH_KEYWORDS, ""},
{"vkEnumeratePhysicalDevices", (PyCFunction) PyvkEnumeratePhysicalDevices, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceProperties", (PyCFunction) PyvkGetPhysicalDeviceProperties, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceQueueFamilyProperties", (PyCFunction) PyvkGetPhysicalDeviceQueueFamilyProperties, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceMemoryProperties", (PyCFunction) PyvkGetPhysicalDeviceMemoryProperties, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceFeatures", (PyCFunction) PyvkGetPhysicalDeviceFeatures, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceFormatProperties", (PyCFunction) PyvkGetPhysicalDeviceFormatProperties, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceImageFormatProperties", (PyCFunction) PyvkGetPhysicalDeviceImageFormatProperties, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateDevice", (PyCFunction) PyvkCreateDevice, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyDevice", (PyCFunction) PyvkDestroyDevice, METH_VARARGS | METH_KEYWORDS, ""},
{"vkEnumerateInstanceLayerProperties", (PyCFunction) PyvkEnumerateInstanceLayerProperties, METH_VARARGS | METH_KEYWORDS, ""},
{"vkEnumerateInstanceExtensionProperties", (PyCFunction) PyvkEnumerateInstanceExtensionProperties, METH_VARARGS | METH_KEYWORDS, ""},
{"vkEnumerateDeviceLayerProperties", (PyCFunction) PyvkEnumerateDeviceLayerProperties, METH_VARARGS | METH_KEYWORDS, ""},
{"vkEnumerateDeviceExtensionProperties", (PyCFunction) PyvkEnumerateDeviceExtensionProperties, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetDeviceQueue", (PyCFunction) PyvkGetDeviceQueue, METH_VARARGS | METH_KEYWORDS, ""},
{"vkQueueSubmit", (PyCFunction) PyvkQueueSubmit, METH_VARARGS | METH_KEYWORDS, ""},
{"vkQueueWaitIdle", (PyCFunction) PyvkQueueWaitIdle, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDeviceWaitIdle", (PyCFunction) PyvkDeviceWaitIdle, METH_VARARGS | METH_KEYWORDS, ""},
{"vkAllocateMemory", (PyCFunction) PyvkAllocateMemory, METH_VARARGS | METH_KEYWORDS, ""},
{"vkFreeMemory", (PyCFunction) PyvkFreeMemory, METH_VARARGS | METH_KEYWORDS, ""},
{"vkMapMemory", (PyCFunction) PyvkMapMemory, METH_VARARGS | METH_KEYWORDS, ""},
{"vkUnmapMemory", (PyCFunction) PyvkUnmapMemory, METH_VARARGS | METH_KEYWORDS, ""},
{"vkFlushMappedMemoryRanges", (PyCFunction) PyvkFlushMappedMemoryRanges, METH_VARARGS | METH_KEYWORDS, ""},
{"vkInvalidateMappedMemoryRanges", (PyCFunction) PyvkInvalidateMappedMemoryRanges, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetDeviceMemoryCommitment", (PyCFunction) PyvkGetDeviceMemoryCommitment, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetBufferMemoryRequirements", (PyCFunction) PyvkGetBufferMemoryRequirements, METH_VARARGS | METH_KEYWORDS, ""},
{"vkBindBufferMemory", (PyCFunction) PyvkBindBufferMemory, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetImageMemoryRequirements", (PyCFunction) PyvkGetImageMemoryRequirements, METH_VARARGS | METH_KEYWORDS, ""},
{"vkBindImageMemory", (PyCFunction) PyvkBindImageMemory, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetImageSparseMemoryRequirements", (PyCFunction) PyvkGetImageSparseMemoryRequirements, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceSparseImageFormatProperties", (PyCFunction) PyvkGetPhysicalDeviceSparseImageFormatProperties, METH_VARARGS | METH_KEYWORDS, ""},
{"vkQueueBindSparse", (PyCFunction) PyvkQueueBindSparse, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateFence", (PyCFunction) PyvkCreateFence, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyFence", (PyCFunction) PyvkDestroyFence, METH_VARARGS | METH_KEYWORDS, ""},
{"vkResetFences", (PyCFunction) PyvkResetFences, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetFenceStatus", (PyCFunction) PyvkGetFenceStatus, METH_VARARGS | METH_KEYWORDS, ""},
{"vkWaitForFences", (PyCFunction) PyvkWaitForFences, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateSemaphore", (PyCFunction) PyvkCreateSemaphore, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroySemaphore", (PyCFunction) PyvkDestroySemaphore, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateEvent", (PyCFunction) PyvkCreateEvent, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyEvent", (PyCFunction) PyvkDestroyEvent, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetEventStatus", (PyCFunction) PyvkGetEventStatus, METH_VARARGS | METH_KEYWORDS, ""},
{"vkSetEvent", (PyCFunction) PyvkSetEvent, METH_VARARGS | METH_KEYWORDS, ""},
{"vkResetEvent", (PyCFunction) PyvkResetEvent, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateQueryPool", (PyCFunction) PyvkCreateQueryPool, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyQueryPool", (PyCFunction) PyvkDestroyQueryPool, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetQueryPoolResults", (PyCFunction) PyvkGetQueryPoolResults, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateBuffer", (PyCFunction) PyvkCreateBuffer, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyBuffer", (PyCFunction) PyvkDestroyBuffer, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateBufferView", (PyCFunction) PyvkCreateBufferView, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyBufferView", (PyCFunction) PyvkDestroyBufferView, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateImage", (PyCFunction) PyvkCreateImage, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyImage", (PyCFunction) PyvkDestroyImage, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetImageSubresourceLayout", (PyCFunction) PyvkGetImageSubresourceLayout, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateImageView", (PyCFunction) PyvkCreateImageView, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyImageView", (PyCFunction) PyvkDestroyImageView, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateShaderModule", (PyCFunction) PyvkCreateShaderModule, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyShaderModule", (PyCFunction) PyvkDestroyShaderModule, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreatePipelineCache", (PyCFunction) PyvkCreatePipelineCache, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyPipelineCache", (PyCFunction) PyvkDestroyPipelineCache, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPipelineCacheData", (PyCFunction) PyvkGetPipelineCacheData, METH_VARARGS | METH_KEYWORDS, ""},
{"vkMergePipelineCaches", (PyCFunction) PyvkMergePipelineCaches, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateGraphicsPipelines", (PyCFunction) PyvkCreateGraphicsPipelines, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateComputePipelines", (PyCFunction) PyvkCreateComputePipelines, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyPipeline", (PyCFunction) PyvkDestroyPipeline, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreatePipelineLayout", (PyCFunction) PyvkCreatePipelineLayout, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyPipelineLayout", (PyCFunction) PyvkDestroyPipelineLayout, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateSampler", (PyCFunction) PyvkCreateSampler, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroySampler", (PyCFunction) PyvkDestroySampler, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateDescriptorSetLayout", (PyCFunction) PyvkCreateDescriptorSetLayout, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyDescriptorSetLayout", (PyCFunction) PyvkDestroyDescriptorSetLayout, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateDescriptorPool", (PyCFunction) PyvkCreateDescriptorPool, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyDescriptorPool", (PyCFunction) PyvkDestroyDescriptorPool, METH_VARARGS | METH_KEYWORDS, ""},
{"vkResetDescriptorPool", (PyCFunction) PyvkResetDescriptorPool, METH_VARARGS | METH_KEYWORDS, ""},
{"vkAllocateDescriptorSets", (PyCFunction) PyvkAllocateDescriptorSets, METH_VARARGS | METH_KEYWORDS, ""},
{"vkFreeDescriptorSets", (PyCFunction) PyvkFreeDescriptorSets, METH_VARARGS | METH_KEYWORDS, ""},
{"vkUpdateDescriptorSets", (PyCFunction) PyvkUpdateDescriptorSets, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateFramebuffer", (PyCFunction) PyvkCreateFramebuffer, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyFramebuffer", (PyCFunction) PyvkDestroyFramebuffer, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateRenderPass", (PyCFunction) PyvkCreateRenderPass, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyRenderPass", (PyCFunction) PyvkDestroyRenderPass, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetRenderAreaGranularity", (PyCFunction) PyvkGetRenderAreaGranularity, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateCommandPool", (PyCFunction) PyvkCreateCommandPool, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyCommandPool", (PyCFunction) PyvkDestroyCommandPool, METH_VARARGS | METH_KEYWORDS, ""},
{"vkResetCommandPool", (PyCFunction) PyvkResetCommandPool, METH_VARARGS | METH_KEYWORDS, ""},
{"vkAllocateCommandBuffers", (PyCFunction) PyvkAllocateCommandBuffers, METH_VARARGS | METH_KEYWORDS, ""},
{"vkFreeCommandBuffers", (PyCFunction) PyvkFreeCommandBuffers, METH_VARARGS | METH_KEYWORDS, ""},
{"vkBeginCommandBuffer", (PyCFunction) PyvkBeginCommandBuffer, METH_VARARGS | METH_KEYWORDS, ""},
{"vkEndCommandBuffer", (PyCFunction) PyvkEndCommandBuffer, METH_VARARGS | METH_KEYWORDS, ""},
{"vkResetCommandBuffer", (PyCFunction) PyvkResetCommandBuffer, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdBindPipeline", (PyCFunction) PyvkCmdBindPipeline, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdSetViewport", (PyCFunction) PyvkCmdSetViewport, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdSetScissor", (PyCFunction) PyvkCmdSetScissor, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdSetLineWidth", (PyCFunction) PyvkCmdSetLineWidth, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdSetDepthBias", (PyCFunction) PyvkCmdSetDepthBias, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdSetBlendConstants", (PyCFunction) PyvkCmdSetBlendConstants, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdSetDepthBounds", (PyCFunction) PyvkCmdSetDepthBounds, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdSetStencilCompareMask", (PyCFunction) PyvkCmdSetStencilCompareMask, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdSetStencilWriteMask", (PyCFunction) PyvkCmdSetStencilWriteMask, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdSetStencilReference", (PyCFunction) PyvkCmdSetStencilReference, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdBindDescriptorSets", (PyCFunction) PyvkCmdBindDescriptorSets, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdBindIndexBuffer", (PyCFunction) PyvkCmdBindIndexBuffer, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdBindVertexBuffers", (PyCFunction) PyvkCmdBindVertexBuffers, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdDraw", (PyCFunction) PyvkCmdDraw, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdDrawIndexed", (PyCFunction) PyvkCmdDrawIndexed, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdDrawIndirect", (PyCFunction) PyvkCmdDrawIndirect, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdDrawIndexedIndirect", (PyCFunction) PyvkCmdDrawIndexedIndirect, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdDispatch", (PyCFunction) PyvkCmdDispatch, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdDispatchIndirect", (PyCFunction) PyvkCmdDispatchIndirect, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdCopyBuffer", (PyCFunction) PyvkCmdCopyBuffer, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdCopyImage", (PyCFunction) PyvkCmdCopyImage, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdBlitImage", (PyCFunction) PyvkCmdBlitImage, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdCopyBufferToImage", (PyCFunction) PyvkCmdCopyBufferToImage, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdCopyImageToBuffer", (PyCFunction) PyvkCmdCopyImageToBuffer, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdUpdateBuffer", (PyCFunction) PyvkCmdUpdateBuffer, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdFillBuffer", (PyCFunction) PyvkCmdFillBuffer, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdClearColorImage", (PyCFunction) PyvkCmdClearColorImage, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdClearDepthStencilImage", (PyCFunction) PyvkCmdClearDepthStencilImage, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdClearAttachments", (PyCFunction) PyvkCmdClearAttachments, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdResolveImage", (PyCFunction) PyvkCmdResolveImage, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdSetEvent", (PyCFunction) PyvkCmdSetEvent, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdResetEvent", (PyCFunction) PyvkCmdResetEvent, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdWaitEvents", (PyCFunction) PyvkCmdWaitEvents, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdPipelineBarrier", (PyCFunction) PyvkCmdPipelineBarrier, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdBeginQuery", (PyCFunction) PyvkCmdBeginQuery, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdEndQuery", (PyCFunction) PyvkCmdEndQuery, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdResetQueryPool", (PyCFunction) PyvkCmdResetQueryPool, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdWriteTimestamp", (PyCFunction) PyvkCmdWriteTimestamp, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdCopyQueryPoolResults", (PyCFunction) PyvkCmdCopyQueryPoolResults, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdPushConstants", (PyCFunction) PyvkCmdPushConstants, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdBeginRenderPass", (PyCFunction) PyvkCmdBeginRenderPass, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdNextSubpass", (PyCFunction) PyvkCmdNextSubpass, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdEndRenderPass", (PyCFunction) PyvkCmdEndRenderPass, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdExecuteCommands", (PyCFunction) PyvkCmdExecuteCommands, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateAndroidSurfaceKHR", (PyCFunction) PyvkCreateAndroidSurfaceKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceDisplayPropertiesKHR", (PyCFunction) PyvkGetPhysicalDeviceDisplayPropertiesKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceDisplayPlanePropertiesKHR", (PyCFunction) PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetDisplayPlaneSupportedDisplaysKHR", (PyCFunction) PyvkGetDisplayPlaneSupportedDisplaysKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetDisplayModePropertiesKHR", (PyCFunction) PyvkGetDisplayModePropertiesKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateDisplayModeKHR", (PyCFunction) PyvkCreateDisplayModeKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetDisplayPlaneCapabilitiesKHR", (PyCFunction) PyvkGetDisplayPlaneCapabilitiesKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateDisplayPlaneSurfaceKHR", (PyCFunction) PyvkCreateDisplayPlaneSurfaceKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateSharedSwapchainsKHR", (PyCFunction) PyvkCreateSharedSwapchainsKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateMirSurfaceKHR", (PyCFunction) PyvkCreateMirSurfaceKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceMirPresentationSupportKHR", (PyCFunction) PyvkGetPhysicalDeviceMirPresentationSupportKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroySurfaceKHR", (PyCFunction) PyvkDestroySurfaceKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceSurfaceSupportKHR", (PyCFunction) PyvkGetPhysicalDeviceSurfaceSupportKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceSurfaceCapabilitiesKHR", (PyCFunction) PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceSurfaceFormatsKHR", (PyCFunction) PyvkGetPhysicalDeviceSurfaceFormatsKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceSurfacePresentModesKHR", (PyCFunction) PyvkGetPhysicalDeviceSurfacePresentModesKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateSwapchainKHR", (PyCFunction) PyvkCreateSwapchainKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroySwapchainKHR", (PyCFunction) PyvkDestroySwapchainKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetSwapchainImagesKHR", (PyCFunction) PyvkGetSwapchainImagesKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkAcquireNextImageKHR", (PyCFunction) PyvkAcquireNextImageKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkQueuePresentKHR", (PyCFunction) PyvkQueuePresentKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateWaylandSurfaceKHR", (PyCFunction) PyvkCreateWaylandSurfaceKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceWaylandPresentationSupportKHR", (PyCFunction) PyvkGetPhysicalDeviceWaylandPresentationSupportKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateWin32SurfaceKHR", (PyCFunction) PyvkCreateWin32SurfaceKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceWin32PresentationSupportKHR", (PyCFunction) PyvkGetPhysicalDeviceWin32PresentationSupportKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateXlibSurfaceKHR", (PyCFunction) PyvkCreateXlibSurfaceKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceXlibPresentationSupportKHR", (PyCFunction) PyvkGetPhysicalDeviceXlibPresentationSupportKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateXcbSurfaceKHR", (PyCFunction) PyvkCreateXcbSurfaceKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceXcbPresentationSupportKHR", (PyCFunction) PyvkGetPhysicalDeviceXcbPresentationSupportKHR, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCreateDebugReportCallbackEXT", (PyCFunction) PyvkCreateDebugReportCallbackEXT, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDestroyDebugReportCallbackEXT", (PyCFunction) PyvkDestroyDebugReportCallbackEXT, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDebugReportMessageEXT", (PyCFunction) PyvkDebugReportMessageEXT, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDebugMarkerSetObjectNameEXT", (PyCFunction) PyvkDebugMarkerSetObjectNameEXT, METH_VARARGS | METH_KEYWORDS, ""},
{"vkDebugMarkerSetObjectTagEXT", (PyCFunction) PyvkDebugMarkerSetObjectTagEXT, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdDebugMarkerBeginEXT", (PyCFunction) PyvkCmdDebugMarkerBeginEXT, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdDebugMarkerEndEXT", (PyCFunction) PyvkCmdDebugMarkerEndEXT, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdDebugMarkerInsertEXT", (PyCFunction) PyvkCmdDebugMarkerInsertEXT, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetPhysicalDeviceExternalImageFormatPropertiesNV", (PyCFunction) PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV, METH_VARARGS | METH_KEYWORDS, ""},
{"vkGetMemoryWin32HandleNV", (PyCFunction) PyvkGetMemoryWin32HandleNV, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdDrawIndirectCountAMD", (PyCFunction) PyvkCmdDrawIndirectCountAMD, METH_VARARGS | METH_KEYWORDS, ""},
{"vkCmdDrawIndexedIndirectCountAMD", (PyCFunction) PyvkCmdDrawIndexedIndirectCountAMD, METH_VARARGS | METH_KEYWORDS, ""},

{NULL, NULL, 0, NULL} };

        static struct PyModuleDef vulkanmodule = {
            PyModuleDef_HEAD_INIT, "vulkan", "Vulkan module", -1, VulkanMethods};
        

PyMODINIT_FUNC PyInit_vulkan(void) {

        PyObject* module;
        module = PyModule_Create(&vulkanmodule);
        if (module == NULL) return NULL;
    

PyModule_AddIntConstant(module, "VK_MAX_PHYSICAL_DEVICE_NAME_SIZE", 256);
PyModule_AddIntConstant(module, "VK_UUID_SIZE", 16);
PyModule_AddIntConstant(module, "VK_MAX_EXTENSION_NAME_SIZE", 256);
PyModule_AddIntConstant(module, "VK_MAX_DESCRIPTION_SIZE", 256);
PyModule_AddIntConstant(module, "VK_MAX_MEMORY_TYPES", 32);
PyModule_AddIntConstant(module, "VK_MAX_MEMORY_HEAPS", 16);
PyModule_AddIntConstant(module, "VK_LOD_CLAMP_NONE", 1000.0f);
PyModule_AddIntConstant(module, "VK_REMAINING_MIP_LEVELS", (~0U));
PyModule_AddIntConstant(module, "VK_REMAINING_ARRAY_LAYERS", (~0U));
PyModule_AddIntConstant(module, "VK_WHOLE_SIZE", (~0ULL));
PyModule_AddIntConstant(module, "VK_ATTACHMENT_UNUSED", (~0U));
PyModule_AddIntConstant(module, "VK_TRUE", 1);
PyModule_AddIntConstant(module, "VK_FALSE", 0);
PyModule_AddIntConstant(module, "VK_QUEUE_FAMILY_IGNORED", (~0U));
PyModule_AddIntConstant(module, "VK_SUBPASS_EXTERNAL", (~0U));
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_UNDEFINED", 0);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_GENERAL", 1);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL", 2);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL", 3);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL", 4);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL", 5);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL", 6);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL", 7);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_PREINITIALIZED", 8);
PyModule_AddIntConstant(module, "VK_ATTACHMENT_LOAD_OP_LOAD", 0);
PyModule_AddIntConstant(module, "VK_ATTACHMENT_LOAD_OP_CLEAR", 1);
PyModule_AddIntConstant(module, "VK_ATTACHMENT_LOAD_OP_DONT_CARE", 2);
PyModule_AddIntConstant(module, "VK_ATTACHMENT_STORE_OP_STORE", 0);
PyModule_AddIntConstant(module, "VK_ATTACHMENT_STORE_OP_DONT_CARE", 1);
PyModule_AddIntConstant(module, "VK_IMAGE_TYPE_1D", 0);
PyModule_AddIntConstant(module, "VK_IMAGE_TYPE_2D", 1);
PyModule_AddIntConstant(module, "VK_IMAGE_TYPE_3D", 2);
PyModule_AddIntConstant(module, "VK_IMAGE_TILING_OPTIMAL", 0);
PyModule_AddIntConstant(module, "VK_IMAGE_TILING_LINEAR", 1);
PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_1D", 0);
PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_2D", 1);
PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_3D", 2);
PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_CUBE", 3);
PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_1D_ARRAY", 4);
PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_2D_ARRAY", 5);
PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", 6);
PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_LEVEL_PRIMARY", 0);
PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_LEVEL_SECONDARY", 1);
PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_IDENTITY", 0);
PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_ZERO", 1);
PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_ONE", 2);
PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_R", 3);
PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_G", 4);
PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_B", 5);
PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_A", 6);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_SAMPLER", 0);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER", 1);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE", 2);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE", 3);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER", 4);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER", 5);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER", 6);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER", 7);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC", 8);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC", 9);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT", 10);
PyModule_AddIntConstant(module, "VK_QUERY_TYPE_OCCLUSION", 0);
PyModule_AddIntConstant(module, "VK_QUERY_TYPE_PIPELINE_STATISTICS", 1);
PyModule_AddIntConstant(module, "VK_QUERY_TYPE_TIMESTAMP", 2);
PyModule_AddIntConstant(module, "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK", 0);
PyModule_AddIntConstant(module, "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK", 1);
PyModule_AddIntConstant(module, "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK", 2);
PyModule_AddIntConstant(module, "VK_BORDER_COLOR_INT_OPAQUE_BLACK", 3);
PyModule_AddIntConstant(module, "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE", 4);
PyModule_AddIntConstant(module, "VK_BORDER_COLOR_INT_OPAQUE_WHITE", 5);
PyModule_AddIntConstant(module, "VK_PIPELINE_BIND_POINT_GRAPHICS", 0);
PyModule_AddIntConstant(module, "VK_PIPELINE_BIND_POINT_COMPUTE", 1);
PyModule_AddIntConstant(module, "VK_PIPELINE_CACHE_HEADER_VERSION_ONE", 1);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_POINT_LIST", 0);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_LIST", 1);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP", 2);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST", 3);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP", 4);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN", 5);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY", 6);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY", 7);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY", 8);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY", 9);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST", 10);
PyModule_AddIntConstant(module, "VK_SHARING_MODE_EXCLUSIVE", 0);
PyModule_AddIntConstant(module, "VK_SHARING_MODE_CONCURRENT", 1);
PyModule_AddIntConstant(module, "VK_INDEX_TYPE_UINT16", 0);
PyModule_AddIntConstant(module, "VK_INDEX_TYPE_UINT32", 1);
PyModule_AddIntConstant(module, "VK_FILTER_NEAREST", 0);
PyModule_AddIntConstant(module, "VK_FILTER_LINEAR", 1);
PyModule_AddIntConstant(module, "VK_SAMPLER_MIPMAP_MODE_NEAREST", 0);
PyModule_AddIntConstant(module, "VK_SAMPLER_MIPMAP_MODE_LINEAR", 1);
PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_REPEAT", 0);
PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT", 1);
PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", 2);
PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER", 3);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_NEVER", 0);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_LESS", 1);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_EQUAL", 2);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_LESS_OR_EQUAL", 3);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_GREATER", 4);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_NOT_EQUAL", 5);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_GREATER_OR_EQUAL", 6);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_ALWAYS", 7);
PyModule_AddIntConstant(module, "VK_POLYGON_MODE_FILL", 0);
PyModule_AddIntConstant(module, "VK_POLYGON_MODE_LINE", 1);
PyModule_AddIntConstant(module, "VK_POLYGON_MODE_POINT", 2);
PyModule_AddIntConstant(module, "VK_CULL_MODE_NONE", 0);
PyModule_AddIntConstant(module, "VK_CULL_MODE_FRONT_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_CULL_MODE_BACK_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_CULL_MODE_FRONT_AND_BACK", 0x00000003);
PyModule_AddIntConstant(module, "VK_FRONT_FACE_COUNTER_CLOCKWISE", 0);
PyModule_AddIntConstant(module, "VK_FRONT_FACE_CLOCKWISE", 1);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ZERO", 0);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE", 1);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC_COLOR", 2);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR", 3);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_DST_COLOR", 4);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR", 5);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC_ALPHA", 6);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA", 7);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_DST_ALPHA", 8);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA", 9);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_CONSTANT_COLOR", 10);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR", 11);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_CONSTANT_ALPHA", 12);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA", 13);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE", 14);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC1_COLOR", 15);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR", 16);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC1_ALPHA", 17);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA", 18);
PyModule_AddIntConstant(module, "VK_BLEND_OP_ADD", 0);
PyModule_AddIntConstant(module, "VK_BLEND_OP_SUBTRACT", 1);
PyModule_AddIntConstant(module, "VK_BLEND_OP_REVERSE_SUBTRACT", 2);
PyModule_AddIntConstant(module, "VK_BLEND_OP_MIN", 3);
PyModule_AddIntConstant(module, "VK_BLEND_OP_MAX", 4);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_KEEP", 0);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_ZERO", 1);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_REPLACE", 2);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_INCREMENT_AND_CLAMP", 3);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_DECREMENT_AND_CLAMP", 4);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_INVERT", 5);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_INCREMENT_AND_WRAP", 6);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_DECREMENT_AND_WRAP", 7);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_CLEAR", 0);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_AND", 1);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_AND_REVERSE", 2);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_COPY", 3);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_AND_INVERTED", 4);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_NO_OP", 5);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_XOR", 6);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_OR", 7);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_NOR", 8);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_EQUIVALENT", 9);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_INVERT", 10);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_OR_REVERSE", 11);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_COPY_INVERTED", 12);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_OR_INVERTED", 13);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_NAND", 14);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_SET", 15);
PyModule_AddIntConstant(module, "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE", 0);
PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND", 0);
PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT", 1);
PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_CACHE", 2);
PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE", 3);
PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE", 4);
PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_OTHER", 0);
PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU", 1);
PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU", 2);
PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU", 3);
PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_CPU", 4);
PyModule_AddIntConstant(module, "VK_VERTEX_INPUT_RATE_VERTEX", 0);
PyModule_AddIntConstant(module, "VK_VERTEX_INPUT_RATE_INSTANCE", 1);
PyModule_AddIntConstant(module, "VK_FORMAT_UNDEFINED", 0);
PyModule_AddIntConstant(module, "VK_FORMAT_R4G4_UNORM_PACK8", 1);
PyModule_AddIntConstant(module, "VK_FORMAT_R4G4B4A4_UNORM_PACK16", 2);
PyModule_AddIntConstant(module, "VK_FORMAT_B4G4R4A4_UNORM_PACK16", 3);
PyModule_AddIntConstant(module, "VK_FORMAT_R5G6B5_UNORM_PACK16", 4);
PyModule_AddIntConstant(module, "VK_FORMAT_B5G6R5_UNORM_PACK16", 5);
PyModule_AddIntConstant(module, "VK_FORMAT_R5G5B5A1_UNORM_PACK16", 6);
PyModule_AddIntConstant(module, "VK_FORMAT_B5G5R5A1_UNORM_PACK16", 7);
PyModule_AddIntConstant(module, "VK_FORMAT_A1R5G5B5_UNORM_PACK16", 8);
PyModule_AddIntConstant(module, "VK_FORMAT_R8_UNORM", 9);
PyModule_AddIntConstant(module, "VK_FORMAT_R8_SNORM", 10);
PyModule_AddIntConstant(module, "VK_FORMAT_R8_USCALED", 11);
PyModule_AddIntConstant(module, "VK_FORMAT_R8_SSCALED", 12);
PyModule_AddIntConstant(module, "VK_FORMAT_R8_UINT", 13);
PyModule_AddIntConstant(module, "VK_FORMAT_R8_SINT", 14);
PyModule_AddIntConstant(module, "VK_FORMAT_R8_SRGB", 15);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_UNORM", 16);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SNORM", 17);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_USCALED", 18);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SSCALED", 19);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_UINT", 20);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SINT", 21);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SRGB", 22);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_UNORM", 23);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SNORM", 24);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_USCALED", 25);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SSCALED", 26);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_UINT", 27);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SINT", 28);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SRGB", 29);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_UNORM", 30);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SNORM", 31);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_USCALED", 32);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SSCALED", 33);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_UINT", 34);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SINT", 35);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SRGB", 36);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_UNORM", 37);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SNORM", 38);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_USCALED", 39);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SSCALED", 40);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_UINT", 41);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SINT", 42);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SRGB", 43);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_UNORM", 44);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SNORM", 45);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_USCALED", 46);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SSCALED", 47);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_UINT", 48);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SINT", 49);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SRGB", 50);
PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_UNORM_PACK32", 51);
PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SNORM_PACK32", 52);
PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_USCALED_PACK32", 53);
PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SSCALED_PACK32", 54);
PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_UINT_PACK32", 55);
PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SINT_PACK32", 56);
PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SRGB_PACK32", 57);
PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_UNORM_PACK32", 58);
PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_SNORM_PACK32", 59);
PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_USCALED_PACK32", 60);
PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_SSCALED_PACK32", 61);
PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_UINT_PACK32", 62);
PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_SINT_PACK32", 63);
PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_UNORM_PACK32", 64);
PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_SNORM_PACK32", 65);
PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_USCALED_PACK32", 66);
PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_SSCALED_PACK32", 67);
PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_UINT_PACK32", 68);
PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_SINT_PACK32", 69);
PyModule_AddIntConstant(module, "VK_FORMAT_R16_UNORM", 70);
PyModule_AddIntConstant(module, "VK_FORMAT_R16_SNORM", 71);
PyModule_AddIntConstant(module, "VK_FORMAT_R16_USCALED", 72);
PyModule_AddIntConstant(module, "VK_FORMAT_R16_SSCALED", 73);
PyModule_AddIntConstant(module, "VK_FORMAT_R16_UINT", 74);
PyModule_AddIntConstant(module, "VK_FORMAT_R16_SINT", 75);
PyModule_AddIntConstant(module, "VK_FORMAT_R16_SFLOAT", 76);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_UNORM", 77);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SNORM", 78);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_USCALED", 79);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SSCALED", 80);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_UINT", 81);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SINT", 82);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SFLOAT", 83);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_UNORM", 84);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SNORM", 85);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_USCALED", 86);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SSCALED", 87);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_UINT", 88);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SINT", 89);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SFLOAT", 90);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_UNORM", 91);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SNORM", 92);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_USCALED", 93);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SSCALED", 94);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_UINT", 95);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SINT", 96);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SFLOAT", 97);
PyModule_AddIntConstant(module, "VK_FORMAT_R32_UINT", 98);
PyModule_AddIntConstant(module, "VK_FORMAT_R32_SINT", 99);
PyModule_AddIntConstant(module, "VK_FORMAT_R32_SFLOAT", 100);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32_UINT", 101);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32_SINT", 102);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32_SFLOAT", 103);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32_UINT", 104);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32_SINT", 105);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32_SFLOAT", 106);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32A32_UINT", 107);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32A32_SINT", 108);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32A32_SFLOAT", 109);
PyModule_AddIntConstant(module, "VK_FORMAT_R64_UINT", 110);
PyModule_AddIntConstant(module, "VK_FORMAT_R64_SINT", 111);
PyModule_AddIntConstant(module, "VK_FORMAT_R64_SFLOAT", 112);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64_UINT", 113);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64_SINT", 114);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64_SFLOAT", 115);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64_UINT", 116);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64_SINT", 117);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64_SFLOAT", 118);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64A64_UINT", 119);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64A64_SINT", 120);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64A64_SFLOAT", 121);
PyModule_AddIntConstant(module, "VK_FORMAT_B10G11R11_UFLOAT_PACK32", 122);
PyModule_AddIntConstant(module, "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32", 123);
PyModule_AddIntConstant(module, "VK_FORMAT_D16_UNORM", 124);
PyModule_AddIntConstant(module, "VK_FORMAT_X8_D24_UNORM_PACK32", 125);
PyModule_AddIntConstant(module, "VK_FORMAT_D32_SFLOAT", 126);
PyModule_AddIntConstant(module, "VK_FORMAT_S8_UINT", 127);
PyModule_AddIntConstant(module, "VK_FORMAT_D16_UNORM_S8_UINT", 128);
PyModule_AddIntConstant(module, "VK_FORMAT_D24_UNORM_S8_UINT", 129);
PyModule_AddIntConstant(module, "VK_FORMAT_D32_SFLOAT_S8_UINT", 130);
PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGB_UNORM_BLOCK", 131);
PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGB_SRGB_BLOCK", 132);
PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGBA_UNORM_BLOCK", 133);
PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGBA_SRGB_BLOCK", 134);
PyModule_AddIntConstant(module, "VK_FORMAT_BC2_UNORM_BLOCK", 135);
PyModule_AddIntConstant(module, "VK_FORMAT_BC2_SRGB_BLOCK", 136);
PyModule_AddIntConstant(module, "VK_FORMAT_BC3_UNORM_BLOCK", 137);
PyModule_AddIntConstant(module, "VK_FORMAT_BC3_SRGB_BLOCK", 138);
PyModule_AddIntConstant(module, "VK_FORMAT_BC4_UNORM_BLOCK", 139);
PyModule_AddIntConstant(module, "VK_FORMAT_BC4_SNORM_BLOCK", 140);
PyModule_AddIntConstant(module, "VK_FORMAT_BC5_UNORM_BLOCK", 141);
PyModule_AddIntConstant(module, "VK_FORMAT_BC5_SNORM_BLOCK", 142);
PyModule_AddIntConstant(module, "VK_FORMAT_BC6H_UFLOAT_BLOCK", 143);
PyModule_AddIntConstant(module, "VK_FORMAT_BC6H_SFLOAT_BLOCK", 144);
PyModule_AddIntConstant(module, "VK_FORMAT_BC7_UNORM_BLOCK", 145);
PyModule_AddIntConstant(module, "VK_FORMAT_BC7_SRGB_BLOCK", 146);
PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK", 147);
PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK", 148);
PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK", 149);
PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK", 150);
PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK", 151);
PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK", 152);
PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11_UNORM_BLOCK", 153);
PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11_SNORM_BLOCK", 154);
PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11G11_UNORM_BLOCK", 155);
PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11G11_SNORM_BLOCK", 156);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_4x4_UNORM_BLOCK", 157);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_4x4_SRGB_BLOCK", 158);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x4_UNORM_BLOCK", 159);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x4_SRGB_BLOCK", 160);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x5_UNORM_BLOCK", 161);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x5_SRGB_BLOCK", 162);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x5_UNORM_BLOCK", 163);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x5_SRGB_BLOCK", 164);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x6_UNORM_BLOCK", 165);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x6_SRGB_BLOCK", 166);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x5_UNORM_BLOCK", 167);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x5_SRGB_BLOCK", 168);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x6_UNORM_BLOCK", 169);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x6_SRGB_BLOCK", 170);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x8_UNORM_BLOCK", 171);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x8_SRGB_BLOCK", 172);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x5_UNORM_BLOCK", 173);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x5_SRGB_BLOCK", 174);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x6_UNORM_BLOCK", 175);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x6_SRGB_BLOCK", 176);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x8_UNORM_BLOCK", 177);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x8_SRGB_BLOCK", 178);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x10_UNORM_BLOCK", 179);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x10_SRGB_BLOCK", 180);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x10_UNORM_BLOCK", 181);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x10_SRGB_BLOCK", 182);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x12_UNORM_BLOCK", 183);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x12_SRGB_BLOCK", 184);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_APPLICATION_INFO", 0);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO", 1);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO", 2);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO", 3);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SUBMIT_INFO", 4);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO", 5);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE", 6);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO", 7);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO", 8);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO", 9);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO", 10);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO", 11);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO", 12);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO", 13);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO", 14);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO", 15);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO", 16);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO", 17);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO", 18);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO", 19);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO", 20);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO", 21);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO", 22);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO", 23);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO", 24);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO", 25);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO", 26);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO", 27);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO", 28);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO", 29);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO", 30);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO", 31);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO", 32);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO", 33);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO", 34);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET", 35);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET", 36);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO", 37);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO", 38);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO", 39);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO", 40);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO", 41);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO", 42);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO", 43);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER", 44);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER", 45);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_MEMORY_BARRIER", 46);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO", 47);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO", 48);
PyModule_AddIntConstant(module, "VK_SUBPASS_CONTENTS_INLINE", 0);
PyModule_AddIntConstant(module, "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS", 1);
PyModule_AddIntConstant(module, "VK_SUCCESS", 0);
PyModule_AddIntConstant(module, "VK_NOT_READY", 1);
PyModule_AddIntConstant(module, "VK_TIMEOUT", 2);
PyModule_AddIntConstant(module, "VK_EVENT_SET", 3);
PyModule_AddIntConstant(module, "VK_EVENT_RESET", 4);
PyModule_AddIntConstant(module, "VK_INCOMPLETE", 5);
PyModule_AddIntConstant(module, "VK_ERROR_OUT_OF_HOST_MEMORY", -1);
PyModule_AddIntConstant(module, "VK_ERROR_OUT_OF_DEVICE_MEMORY", -2);
PyModule_AddIntConstant(module, "VK_ERROR_INITIALIZATION_FAILED", -3);
PyModule_AddIntConstant(module, "VK_ERROR_DEVICE_LOST", -4);
PyModule_AddIntConstant(module, "VK_ERROR_MEMORY_MAP_FAILED", -5);
PyModule_AddIntConstant(module, "VK_ERROR_LAYER_NOT_PRESENT", -6);
PyModule_AddIntConstant(module, "VK_ERROR_EXTENSION_NOT_PRESENT", -7);
PyModule_AddIntConstant(module, "VK_ERROR_FEATURE_NOT_PRESENT", -8);
PyModule_AddIntConstant(module, "VK_ERROR_INCOMPATIBLE_DRIVER", -9);
PyModule_AddIntConstant(module, "VK_ERROR_TOO_MANY_OBJECTS", -10);
PyModule_AddIntConstant(module, "VK_ERROR_FORMAT_NOT_SUPPORTED", -11);
PyModule_AddIntConstant(module, "VK_ERROR_FRAGMENTED_POOL", -12);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_VIEWPORT", 0);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_SCISSOR", 1);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_LINE_WIDTH", 2);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_DEPTH_BIAS", 3);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_BLEND_CONSTANTS", 4);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_DEPTH_BOUNDS", 5);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK", 6);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK", 7);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_STENCIL_REFERENCE", 8);
PyModule_AddIntConstant(module, "VK_QUEUE_GRAPHICS_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_QUEUE_COMPUTE_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_QUEUE_TRANSFER_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_QUEUE_SPARSE_BINDING_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_HOST_CACHED_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_ACCESS_INDIRECT_COMMAND_READ_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_ACCESS_INDEX_READ_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_ACCESS_UNIFORM_READ_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_ACCESS_SHADER_READ_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_ACCESS_SHADER_WRITE_BIT", 0x00000007);
PyModule_AddIntConstant(module, "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT", 0x00000008);
PyModule_AddIntConstant(module, "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT", 0x00000009);
PyModule_AddIntConstant(module, "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT", 0x00000010);
PyModule_AddIntConstant(module, "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT", 0x00000011);
PyModule_AddIntConstant(module, "VK_ACCESS_TRANSFER_READ_BIT", 0x00000012);
PyModule_AddIntConstant(module, "VK_ACCESS_TRANSFER_WRITE_BIT", 0x00000013);
PyModule_AddIntConstant(module, "VK_ACCESS_HOST_READ_BIT", 0x00000014);
PyModule_AddIntConstant(module, "VK_ACCESS_HOST_WRITE_BIT", 0x00000015);
PyModule_AddIntConstant(module, "VK_ACCESS_MEMORY_READ_BIT", 0x00000016);
PyModule_AddIntConstant(module, "VK_ACCESS_MEMORY_WRITE_BIT", 0x00000017);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_TRANSFER_SRC_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_TRANSFER_DST_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_INDEX_BUFFER_BIT", 0x00000007);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT", 0x00000008);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT", 0x00000009);
PyModule_AddIntConstant(module, "VK_BUFFER_CREATE_SPARSE_BINDING_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_VERTEX_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_GEOMETRY_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_FRAGMENT_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_COMPUTE_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_ALL_GRAPHICS", 0x0000001F);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_ALL", 0x7FFFFFFF);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_TRANSFER_SRC_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_TRANSFER_DST_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_SAMPLED_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_STORAGE_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT", 0x00000007);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", 0x00000008);
PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_SPARSE_BINDING_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_PIPELINE_CREATE_DERIVATIVE_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_R_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_G_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_B_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_A_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_FENCE_CREATE_SIGNALED_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT", 0x00000007);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT", 0x00000008);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", 0x00000009);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", 0x00000010);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_BLIT_SRC_BIT", 0x00000011);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_BLIT_DST_BIT", 0x00000012);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", 0x00000013);
PyModule_AddIntConstant(module, "VK_QUERY_CONTROL_PRECISE_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_QUERY_RESULT_64_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_QUERY_RESULT_WAIT_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_QUERY_RESULT_PARTIAL_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT", 0x00000007);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT", 0x00000008);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT", 0x00000009);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT", 0x00000010);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT", 0x00000011);
PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_COLOR_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_DEPTH_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_STENCIL_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_METADATA_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_SPARSE_MEMORY_BIND_METADATA_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", 0x00000007);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT", 0x00000008);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT", 0x00000009);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT", 0x00000010);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT", 0x00000011);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT", 0x00000012);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TRANSFER_BIT", 0x00000013);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT", 0x00000014);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_HOST_BIT", 0x00000015);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT", 0x00000016);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT", 0x00000017);
PyModule_AddIntConstant(module, "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_1_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_2_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_4_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_8_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_16_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_32_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_64_BIT", 0x00000007);
PyModule_AddIntConstant(module, "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_STENCIL_FACE_FRONT_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_STENCIL_FACE_BACK_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_STENCIL_FRONT_AND_BACK", 0x00000003);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_DEPENDENCY_BY_REGION_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_PRESENT_MODE_IMMEDIATE_KHR", 0);
PyModule_AddIntConstant(module, "VK_PRESENT_MODE_MAILBOX_KHR", 1);
PyModule_AddIntConstant(module, "VK_PRESENT_MODE_FIFO_KHR", 2);
PyModule_AddIntConstant(module, "VK_PRESENT_MODE_FIFO_RELAXED_KHR", 3);
PyModule_AddIntConstant(module, "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR", 0);
PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR", 0x00000001);
PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR", 0x00000002);
PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR", 0x00000003);
PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR", 0x00000004);
PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR", 0x00000001);
PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR", 0x00000002);
PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR", 0x00000003);
PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR", 0x00000004);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR", 0x00000001);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR", 0x00000002);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR", 0x00000003);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR", 0x00000004);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR", 0x00000005);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR", 0x00000006);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR", 0x00000007);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR", 0x00000008);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR", 0x00000009);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_INFORMATION_BIT_EXT", 0x00000001);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_WARNING_BIT_EXT", 0x00000002);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT", 0x00000003);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_ERROR_BIT_EXT", 0x00000004);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_DEBUG_BIT_EXT", 0x00000005);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT", 0);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT", 1);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT", 2);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT", 3);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT", 4);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT", 5);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT", 6);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT", 7);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT", 8);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT", 9);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT", 10);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT", 11);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT", 12);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT", 13);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT", 14);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT", 15);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT", 16);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT", 17);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT", 18);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT", 19);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT", 20);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT", 21);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT", 22);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT", 23);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT", 24);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT", 25);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT", 26);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT", 27);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT", 28);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_ERROR_NONE_EXT", 0);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT", 1);
PyModule_AddIntConstant(module, "VK_RASTERIZATION_ORDER_STRICT_AMD", 0);
PyModule_AddIntConstant(module, "VK_RASTERIZATION_ORDER_RELAXED_AMD", 1);
PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV", 0x00000001);
PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV", 0x00000002);
PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV", 0x00000004);
PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV", 0x00000008);
PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV", 0x00000001);
PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV", 0x00000002);
PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV", 0x00000004);

                if (PyType_Ready(&PyVkOffset2DType) < 0)
                    return NULL;
                Py_INCREF(&PyVkOffset2DType);
                PyModule_AddObject(module, "VkOffset2D", (PyObject *)&PyVkOffset2DType);
            
                if (PyType_Ready(&PyVkOffset3DType) < 0)
                    return NULL;
                Py_INCREF(&PyVkOffset3DType);
                PyModule_AddObject(module, "VkOffset3D", (PyObject *)&PyVkOffset3DType);
            
                if (PyType_Ready(&PyVkExtent2DType) < 0)
                    return NULL;
                Py_INCREF(&PyVkExtent2DType);
                PyModule_AddObject(module, "VkExtent2D", (PyObject *)&PyVkExtent2DType);
            
                if (PyType_Ready(&PyVkExtent3DType) < 0)
                    return NULL;
                Py_INCREF(&PyVkExtent3DType);
                PyModule_AddObject(module, "VkExtent3D", (PyObject *)&PyVkExtent3DType);
            
                if (PyType_Ready(&PyVkViewportType) < 0)
                    return NULL;
                Py_INCREF(&PyVkViewportType);
                PyModule_AddObject(module, "VkViewport", (PyObject *)&PyVkViewportType);
            
                if (PyType_Ready(&PyVkRect2DType) < 0)
                    return NULL;
                Py_INCREF(&PyVkRect2DType);
                PyModule_AddObject(module, "VkRect2D", (PyObject *)&PyVkRect2DType);
            
#ifdef hackdefine

                if (PyType_Ready(&PyVkRect3DType) < 0)
                    return NULL;
                Py_INCREF(&PyVkRect3DType);
                PyModule_AddObject(module, "VkRect3D", (PyObject *)&PyVkRect3DType);
            
#endif

                if (PyType_Ready(&PyVkClearRectType) < 0)
                    return NULL;
                Py_INCREF(&PyVkClearRectType);
                PyModule_AddObject(module, "VkClearRect", (PyObject *)&PyVkClearRectType);
            
                if (PyType_Ready(&PyVkComponentMappingType) < 0)
                    return NULL;
                Py_INCREF(&PyVkComponentMappingType);
                PyModule_AddObject(module, "VkComponentMapping", (PyObject *)&PyVkComponentMappingType);
            
                if (PyType_Ready(&PyVkPhysicalDevicePropertiesType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPhysicalDevicePropertiesType);
                PyModule_AddObject(module, "VkPhysicalDeviceProperties", (PyObject *)&PyVkPhysicalDevicePropertiesType);
            
                if (PyType_Ready(&PyVkExtensionPropertiesType) < 0)
                    return NULL;
                Py_INCREF(&PyVkExtensionPropertiesType);
                PyModule_AddObject(module, "VkExtensionProperties", (PyObject *)&PyVkExtensionPropertiesType);
            
                if (PyType_Ready(&PyVkLayerPropertiesType) < 0)
                    return NULL;
                Py_INCREF(&PyVkLayerPropertiesType);
                PyModule_AddObject(module, "VkLayerProperties", (PyObject *)&PyVkLayerPropertiesType);
            
                if (PyType_Ready(&PyVkApplicationInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkApplicationInfoType);
                PyModule_AddObject(module, "VkApplicationInfo", (PyObject *)&PyVkApplicationInfoType);
            
                if (PyType_Ready(&PyVkAllocationCallbacksType) < 0)
                    return NULL;
                Py_INCREF(&PyVkAllocationCallbacksType);
                PyModule_AddObject(module, "VkAllocationCallbacks", (PyObject *)&PyVkAllocationCallbacksType);
            
                if (PyType_Ready(&PyVkDeviceQueueCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDeviceQueueCreateInfoType);
                PyModule_AddObject(module, "VkDeviceQueueCreateInfo", (PyObject *)&PyVkDeviceQueueCreateInfoType);
            
                if (PyType_Ready(&PyVkDeviceCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDeviceCreateInfoType);
                PyModule_AddObject(module, "VkDeviceCreateInfo", (PyObject *)&PyVkDeviceCreateInfoType);
            
                if (PyType_Ready(&PyVkInstanceCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkInstanceCreateInfoType);
                PyModule_AddObject(module, "VkInstanceCreateInfo", (PyObject *)&PyVkInstanceCreateInfoType);
            
                if (PyType_Ready(&PyVkQueueFamilyPropertiesType) < 0)
                    return NULL;
                Py_INCREF(&PyVkQueueFamilyPropertiesType);
                PyModule_AddObject(module, "VkQueueFamilyProperties", (PyObject *)&PyVkQueueFamilyPropertiesType);
            
                if (PyType_Ready(&PyVkPhysicalDeviceMemoryPropertiesType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPhysicalDeviceMemoryPropertiesType);
                PyModule_AddObject(module, "VkPhysicalDeviceMemoryProperties", (PyObject *)&PyVkPhysicalDeviceMemoryPropertiesType);
            
                if (PyType_Ready(&PyVkMemoryAllocateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkMemoryAllocateInfoType);
                PyModule_AddObject(module, "VkMemoryAllocateInfo", (PyObject *)&PyVkMemoryAllocateInfoType);
            
                if (PyType_Ready(&PyVkMemoryRequirementsType) < 0)
                    return NULL;
                Py_INCREF(&PyVkMemoryRequirementsType);
                PyModule_AddObject(module, "VkMemoryRequirements", (PyObject *)&PyVkMemoryRequirementsType);
            
                if (PyType_Ready(&PyVkSparseImageFormatPropertiesType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSparseImageFormatPropertiesType);
                PyModule_AddObject(module, "VkSparseImageFormatProperties", (PyObject *)&PyVkSparseImageFormatPropertiesType);
            
                if (PyType_Ready(&PyVkSparseImageMemoryRequirementsType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSparseImageMemoryRequirementsType);
                PyModule_AddObject(module, "VkSparseImageMemoryRequirements", (PyObject *)&PyVkSparseImageMemoryRequirementsType);
            
                if (PyType_Ready(&PyVkMemoryTypeType) < 0)
                    return NULL;
                Py_INCREF(&PyVkMemoryTypeType);
                PyModule_AddObject(module, "VkMemoryType", (PyObject *)&PyVkMemoryTypeType);
            
                if (PyType_Ready(&PyVkMemoryHeapType) < 0)
                    return NULL;
                Py_INCREF(&PyVkMemoryHeapType);
                PyModule_AddObject(module, "VkMemoryHeap", (PyObject *)&PyVkMemoryHeapType);
            
                if (PyType_Ready(&PyVkMappedMemoryRangeType) < 0)
                    return NULL;
                Py_INCREF(&PyVkMappedMemoryRangeType);
                PyModule_AddObject(module, "VkMappedMemoryRange", (PyObject *)&PyVkMappedMemoryRangeType);
            
                if (PyType_Ready(&PyVkFormatPropertiesType) < 0)
                    return NULL;
                Py_INCREF(&PyVkFormatPropertiesType);
                PyModule_AddObject(module, "VkFormatProperties", (PyObject *)&PyVkFormatPropertiesType);
            
                if (PyType_Ready(&PyVkImageFormatPropertiesType) < 0)
                    return NULL;
                Py_INCREF(&PyVkImageFormatPropertiesType);
                PyModule_AddObject(module, "VkImageFormatProperties", (PyObject *)&PyVkImageFormatPropertiesType);
            
                if (PyType_Ready(&PyVkDescriptorBufferInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDescriptorBufferInfoType);
                PyModule_AddObject(module, "VkDescriptorBufferInfo", (PyObject *)&PyVkDescriptorBufferInfoType);
            
                if (PyType_Ready(&PyVkDescriptorImageInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDescriptorImageInfoType);
                PyModule_AddObject(module, "VkDescriptorImageInfo", (PyObject *)&PyVkDescriptorImageInfoType);
            
                if (PyType_Ready(&PyVkWriteDescriptorSetType) < 0)
                    return NULL;
                Py_INCREF(&PyVkWriteDescriptorSetType);
                PyModule_AddObject(module, "VkWriteDescriptorSet", (PyObject *)&PyVkWriteDescriptorSetType);
            
                if (PyType_Ready(&PyVkCopyDescriptorSetType) < 0)
                    return NULL;
                Py_INCREF(&PyVkCopyDescriptorSetType);
                PyModule_AddObject(module, "VkCopyDescriptorSet", (PyObject *)&PyVkCopyDescriptorSetType);
            
                if (PyType_Ready(&PyVkBufferCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkBufferCreateInfoType);
                PyModule_AddObject(module, "VkBufferCreateInfo", (PyObject *)&PyVkBufferCreateInfoType);
            
                if (PyType_Ready(&PyVkBufferViewCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkBufferViewCreateInfoType);
                PyModule_AddObject(module, "VkBufferViewCreateInfo", (PyObject *)&PyVkBufferViewCreateInfoType);
            
                if (PyType_Ready(&PyVkImageSubresourceType) < 0)
                    return NULL;
                Py_INCREF(&PyVkImageSubresourceType);
                PyModule_AddObject(module, "VkImageSubresource", (PyObject *)&PyVkImageSubresourceType);
            
                if (PyType_Ready(&PyVkImageSubresourceLayersType) < 0)
                    return NULL;
                Py_INCREF(&PyVkImageSubresourceLayersType);
                PyModule_AddObject(module, "VkImageSubresourceLayers", (PyObject *)&PyVkImageSubresourceLayersType);
            
                if (PyType_Ready(&PyVkImageSubresourceRangeType) < 0)
                    return NULL;
                Py_INCREF(&PyVkImageSubresourceRangeType);
                PyModule_AddObject(module, "VkImageSubresourceRange", (PyObject *)&PyVkImageSubresourceRangeType);
            
                if (PyType_Ready(&PyVkMemoryBarrierType) < 0)
                    return NULL;
                Py_INCREF(&PyVkMemoryBarrierType);
                PyModule_AddObject(module, "VkMemoryBarrier", (PyObject *)&PyVkMemoryBarrierType);
            
                if (PyType_Ready(&PyVkBufferMemoryBarrierType) < 0)
                    return NULL;
                Py_INCREF(&PyVkBufferMemoryBarrierType);
                PyModule_AddObject(module, "VkBufferMemoryBarrier", (PyObject *)&PyVkBufferMemoryBarrierType);
            
                if (PyType_Ready(&PyVkImageMemoryBarrierType) < 0)
                    return NULL;
                Py_INCREF(&PyVkImageMemoryBarrierType);
                PyModule_AddObject(module, "VkImageMemoryBarrier", (PyObject *)&PyVkImageMemoryBarrierType);
            
                if (PyType_Ready(&PyVkImageCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkImageCreateInfoType);
                PyModule_AddObject(module, "VkImageCreateInfo", (PyObject *)&PyVkImageCreateInfoType);
            
                if (PyType_Ready(&PyVkSubresourceLayoutType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSubresourceLayoutType);
                PyModule_AddObject(module, "VkSubresourceLayout", (PyObject *)&PyVkSubresourceLayoutType);
            
                if (PyType_Ready(&PyVkImageViewCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkImageViewCreateInfoType);
                PyModule_AddObject(module, "VkImageViewCreateInfo", (PyObject *)&PyVkImageViewCreateInfoType);
            
                if (PyType_Ready(&PyVkBufferCopyType) < 0)
                    return NULL;
                Py_INCREF(&PyVkBufferCopyType);
                PyModule_AddObject(module, "VkBufferCopy", (PyObject *)&PyVkBufferCopyType);
            
                if (PyType_Ready(&PyVkSparseMemoryBindType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSparseMemoryBindType);
                PyModule_AddObject(module, "VkSparseMemoryBind", (PyObject *)&PyVkSparseMemoryBindType);
            
                if (PyType_Ready(&PyVkSparseImageMemoryBindType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSparseImageMemoryBindType);
                PyModule_AddObject(module, "VkSparseImageMemoryBind", (PyObject *)&PyVkSparseImageMemoryBindType);
            
                if (PyType_Ready(&PyVkSparseBufferMemoryBindInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSparseBufferMemoryBindInfoType);
                PyModule_AddObject(module, "VkSparseBufferMemoryBindInfo", (PyObject *)&PyVkSparseBufferMemoryBindInfoType);
            
                if (PyType_Ready(&PyVkSparseImageOpaqueMemoryBindInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSparseImageOpaqueMemoryBindInfoType);
                PyModule_AddObject(module, "VkSparseImageOpaqueMemoryBindInfo", (PyObject *)&PyVkSparseImageOpaqueMemoryBindInfoType);
            
                if (PyType_Ready(&PyVkSparseImageMemoryBindInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSparseImageMemoryBindInfoType);
                PyModule_AddObject(module, "VkSparseImageMemoryBindInfo", (PyObject *)&PyVkSparseImageMemoryBindInfoType);
            
                if (PyType_Ready(&PyVkBindSparseInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkBindSparseInfoType);
                PyModule_AddObject(module, "VkBindSparseInfo", (PyObject *)&PyVkBindSparseInfoType);
            
                if (PyType_Ready(&PyVkImageCopyType) < 0)
                    return NULL;
                Py_INCREF(&PyVkImageCopyType);
                PyModule_AddObject(module, "VkImageCopy", (PyObject *)&PyVkImageCopyType);
            
                if (PyType_Ready(&PyVkImageBlitType) < 0)
                    return NULL;
                Py_INCREF(&PyVkImageBlitType);
                PyModule_AddObject(module, "VkImageBlit", (PyObject *)&PyVkImageBlitType);
            
                if (PyType_Ready(&PyVkBufferImageCopyType) < 0)
                    return NULL;
                Py_INCREF(&PyVkBufferImageCopyType);
                PyModule_AddObject(module, "VkBufferImageCopy", (PyObject *)&PyVkBufferImageCopyType);
            
                if (PyType_Ready(&PyVkImageResolveType) < 0)
                    return NULL;
                Py_INCREF(&PyVkImageResolveType);
                PyModule_AddObject(module, "VkImageResolve", (PyObject *)&PyVkImageResolveType);
            
                if (PyType_Ready(&PyVkShaderModuleCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkShaderModuleCreateInfoType);
                PyModule_AddObject(module, "VkShaderModuleCreateInfo", (PyObject *)&PyVkShaderModuleCreateInfoType);
            
                if (PyType_Ready(&PyVkDescriptorSetLayoutBindingType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDescriptorSetLayoutBindingType);
                PyModule_AddObject(module, "VkDescriptorSetLayoutBinding", (PyObject *)&PyVkDescriptorSetLayoutBindingType);
            
                if (PyType_Ready(&PyVkDescriptorSetLayoutCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDescriptorSetLayoutCreateInfoType);
                PyModule_AddObject(module, "VkDescriptorSetLayoutCreateInfo", (PyObject *)&PyVkDescriptorSetLayoutCreateInfoType);
            
                if (PyType_Ready(&PyVkDescriptorPoolSizeType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDescriptorPoolSizeType);
                PyModule_AddObject(module, "VkDescriptorPoolSize", (PyObject *)&PyVkDescriptorPoolSizeType);
            
                if (PyType_Ready(&PyVkDescriptorPoolCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDescriptorPoolCreateInfoType);
                PyModule_AddObject(module, "VkDescriptorPoolCreateInfo", (PyObject *)&PyVkDescriptorPoolCreateInfoType);
            
                if (PyType_Ready(&PyVkDescriptorSetAllocateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDescriptorSetAllocateInfoType);
                PyModule_AddObject(module, "VkDescriptorSetAllocateInfo", (PyObject *)&PyVkDescriptorSetAllocateInfoType);
            
                if (PyType_Ready(&PyVkSpecializationMapEntryType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSpecializationMapEntryType);
                PyModule_AddObject(module, "VkSpecializationMapEntry", (PyObject *)&PyVkSpecializationMapEntryType);
            
                if (PyType_Ready(&PyVkSpecializationInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSpecializationInfoType);
                PyModule_AddObject(module, "VkSpecializationInfo", (PyObject *)&PyVkSpecializationInfoType);
            
                if (PyType_Ready(&PyVkPipelineShaderStageCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPipelineShaderStageCreateInfoType);
                PyModule_AddObject(module, "VkPipelineShaderStageCreateInfo", (PyObject *)&PyVkPipelineShaderStageCreateInfoType);
            
                if (PyType_Ready(&PyVkComputePipelineCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkComputePipelineCreateInfoType);
                PyModule_AddObject(module, "VkComputePipelineCreateInfo", (PyObject *)&PyVkComputePipelineCreateInfoType);
            
                if (PyType_Ready(&PyVkVertexInputBindingDescriptionType) < 0)
                    return NULL;
                Py_INCREF(&PyVkVertexInputBindingDescriptionType);
                PyModule_AddObject(module, "VkVertexInputBindingDescription", (PyObject *)&PyVkVertexInputBindingDescriptionType);
            
                if (PyType_Ready(&PyVkVertexInputAttributeDescriptionType) < 0)
                    return NULL;
                Py_INCREF(&PyVkVertexInputAttributeDescriptionType);
                PyModule_AddObject(module, "VkVertexInputAttributeDescription", (PyObject *)&PyVkVertexInputAttributeDescriptionType);
            
                if (PyType_Ready(&PyVkPipelineVertexInputStateCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPipelineVertexInputStateCreateInfoType);
                PyModule_AddObject(module, "VkPipelineVertexInputStateCreateInfo", (PyObject *)&PyVkPipelineVertexInputStateCreateInfoType);
            
                if (PyType_Ready(&PyVkPipelineInputAssemblyStateCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPipelineInputAssemblyStateCreateInfoType);
                PyModule_AddObject(module, "VkPipelineInputAssemblyStateCreateInfo", (PyObject *)&PyVkPipelineInputAssemblyStateCreateInfoType);
            
                if (PyType_Ready(&PyVkPipelineTessellationStateCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPipelineTessellationStateCreateInfoType);
                PyModule_AddObject(module, "VkPipelineTessellationStateCreateInfo", (PyObject *)&PyVkPipelineTessellationStateCreateInfoType);
            
                if (PyType_Ready(&PyVkPipelineViewportStateCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPipelineViewportStateCreateInfoType);
                PyModule_AddObject(module, "VkPipelineViewportStateCreateInfo", (PyObject *)&PyVkPipelineViewportStateCreateInfoType);
            
                if (PyType_Ready(&PyVkPipelineRasterizationStateCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPipelineRasterizationStateCreateInfoType);
                PyModule_AddObject(module, "VkPipelineRasterizationStateCreateInfo", (PyObject *)&PyVkPipelineRasterizationStateCreateInfoType);
            
                if (PyType_Ready(&PyVkPipelineMultisampleStateCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPipelineMultisampleStateCreateInfoType);
                PyModule_AddObject(module, "VkPipelineMultisampleStateCreateInfo", (PyObject *)&PyVkPipelineMultisampleStateCreateInfoType);
            
                if (PyType_Ready(&PyVkPipelineColorBlendAttachmentStateType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPipelineColorBlendAttachmentStateType);
                PyModule_AddObject(module, "VkPipelineColorBlendAttachmentState", (PyObject *)&PyVkPipelineColorBlendAttachmentStateType);
            
                if (PyType_Ready(&PyVkPipelineColorBlendStateCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPipelineColorBlendStateCreateInfoType);
                PyModule_AddObject(module, "VkPipelineColorBlendStateCreateInfo", (PyObject *)&PyVkPipelineColorBlendStateCreateInfoType);
            
                if (PyType_Ready(&PyVkPipelineDynamicStateCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPipelineDynamicStateCreateInfoType);
                PyModule_AddObject(module, "VkPipelineDynamicStateCreateInfo", (PyObject *)&PyVkPipelineDynamicStateCreateInfoType);
            
                if (PyType_Ready(&PyVkStencilOpStateType) < 0)
                    return NULL;
                Py_INCREF(&PyVkStencilOpStateType);
                PyModule_AddObject(module, "VkStencilOpState", (PyObject *)&PyVkStencilOpStateType);
            
                if (PyType_Ready(&PyVkPipelineDepthStencilStateCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPipelineDepthStencilStateCreateInfoType);
                PyModule_AddObject(module, "VkPipelineDepthStencilStateCreateInfo", (PyObject *)&PyVkPipelineDepthStencilStateCreateInfoType);
            
                if (PyType_Ready(&PyVkGraphicsPipelineCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkGraphicsPipelineCreateInfoType);
                PyModule_AddObject(module, "VkGraphicsPipelineCreateInfo", (PyObject *)&PyVkGraphicsPipelineCreateInfoType);
            
                if (PyType_Ready(&PyVkPipelineCacheCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPipelineCacheCreateInfoType);
                PyModule_AddObject(module, "VkPipelineCacheCreateInfo", (PyObject *)&PyVkPipelineCacheCreateInfoType);
            
                if (PyType_Ready(&PyVkPushConstantRangeType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPushConstantRangeType);
                PyModule_AddObject(module, "VkPushConstantRange", (PyObject *)&PyVkPushConstantRangeType);
            
                if (PyType_Ready(&PyVkPipelineLayoutCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPipelineLayoutCreateInfoType);
                PyModule_AddObject(module, "VkPipelineLayoutCreateInfo", (PyObject *)&PyVkPipelineLayoutCreateInfoType);
            
                if (PyType_Ready(&PyVkSamplerCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSamplerCreateInfoType);
                PyModule_AddObject(module, "VkSamplerCreateInfo", (PyObject *)&PyVkSamplerCreateInfoType);
            
                if (PyType_Ready(&PyVkCommandPoolCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkCommandPoolCreateInfoType);
                PyModule_AddObject(module, "VkCommandPoolCreateInfo", (PyObject *)&PyVkCommandPoolCreateInfoType);
            
                if (PyType_Ready(&PyVkCommandBufferAllocateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkCommandBufferAllocateInfoType);
                PyModule_AddObject(module, "VkCommandBufferAllocateInfo", (PyObject *)&PyVkCommandBufferAllocateInfoType);
            
                if (PyType_Ready(&PyVkCommandBufferInheritanceInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkCommandBufferInheritanceInfoType);
                PyModule_AddObject(module, "VkCommandBufferInheritanceInfo", (PyObject *)&PyVkCommandBufferInheritanceInfoType);
            
                if (PyType_Ready(&PyVkCommandBufferBeginInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkCommandBufferBeginInfoType);
                PyModule_AddObject(module, "VkCommandBufferBeginInfo", (PyObject *)&PyVkCommandBufferBeginInfoType);
            
                if (PyType_Ready(&PyVkRenderPassBeginInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkRenderPassBeginInfoType);
                PyModule_AddObject(module, "VkRenderPassBeginInfo", (PyObject *)&PyVkRenderPassBeginInfoType);
            
                if (PyType_Ready(&PyVkClearDepthStencilValueType) < 0)
                    return NULL;
                Py_INCREF(&PyVkClearDepthStencilValueType);
                PyModule_AddObject(module, "VkClearDepthStencilValue", (PyObject *)&PyVkClearDepthStencilValueType);
            
                if (PyType_Ready(&PyVkClearAttachmentType) < 0)
                    return NULL;
                Py_INCREF(&PyVkClearAttachmentType);
                PyModule_AddObject(module, "VkClearAttachment", (PyObject *)&PyVkClearAttachmentType);
            
                if (PyType_Ready(&PyVkAttachmentDescriptionType) < 0)
                    return NULL;
                Py_INCREF(&PyVkAttachmentDescriptionType);
                PyModule_AddObject(module, "VkAttachmentDescription", (PyObject *)&PyVkAttachmentDescriptionType);
            
                if (PyType_Ready(&PyVkAttachmentReferenceType) < 0)
                    return NULL;
                Py_INCREF(&PyVkAttachmentReferenceType);
                PyModule_AddObject(module, "VkAttachmentReference", (PyObject *)&PyVkAttachmentReferenceType);
            
                if (PyType_Ready(&PyVkSubpassDescriptionType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSubpassDescriptionType);
                PyModule_AddObject(module, "VkSubpassDescription", (PyObject *)&PyVkSubpassDescriptionType);
            
                if (PyType_Ready(&PyVkSubpassDependencyType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSubpassDependencyType);
                PyModule_AddObject(module, "VkSubpassDependency", (PyObject *)&PyVkSubpassDependencyType);
            
                if (PyType_Ready(&PyVkRenderPassCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkRenderPassCreateInfoType);
                PyModule_AddObject(module, "VkRenderPassCreateInfo", (PyObject *)&PyVkRenderPassCreateInfoType);
            
                if (PyType_Ready(&PyVkEventCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkEventCreateInfoType);
                PyModule_AddObject(module, "VkEventCreateInfo", (PyObject *)&PyVkEventCreateInfoType);
            
                if (PyType_Ready(&PyVkFenceCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkFenceCreateInfoType);
                PyModule_AddObject(module, "VkFenceCreateInfo", (PyObject *)&PyVkFenceCreateInfoType);
            
                if (PyType_Ready(&PyVkPhysicalDeviceFeaturesType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPhysicalDeviceFeaturesType);
                PyModule_AddObject(module, "VkPhysicalDeviceFeatures", (PyObject *)&PyVkPhysicalDeviceFeaturesType);
            
                if (PyType_Ready(&PyVkPhysicalDeviceSparsePropertiesType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPhysicalDeviceSparsePropertiesType);
                PyModule_AddObject(module, "VkPhysicalDeviceSparseProperties", (PyObject *)&PyVkPhysicalDeviceSparsePropertiesType);
            
                if (PyType_Ready(&PyVkPhysicalDeviceLimitsType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPhysicalDeviceLimitsType);
                PyModule_AddObject(module, "VkPhysicalDeviceLimits", (PyObject *)&PyVkPhysicalDeviceLimitsType);
            
                if (PyType_Ready(&PyVkSemaphoreCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSemaphoreCreateInfoType);
                PyModule_AddObject(module, "VkSemaphoreCreateInfo", (PyObject *)&PyVkSemaphoreCreateInfoType);
            
                if (PyType_Ready(&PyVkQueryPoolCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkQueryPoolCreateInfoType);
                PyModule_AddObject(module, "VkQueryPoolCreateInfo", (PyObject *)&PyVkQueryPoolCreateInfoType);
            
                if (PyType_Ready(&PyVkFramebufferCreateInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkFramebufferCreateInfoType);
                PyModule_AddObject(module, "VkFramebufferCreateInfo", (PyObject *)&PyVkFramebufferCreateInfoType);
            
                if (PyType_Ready(&PyVkDrawIndirectCommandType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDrawIndirectCommandType);
                PyModule_AddObject(module, "VkDrawIndirectCommand", (PyObject *)&PyVkDrawIndirectCommandType);
            
                if (PyType_Ready(&PyVkDrawIndexedIndirectCommandType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDrawIndexedIndirectCommandType);
                PyModule_AddObject(module, "VkDrawIndexedIndirectCommand", (PyObject *)&PyVkDrawIndexedIndirectCommandType);
            
                if (PyType_Ready(&PyVkDispatchIndirectCommandType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDispatchIndirectCommandType);
                PyModule_AddObject(module, "VkDispatchIndirectCommand", (PyObject *)&PyVkDispatchIndirectCommandType);
            
                if (PyType_Ready(&PyVkSubmitInfoType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSubmitInfoType);
                PyModule_AddObject(module, "VkSubmitInfo", (PyObject *)&PyVkSubmitInfoType);
            
                if (PyType_Ready(&PyVkDisplayPropertiesKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDisplayPropertiesKHRType);
                PyModule_AddObject(module, "VkDisplayPropertiesKHR", (PyObject *)&PyVkDisplayPropertiesKHRType);
            
                if (PyType_Ready(&PyVkDisplayPlanePropertiesKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDisplayPlanePropertiesKHRType);
                PyModule_AddObject(module, "VkDisplayPlanePropertiesKHR", (PyObject *)&PyVkDisplayPlanePropertiesKHRType);
            
                if (PyType_Ready(&PyVkDisplayModeParametersKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDisplayModeParametersKHRType);
                PyModule_AddObject(module, "VkDisplayModeParametersKHR", (PyObject *)&PyVkDisplayModeParametersKHRType);
            
                if (PyType_Ready(&PyVkDisplayModePropertiesKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDisplayModePropertiesKHRType);
                PyModule_AddObject(module, "VkDisplayModePropertiesKHR", (PyObject *)&PyVkDisplayModePropertiesKHRType);
            
                if (PyType_Ready(&PyVkDisplayModeCreateInfoKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDisplayModeCreateInfoKHRType);
                PyModule_AddObject(module, "VkDisplayModeCreateInfoKHR", (PyObject *)&PyVkDisplayModeCreateInfoKHRType);
            
                if (PyType_Ready(&PyVkDisplayPlaneCapabilitiesKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDisplayPlaneCapabilitiesKHRType);
                PyModule_AddObject(module, "VkDisplayPlaneCapabilitiesKHR", (PyObject *)&PyVkDisplayPlaneCapabilitiesKHRType);
            
                if (PyType_Ready(&PyVkDisplaySurfaceCreateInfoKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDisplaySurfaceCreateInfoKHRType);
                PyModule_AddObject(module, "VkDisplaySurfaceCreateInfoKHR", (PyObject *)&PyVkDisplaySurfaceCreateInfoKHRType);
            
                if (PyType_Ready(&PyVkDisplayPresentInfoKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDisplayPresentInfoKHRType);
                PyModule_AddObject(module, "VkDisplayPresentInfoKHR", (PyObject *)&PyVkDisplayPresentInfoKHRType);
            
                if (PyType_Ready(&PyVkSurfaceCapabilitiesKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSurfaceCapabilitiesKHRType);
                PyModule_AddObject(module, "VkSurfaceCapabilitiesKHR", (PyObject *)&PyVkSurfaceCapabilitiesKHRType);
            
#ifdef VK_USE_PLATFORM_ANDROID_KHR

                if (PyType_Ready(&PyVkAndroidSurfaceCreateInfoKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkAndroidSurfaceCreateInfoKHRType);
                PyModule_AddObject(module, "VkAndroidSurfaceCreateInfoKHR", (PyObject *)&PyVkAndroidSurfaceCreateInfoKHRType);
            
#endif

#ifdef VK_USE_PLATFORM_MIR_KHR

                if (PyType_Ready(&PyVkMirSurfaceCreateInfoKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkMirSurfaceCreateInfoKHRType);
                PyModule_AddObject(module, "VkMirSurfaceCreateInfoKHR", (PyObject *)&PyVkMirSurfaceCreateInfoKHRType);
            
#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

                if (PyType_Ready(&PyVkWaylandSurfaceCreateInfoKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkWaylandSurfaceCreateInfoKHRType);
                PyModule_AddObject(module, "VkWaylandSurfaceCreateInfoKHR", (PyObject *)&PyVkWaylandSurfaceCreateInfoKHRType);
            
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

                if (PyType_Ready(&PyVkWin32SurfaceCreateInfoKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkWin32SurfaceCreateInfoKHRType);
                PyModule_AddObject(module, "VkWin32SurfaceCreateInfoKHR", (PyObject *)&PyVkWin32SurfaceCreateInfoKHRType);
            
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR

                if (PyType_Ready(&PyVkXlibSurfaceCreateInfoKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkXlibSurfaceCreateInfoKHRType);
                PyModule_AddObject(module, "VkXlibSurfaceCreateInfoKHR", (PyObject *)&PyVkXlibSurfaceCreateInfoKHRType);
            
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

                if (PyType_Ready(&PyVkXcbSurfaceCreateInfoKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkXcbSurfaceCreateInfoKHRType);
                PyModule_AddObject(module, "VkXcbSurfaceCreateInfoKHR", (PyObject *)&PyVkXcbSurfaceCreateInfoKHRType);
            
#endif

                if (PyType_Ready(&PyVkSurfaceFormatKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSurfaceFormatKHRType);
                PyModule_AddObject(module, "VkSurfaceFormatKHR", (PyObject *)&PyVkSurfaceFormatKHRType);
            
                if (PyType_Ready(&PyVkSwapchainCreateInfoKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkSwapchainCreateInfoKHRType);
                PyModule_AddObject(module, "VkSwapchainCreateInfoKHR", (PyObject *)&PyVkSwapchainCreateInfoKHRType);
            
                if (PyType_Ready(&PyVkPresentInfoKHRType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPresentInfoKHRType);
                PyModule_AddObject(module, "VkPresentInfoKHR", (PyObject *)&PyVkPresentInfoKHRType);
            
                if (PyType_Ready(&PyVkDebugReportCallbackCreateInfoEXTType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDebugReportCallbackCreateInfoEXTType);
                PyModule_AddObject(module, "VkDebugReportCallbackCreateInfoEXT", (PyObject *)&PyVkDebugReportCallbackCreateInfoEXTType);
            
                if (PyType_Ready(&PyVkDebugReportLayerFlagsEXTType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDebugReportLayerFlagsEXTType);
                PyModule_AddObject(module, "VkDebugReportLayerFlagsEXT", (PyObject *)&PyVkDebugReportLayerFlagsEXTType);
            
                if (PyType_Ready(&PyVkPipelineRasterizationStateRasterizationOrderAMDType) < 0)
                    return NULL;
                Py_INCREF(&PyVkPipelineRasterizationStateRasterizationOrderAMDType);
                PyModule_AddObject(module, "VkPipelineRasterizationStateRasterizationOrderAMD", (PyObject *)&PyVkPipelineRasterizationStateRasterizationOrderAMDType);
            
                if (PyType_Ready(&PyVkDebugMarkerObjectNameInfoEXTType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDebugMarkerObjectNameInfoEXTType);
                PyModule_AddObject(module, "VkDebugMarkerObjectNameInfoEXT", (PyObject *)&PyVkDebugMarkerObjectNameInfoEXTType);
            
                if (PyType_Ready(&PyVkDebugMarkerObjectTagInfoEXTType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDebugMarkerObjectTagInfoEXTType);
                PyModule_AddObject(module, "VkDebugMarkerObjectTagInfoEXT", (PyObject *)&PyVkDebugMarkerObjectTagInfoEXTType);
            
                if (PyType_Ready(&PyVkDebugMarkerMarkerInfoEXTType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDebugMarkerMarkerInfoEXTType);
                PyModule_AddObject(module, "VkDebugMarkerMarkerInfoEXT", (PyObject *)&PyVkDebugMarkerMarkerInfoEXTType);
            
                if (PyType_Ready(&PyVkDedicatedAllocationImageCreateInfoNVType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDedicatedAllocationImageCreateInfoNVType);
                PyModule_AddObject(module, "VkDedicatedAllocationImageCreateInfoNV", (PyObject *)&PyVkDedicatedAllocationImageCreateInfoNVType);
            
                if (PyType_Ready(&PyVkDedicatedAllocationBufferCreateInfoNVType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDedicatedAllocationBufferCreateInfoNVType);
                PyModule_AddObject(module, "VkDedicatedAllocationBufferCreateInfoNV", (PyObject *)&PyVkDedicatedAllocationBufferCreateInfoNVType);
            
                if (PyType_Ready(&PyVkDedicatedAllocationMemoryAllocateInfoNVType) < 0)
                    return NULL;
                Py_INCREF(&PyVkDedicatedAllocationMemoryAllocateInfoNVType);
                PyModule_AddObject(module, "VkDedicatedAllocationMemoryAllocateInfoNV", (PyObject *)&PyVkDedicatedAllocationMemoryAllocateInfoNVType);
            
                if (PyType_Ready(&PyVkExternalImageFormatPropertiesNVType) < 0)
                    return NULL;
                Py_INCREF(&PyVkExternalImageFormatPropertiesNVType);
                PyModule_AddObject(module, "VkExternalImageFormatPropertiesNV", (PyObject *)&PyVkExternalImageFormatPropertiesNVType);
            
                if (PyType_Ready(&PyVkExternalMemoryImageCreateInfoNVType) < 0)
                    return NULL;
                Py_INCREF(&PyVkExternalMemoryImageCreateInfoNVType);
                PyModule_AddObject(module, "VkExternalMemoryImageCreateInfoNV", (PyObject *)&PyVkExternalMemoryImageCreateInfoNVType);
            
                if (PyType_Ready(&PyVkExportMemoryAllocateInfoNVType) < 0)
                    return NULL;
                Py_INCREF(&PyVkExportMemoryAllocateInfoNVType);
                PyModule_AddObject(module, "VkExportMemoryAllocateInfoNV", (PyObject *)&PyVkExportMemoryAllocateInfoNVType);
            
#ifdef VK_USE_PLATFORM_WIN32_KHR

                if (PyType_Ready(&PyVkImportMemoryWin32HandleInfoNVType) < 0)
                    return NULL;
                Py_INCREF(&PyVkImportMemoryWin32HandleInfoNVType);
                PyModule_AddObject(module, "VkImportMemoryWin32HandleInfoNV", (PyObject *)&PyVkImportMemoryWin32HandleInfoNVType);
            
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

                if (PyType_Ready(&PyVkExportMemoryWin32HandleInfoNVType) < 0)
                    return NULL;
                Py_INCREF(&PyVkExportMemoryWin32HandleInfoNVType);
                PyModule_AddObject(module, "VkExportMemoryWin32HandleInfoNV", (PyObject *)&PyVkExportMemoryWin32HandleInfoNVType);
            
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

                if (PyType_Ready(&PyVkWin32KeyedMutexAcquireReleaseInfoNVType) < 0)
                    return NULL;
                Py_INCREF(&PyVkWin32KeyedMutexAcquireReleaseInfoNVType);
                PyModule_AddObject(module, "VkWin32KeyedMutexAcquireReleaseInfoNV", (PyObject *)&PyVkWin32KeyedMutexAcquireReleaseInfoNVType);
            
#endif

                if (PyType_Ready(&PyVkClearColorValueType) < 0)
                    return NULL;
                Py_INCREF(&PyVkClearColorValueType);
                PyModule_AddObject(module, "VkClearColorValue", (PyObject *)&PyVkClearColorValueType);
            
                if (PyType_Ready(&PyVkClearValueType) < 0)
                    return NULL;
                Py_INCREF(&PyVkClearValueType);
                PyModule_AddObject(module, "VkClearValue", (PyObject *)&PyVkClearValueType);
            return module;
}
